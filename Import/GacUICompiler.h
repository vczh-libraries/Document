/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "GacUIReflection.h"
#include "GacUI.h"
#include "VlppWorkflowCompiler.h"
#include "VlppGlrParser.h"
#include "VlppWorkflowLibrary.h"
#include "VlppReflection.h"
#include "VlppOS.h"
#include "Vlpp.h"
#include "VlppRegex.h"
#include "VlppWorkflowRuntime.h"

/***********************************************************************
.\GUICPPGEN.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Loader

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUICPPGEN
#define VCZH_PRESENTATION_REFLECTION_GUICPPGEN


namespace vl
{
	namespace presentation
	{
		extern bool										WriteErrors(
															collections::List<GuiResourceError>& errors,
															const filesystem::FilePath& errorPath
															);

		extern Ptr<GuiResourceFolder>					PrecompileResource(
															Ptr<GuiResource> resource,
															GuiResourceCpuArchitecture targetCpuArchitecture,
															IGuiResourcePrecompileCallback* callback,
															collections::List<GuiResourceError>& errors);

		extern Ptr<GuiInstanceCompiledWorkflow>			WriteWorkflowScript(
															Ptr<GuiResourceFolder> precompiledFolder,
															const WString& assemblyResourcePath,
															const filesystem::FilePath& workflowPath);

		extern Ptr<workflow::cppcodegen::WfCppOutput>	WriteCppCodesToFile(
															Ptr<GuiResource> resource,
															Ptr<GuiInstanceCompiledWorkflow> compiled,
															Ptr<workflow::cppcodegen::WfCppInput> cppInput,
															const filesystem::FilePath& cppFolder,
															collections::List<GuiResourceError>& errors);

		extern bool										WriteBinaryResource(
															Ptr<GuiResource> resource,
															bool compress,
															bool includeAssemblyInResource,
															Nullable<filesystem::FilePath> resourceOutput,
															Nullable<filesystem::FilePath> assemblyOutput);

		extern bool										WriteEmbeddedResource(Ptr<GuiResource> resource,
															Ptr<workflow::cppcodegen::WfCppInput> cppInput,
															Ptr<workflow::cppcodegen::WfCppOutput> cppOutput,
															bool compress,
															const filesystem::FilePath& filePath);
	}
}

#endif


/***********************************************************************
.\GUIINSTANCEANIMATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Shared Script

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEANIMATION
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEANIMATION


namespace vl
{
	namespace presentation
	{
		class GuiInstanceAnimation : public Object, public Description<GuiInstanceAnimation>
		{
		public:
		};

		class GuiInstanceGradientAnimation : public GuiInstanceAnimation, public Description<GuiInstanceGradientAnimation>
		{
		public:
			struct Target
			{
				WString									name;
				WString									interpolation;

				GuiResourceTextPos						namePosition;
				GuiResourceTextPos						interpolationPosition;
			};

			using EnumerateMemberAccessor = const Func<Ptr<workflow::WfExpression>(Ptr<workflow::WfExpression>)>&;
			using EnumerateMemberCallback = const Func<void(EnumerateMemberAccessor, description::IPropertyInfo*, description::IPropertyInfo*)>&;

			WString										className;
			WString										typeName;
			WString										interpolation;
			collections::List<Target>					targets;

			GuiResourceTextPos							tagPosition;
			GuiResourceTextPos							classPosition;
			GuiResourceTextPos							typePosition;
			GuiResourceTextPos							interpolationPosition;

			static Ptr<GuiInstanceGradientAnimation>	LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<glr::xml::XmlElement>					SaveToXml();

			bool										IsSupportedPrimitiveType(description::ITypeDescriptor* td);
			vint										ValidateStructMembers(GuiResourceTextPos namePosition, description::ITypeDescriptor* td, const WString& prefix, GuiResourceError::List& errors);
			vint										ValidatePropertyType(GuiResourceTextPos namePosition, description::ITypeInfo* typeInfo, const WString& prefix, GuiResourceError::List& errors, bool rootValue = false);

			void										EnumerateMembers(EnumerateMemberCallback callback, EnumerateMemberAccessor accessor, description::IPropertyInfo* propInfo, description::IPropertyInfo* originPropInfo);
			void										EnumerateMembers(EnumerateMemberCallback callback, EnumerateMemberAccessor accessor, description::ITypeDescriptor* td, description::IPropertyInfo* originPropInfo);
			void										EnumerateProperties(EnumerateMemberCallback callback, description::ITypeDescriptor* td);
			Ptr<workflow::WfExpression>					InitStruct(description::IPropertyInfo* propInfo, const WString& prefix, collections::SortedList<WString>& varNames);
			Ptr<workflow::WfModule>						Compile(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, bool generateImpl, GuiResourceError::List& errors);
		};
	}
}

#endif

/***********************************************************************
.\GUIINSTANCELOCALIZEDSTRINGS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Shared Script

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOCALIZEDSTRINGS
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOCALIZEDSTRINGS


namespace vl
{
	namespace presentation
	{
		class GuiInstanceLocalizedStringsBase : public Description<GuiInstanceLocalizedStringsBase>
		{
		public:
			struct StringItem
			{
			public:
				WString												name;
				WString												text;
				GuiResourceTextPos									textPosition;
			};

			struct Strings
			{
				using StringItemMap = collections::Dictionary<WString, Ptr<StringItem>>;

				collections::List<WString>							locales;
				StringItemMap										items;
				GuiResourceTextPos									tagPosition;

				WString												GetLocalesName();
			};

			collections::List<Ptr<Strings>>							strings;
			GuiResourceTextPos										tagPosition;

		public:
			using ParameterPair = collections::Pair<Ptr<reflection::description::ITypeInfo>, WString>;
			using ParameterList = collections::List<ParameterPair>;
			using PositionList = collections::List<vint>;
			using TextList = collections::List<WString>;

			struct TextDesc
			{
				ParameterList										parameters;
				PositionList										positions;
				TextList											texts;
			};

			using TextDescMap = collections::Dictionary<collections::Pair<Ptr<Strings>, WString>, Ptr<TextDesc>>;

		protected:
			static Ptr<Strings>										LoadStringsFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlElement> xmlStrings, collections::SortedList<WString>& existingLocales, GuiResourceError::List& errors);
			static Ptr<glr::xml::XmlElement>						SaveStringsToXml(Ptr<Strings> lss);
			static Ptr<TextDesc>									ParseLocalizedText(const WString& text, GuiResourceTextPos pos, GuiResourceError::List& errors);

			static void												FillStringsToTextDescMap(Ptr<Strings> lss, TextDescMap& textDescs, GuiResourceError::List& errors);
			static void												ValidateNamesAgainstDefaultStrings(Ptr<Strings> defaultStrings, Ptr<Strings> lss, GuiResourceError::List& errors);
			static void												ValidateSignatureAgainstDefaultStrings(Ptr<Strings> defaultStrings, Ptr<Strings> lss, TextDescMap& textDescs, GuiResourceError::List& errors);
			static void												ValidateAgainstDefaultStrings(Ptr<Strings> defaultStrings, collections::List<Ptr<Strings>>& nonDefaultStrings, TextDescMap& textDescs, GuiResourceError::List& errors);

			static WString											GetInterfaceTypeName(const WString& className, bool hasNamespace);
			static WString											GenerateStringsCppName(Ptr<Strings> lss);
			static Ptr<workflow::WfFunctionDeclaration>				GenerateTextDescFunctionHeader(Ptr<TextDesc> textDesc, const WString& functionName, workflow::WfFunctionKind functionKind);
			static Ptr<workflow::WfExpression>						GenerateTextDescArgumentFormatting(Ptr<description::ITypeInfo> type, const WString& function, vint argumentIndex);
			static Ptr<workflow::WfBlockStatement>					GenerateTextDescFunctionBody(Ptr<TextDesc> textDesc);
			static Ptr<workflow::WfExpression>						GenerateStringsConstructor(const WString& interfaceFullName, TextDescMap& textDescs, Ptr<Strings> lss);
			static Ptr<workflow::WfFunctionDeclaration>				GenerateBuildStringsFunction(const WString& interfaceFullName, TextDescMap& textDescs, Ptr<Strings> lss);
			static Ptr<workflow::WfBlockStatement>					GenerateStaticInit(const WString& stringsClassWithoutNs, const WString& installClassFullName, collections::List<Ptr<Strings>>& strings);
		};

		class GuiInstanceLocalizedStrings : public GuiInstanceLocalizedStringsBase, public Description<GuiInstanceLocalizedStrings>
		{
		public:
			WString													className;
			WString													defaultLocale;
			Ptr<Strings>											defaultStrings;

		public:

			static Ptr<GuiInstanceLocalizedStrings>					LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<glr::xml::XmlElement>								SaveToXml();

			Ptr<workflow::WfFunctionDeclaration>					GenerateInstallFunction(const WString& cacheName);
			Ptr<workflow::WfFunctionDeclaration>					GenerateGetFunction(const WString& cacheName);
			Ptr<workflow::WfModule>									Compile(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, GuiResourceError::List& errors);
		};

		class GuiInstanceLocalizedStringsInjection : public GuiInstanceLocalizedStringsBase, public Description<GuiInstanceLocalizedStringsInjection>
		{
		public:
			WString													className;
			WString													injectIntoClassName;

		public:

			static Ptr<GuiInstanceLocalizedStringsInjection>		LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<glr::xml::XmlElement>								SaveToXml();

			void													DecompileDefaultStrings(description::ITypeDescriptor* td, Ptr<Strings> defaultStrings, TextDescMap& textDescs, GuiResourceError::List& errors);
			Ptr<workflow::WfModule>									Compile(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, GuiResourceError::List& errors);
		};
	}
}

#endif

/***********************************************************************
.\GUIINSTANCESHAREDSCRIPT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Shared Script

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCESHAREDSCRIPT
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCESHAREDSCRIPT


namespace vl
{
	namespace presentation
	{
		class GuiInstanceSharedScript :public Object, public Description<GuiInstanceSharedScript>
		{
		public:
			WString										language;
			WString										code;
			GuiResourceTextPos							codePosition;

			static Ptr<GuiInstanceSharedScript>			LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<glr::xml::XmlElement>					SaveToXml();
		};
	}
}

#endif

/***********************************************************************
.\INSTANCEQUERY\GENERATED\GUIINSTANCEQUERYAST.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PRESENTATION_INSTANCEQUERY_AST_AST
#define VCZH_PRESENTATION_INSTANCEQUERY_AST_AST


namespace vl::presentation::instancequery
{
	class GuiIqCascadeQuery;
	class GuiIqPrimaryQuery;
	class GuiIqQuery;
	class GuiIqSetQuery;

	enum class GuiIqNameOption
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Specified = 0,
		Any = 1,
	};

	enum class GuiIqChildOption
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Direct = 0,
		Indirect = 1,
	};

	enum class GuiIqBinaryOperator
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		ExclusiveOr = 0,
		Intersect = 1,
		Union = 2,
		Substract = 3,
	};

	class GuiIqQuery abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<GuiIqQuery>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(GuiIqPrimaryQuery* node) = 0;
			virtual void Visit(GuiIqCascadeQuery* node) = 0;
			virtual void Visit(GuiIqSetQuery* node) = 0;
		};

		virtual void Accept(GuiIqQuery::IVisitor* visitor) = 0;

	};

	class GuiIqPrimaryQuery : public GuiIqQuery, vl::reflection::Description<GuiIqPrimaryQuery>
	{
	public:
		GuiIqChildOption childOption = GuiIqChildOption::UNDEFINED_ENUM_ITEM_VALUE;
		GuiIqNameOption attributeNameOption = GuiIqNameOption::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken attributeName;
		GuiIqNameOption typeNameOption = GuiIqNameOption::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken typeName;
		vl::glr::ParsingToken referenceName;

		void Accept(GuiIqQuery::IVisitor* visitor) override;
	};

	class GuiIqCascadeQuery : public GuiIqQuery, vl::reflection::Description<GuiIqCascadeQuery>
	{
	public:
		vl::Ptr<GuiIqQuery> parent;
		vl::Ptr<GuiIqQuery> child;

		void Accept(GuiIqQuery::IVisitor* visitor) override;
	};

	class GuiIqSetQuery : public GuiIqQuery, vl::reflection::Description<GuiIqSetQuery>
	{
	public:
		vl::Ptr<GuiIqQuery> first;
		vl::Ptr<GuiIqQuery> second;
		GuiIqBinaryOperator op = GuiIqBinaryOperator::UNDEFINED_ENUM_ITEM_VALUE;

		void Accept(GuiIqQuery::IVisitor* visitor) override;
	};
}
namespace vl::reflection::description
{
#ifndef VCZH_DEBUG_NO_REFLECTION
	DECL_TYPE_INFO(vl::presentation::instancequery::GuiIqQuery)
	DECL_TYPE_INFO(vl::presentation::instancequery::GuiIqQuery::IVisitor)
	DECL_TYPE_INFO(vl::presentation::instancequery::GuiIqNameOption)
	DECL_TYPE_INFO(vl::presentation::instancequery::GuiIqChildOption)
	DECL_TYPE_INFO(vl::presentation::instancequery::GuiIqPrimaryQuery)
	DECL_TYPE_INFO(vl::presentation::instancequery::GuiIqCascadeQuery)
	DECL_TYPE_INFO(vl::presentation::instancequery::GuiIqBinaryOperator)
	DECL_TYPE_INFO(vl::presentation::instancequery::GuiIqSetQuery)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::presentation::instancequery::GuiIqQuery::IVisitor)
		void Visit(vl::presentation::instancequery::GuiIqPrimaryQuery* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::presentation::instancequery::GuiIqCascadeQuery* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::presentation::instancequery::GuiIqSetQuery* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::presentation::instancequery::GuiIqQuery::IVisitor)

#endif
#endif
	/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
	/// <returns>Returns true if this operation succeeded.</returns>
	extern bool GuiInstanceQueryAstLoadTypes();
}
#endif

/***********************************************************************
.\GUIINSTANCEREPRESENTATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Representation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEREPRESENTATION
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEREPRESENTATION


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Instance Representation
***********************************************************************/

		class GuiTextRepr;
		class GuiAttSetterRepr;
		class GuiConstructorRepr;
		class IGuiInstanceCache;

		class GuiValueRepr : public Object, public Description<GuiValueRepr>
		{
		public:
			class IVisitor : public IDescriptable, public Description<IVisitor>
			{
			public:
				virtual void						Visit(GuiTextRepr* repr)=0;
				virtual void						Visit(GuiAttSetterRepr* repr)=0;
				virtual void						Visit(GuiConstructorRepr* repr)=0;
			};

			bool									fromStyle = false;
			GuiResourceTextPos						tagPosition;

			void									CloneBody(Ptr<GuiValueRepr> repr);

			virtual void							Accept(IVisitor* visitor) = 0;
			virtual Ptr<GuiValueRepr>				Clone() = 0;
			virtual void							FillXml(Ptr<glr::xml::XmlElement> xml) = 0;
		};

		class GuiTextRepr : public GuiValueRepr, public Description<GuiTextRepr>
		{
		public:
			static const vint						BinaryKey = 1;

			WString									text;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<glr::xml::XmlElement> xml)override;
		};

		class GuiAttSetterRepr : public GuiValueRepr, public Description<GuiAttSetterRepr>
		{
		public:
			typedef collections::List<Ptr<GuiValueRepr>>						ValueList;
			static const vint						BinaryKey = 2;

			struct SetterValue : public Object, public Description<SetterValue>
			{
				GlobalStringKey						binding;
				ValueList							values;
				GuiResourceTextPos					attPosition;
			};

			struct EventValue : public Object, public Description<EventValue>
			{
				GlobalStringKey						binding;
				WString								value;
				bool								fromStyle = false;
				GuiResourceTextPos					attPosition;
				GuiResourceTextPos					valuePosition;
			};

			struct EnvVarValue : public Object, public Description<EnvVarValue>
			{
				WString								value;
				bool								fromStyle = false;
				GuiResourceTextPos					attPosition;
				GuiResourceTextPos					valuePosition;
			};
			
			typedef collections::Dictionary<GlobalStringKey, Ptr<SetterValue>>			SetteValuerMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<EventValue>>			EventHandlerMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<EnvVarValue>>			EnvironmentVariableMap;
		public:
			SetteValuerMap							setters;					// empty key means default property
			EventHandlerMap							eventHandlers;
			EnvironmentVariableMap					environmentVariables;
			GlobalStringKey							instanceName;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			void									CloneBody(Ptr<GuiAttSetterRepr> repr);
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<glr::xml::XmlElement> xml)override;
		};

		class GuiConstructorRepr : public GuiAttSetterRepr, public Description<GuiConstructorRepr>
		{
		public:
			static const vint						BinaryKey = 3;

			GlobalStringKey							typeNamespace;
			GlobalStringKey							typeName;
			Nullable<WString>						styleName;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<glr::xml::XmlElement> xml)override;
		};

/***********************************************************************
Instance Namespace
***********************************************************************/

		class GuiInstanceNamespace : public Object, public Description<GuiInstanceNamespace>
		{
		public:
			WString									prefix;
			WString									postfix;
		};

		// Workflow:	<name>
		// C++:			<instance>->Get<name>()
		class GuiInstanceParameter : public Object, public Description<GuiInstanceParameter>
		{
		public:
			GlobalStringKey							name;
			GlobalStringKey							className;
			GuiResourceTextPos						tagPosition;
			GuiResourceTextPos						classPosition;
		};

		class GuiInstanceLocalized : public Object, public Description<GuiInstanceLocalized>
		{
		public:
			GlobalStringKey							name;
			GlobalStringKey							className;
			GuiResourceTextPos						tagPosition;
			GuiResourceTextPos						classPosition;
			bool									defaultStrings = false;
		};

/***********************************************************************
Instance Context
***********************************************************************/

		class GuiInstanceStyleContext;

		class GuiInstanceContext : public Object, public Description<GuiInstanceContext>
		{
		public:
			typedef collections::List<Ptr<GuiInstanceNamespace>>						NamespaceList;

			struct NamespaceInfo : public Object, public Description<NamespaceInfo>
			{
				GlobalStringKey						name;
				NamespaceList						namespaces;
				GuiResourceTextPos					attPosition;
			};
			typedef collections::Dictionary<GlobalStringKey, Ptr<NamespaceInfo>>		NamespaceMap;
			typedef collections::List<Ptr<GuiInstanceParameter>>						ParameterList;
			typedef collections::List<Ptr<GuiInstanceLocalized>>						LocalizedList;
			typedef collections::List<Ptr<GuiInstanceStyleContext>>						StyleContextList;

			class ElementName : public Object
			{
			public:
				WString								namespaceName;				// empty key means default namespace
				WString								category;
				WString								name;
				WString								binding;

				bool IsCtorName() { return category == L"" && name != L"" && binding == L""; }
				bool IsReferenceAttributeName() { return namespaceName == L"" && category == L"ref" && name != L"" && binding == L""; }
				bool IsEnvironmentAttributeName() { return namespaceName == L"" && category == L"env" && name != L""; }
				bool IsPropertyAttributeName() { return namespaceName == L"" && category == L"" && name != L""; }
				bool IsPropertyElementName() { return namespaceName == L"" && category == L"att" && name != L""; }
				bool IsEventAttributeName() { return namespaceName == L"" && category == L"ev" && name != L""; }
				bool IsEventElementName() { return namespaceName == L"" && category == L"ev" && name != L""; }
			};
		public:
			Ptr<GuiConstructorRepr>					instance;
			NamespaceMap							namespaces;
			bool									codeBehind = true;
			WString									className;
			collections::List<WString>				stylePaths;

			ParameterList							parameters;
			LocalizedList							localizeds;
			WString									memberScript;
			WString									ctorScript;
			WString									dtorScript;

			GuiResourceTextPos						tagPosition;
			GuiResourceTextPos						classPosition;
			GuiResourceTextPos						stylePosition;
			GuiResourceTextPos						memberPosition;
			GuiResourceTextPos						ctorPosition;
			GuiResourceTextPos						dtorPosition;

			bool									appliedStyles = false;
			StyleContextList						styles;

			static void								CollectDefaultAttributes(Ptr<GuiResourceItem> resource, GuiAttSetterRepr::ValueList& values, Ptr<glr::xml::XmlElement> xml, GuiResourceError::List& errors);
			static void								CollectAttributes(Ptr<GuiResourceItem> resource, GuiAttSetterRepr::SetteValuerMap& setters, Ptr<glr::xml::XmlElement> xml, GuiResourceError::List& errors);
			static void								CollectEvents(Ptr<GuiResourceItem> resource, GuiAttSetterRepr::EventHandlerMap& eventHandlers, Ptr<glr::xml::XmlElement> xml, GuiResourceError::List& errors);
			static void								FillAttSetter(Ptr<GuiResourceItem> resource, Ptr<GuiAttSetterRepr> setter, Ptr<glr::xml::XmlElement> xml, GuiResourceError::List& errors);
			static Ptr<GuiConstructorRepr>			LoadCtor(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlElement> xml, GuiResourceError::List& errors);
			static Ptr<GuiInstanceContext>			LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<glr::xml::XmlDocument>				SaveToXml();
			bool									ApplyStyles(Ptr<GuiResourceItem> resource, Ptr<GuiResourcePathResolver> resolver, GuiResourceError::List& errors);
		};

/***********************************************************************
Instance Style Context
***********************************************************************/

		class GuiInstanceStyle : public Object, public Description<GuiInstanceStyle>
		{
		public:
			Ptr<instancequery::GuiIqQuery>			query;
			Ptr<GuiAttSetterRepr>					setter;

			static Ptr<GuiInstanceStyle>			LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlElement> xml, GuiResourceError::List& errors);
			Ptr<glr::xml::XmlElement>				SaveToXml();
		};

		class GuiInstanceStyleContext : public Object, public Description<GuiInstanceStyleContext>
		{
			typedef collections::List<Ptr<GuiInstanceStyle>>		StyleList;
		public:
			StyleList								styles;

			static Ptr<GuiInstanceStyleContext>		LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<glr::xml::XmlDocument>				SaveToXml();
		};
	}
}

#endif

/***********************************************************************
.\GUIINSTANCELOADER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Loader

Interfaces:
***********************************************************************/

#ifdef VCZH_DEBUG_NO_REFLECTION
static_assert(false, "Don't use GacUICompiler.(h|cpp) if VCZH_DEBUG_NO_REFLECTION is defined.");
#endif

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOADER
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOADER


namespace vl
{
	namespace presentation
	{
		namespace types
		{
			struct ResolvingResult;
		}

/***********************************************************************
Instance Loader
***********************************************************************/

		class GuiInstancePropertyInfo : public IDescriptable, public Description<GuiInstancePropertyInfo>
		{
			typedef collections::List<Ptr<description::ITypeInfo>>		TypeInfoList;
		public:
			enum Support
			{
				NotSupport,
				SupportAssign,
				SupportArray,
				SupportCollection,
				SupportSet,
			};

			enum PropertyUsage
			{
				ConstructorArgument,
				Property,
			};

			enum PropertyBindability
			{
				Bindable,
				NotBindable,
			};

			enum PropertyMergability
			{
				MergeWithParent,
				NotMerge,
			};

			Support									support = NotSupport;
			PropertyUsage							usage = Property;
			PropertyBindability						bindability = NotBindable;
			PropertyMergability						mergability = NotMerge;
			TypeInfoList							acceptableTypes;

			static Ptr<GuiInstancePropertyInfo>		Unsupported();
			static Ptr<GuiInstancePropertyInfo>		Assign(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		AssignWithParent(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		Collection(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		CollectionWithParent(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		Set(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		Array(Ptr<description::ITypeInfo> typeInfo);
		};

		class IGuiInstanceLoader : public IDescriptable, public Description<IGuiInstanceLoader>
		{
		public:
			struct TypeInfo
			{
				GlobalStringKey						typeName;
				Ptr<description::ITypeInfo>			typeInfo = nullptr;

				TypeInfo()
				{
				}

				TypeInfo(GlobalStringKey _typeName, Ptr<description::ITypeInfo> _typeInfo)
					:typeName(_typeName)
					, typeInfo(_typeInfo)
				{
				}
			};

			struct PropertyInfo
			{
				TypeInfo							typeInfo;
				GlobalStringKey						propertyName;

				PropertyInfo(){}
				PropertyInfo(const TypeInfo& _typeInfo, GlobalStringKey _propertyName)
					:typeInfo(_typeInfo)
					, propertyName(_propertyName)
				{
				}
			};

			struct PropertyValue : PropertyInfo
			{
				description::Value					instanceValue;
				description::Value					propertyValue;

				PropertyValue(){}
				PropertyValue(const TypeInfo& _typeInfo, GlobalStringKey _propertyName, description::Value _instanceValue, description::Value _propertyValue = description::Value())
					:PropertyInfo(_typeInfo, _propertyName)
					, instanceValue(_instanceValue)
					, propertyValue(_propertyValue)
				{
				}
			};

			struct ArgumentInfo
			{
				Ptr<workflow::WfExpression>			expression;
				Ptr<description::ITypeInfo>			typeInfo;
				GuiResourceTextPos					attPosition;
				GuiResourceTextPos					valuePosition;				// only apply to text value
			};

			typedef collections::Group<GlobalStringKey, ArgumentInfo>	ArgumentMap;

			virtual GlobalStringKey							GetTypeName() = 0;
			virtual void									ClearReflectionCache();

			virtual void									GetRequiredPropertyNames(GuiResourcePrecompileContext& precompileContext, const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual void									GetPropertyNames(GuiResourcePrecompileContext& precompileContext, const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual void									GetPairedProperties(GuiResourcePrecompileContext& precompileContext, const PropertyInfo& propertyInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual Ptr<GuiInstancePropertyInfo>			GetPropertyType(GuiResourcePrecompileContext& precompileContext, const PropertyInfo& propertyInfo);

			virtual bool									CanCreate(const TypeInfo& typeInfo);
			virtual Ptr<workflow::WfBaseConstructorCall>	CreateRootInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, ArgumentMap& arguments, GuiResourceError::List& errors);
			virtual Ptr<workflow::WfStatement>				InitializeRootInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceError::List& errors);
			virtual Ptr<workflow::WfStatement>				CreateInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceTextPos tagPosition, GuiResourceError::List& errors);
			virtual Ptr<workflow::WfStatement>				AssignParameters(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
			virtual Ptr<workflow::WfExpression>				GetParameter(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const PropertyInfo& propertyInfo, GlobalStringKey variableName, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
		};

/***********************************************************************
Instance Binder
***********************************************************************/

		class IGuiInstanceBinder : public IDescriptable, public Description<IGuiInstanceBinder>
		{
		public:
			virtual GlobalStringKey					GetBindingName() = 0;
			virtual bool							ApplicableToConstructorArgument() = 0;
			virtual bool							RequirePropertyExist() = 0;
			virtual Ptr<workflow::WfExpression>		GenerateConstructorArgument(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, GuiResourceTextPos position, GuiResourceError::List& errors) = 0;
			virtual Ptr<workflow::WfStatement>		GenerateInstallStatement(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, GuiResourceTextPos position, GuiResourceError::List& errors) = 0;
		};

		class IGuiInstanceEventBinder : public IDescriptable, public Description<IGuiInstanceEventBinder>
		{
		public:
			virtual GlobalStringKey					GetBindingName() = 0;
			virtual Ptr<workflow::WfStatement>		GenerateInstallStatement(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& code, GuiResourceTextPos position, GuiResourceError::List& errors) = 0;
		};

		class IGuiInstanceDeserializer : public IDescriptable, public Description<IGuiInstanceDeserializer>
		{
		public:
			virtual bool							CanDeserialize(const IGuiInstanceLoader::PropertyInfo& propertyInfo, description::ITypeInfo* typeInfo) = 0;
			virtual description::ITypeInfo*			DeserializeAs(const IGuiInstanceLoader::PropertyInfo& propertyInfo, description::ITypeInfo* typeInfo) = 0;
			virtual Ptr<workflow::WfExpression>		Deserialize(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const IGuiInstanceLoader::PropertyInfo& propertyInfo, description::ITypeInfo* typeInfo, Ptr<workflow::WfExpression> valueExpression, GuiResourceTextPos tagPosition, GuiResourceError::List& errors) = 0;
		};

/***********************************************************************
Instance Loader Manager
***********************************************************************/

		class IGuiInstanceLoaderManager : public IDescriptable, public Description<IGuiInstanceLoaderManager>
		{
		public:
			virtual bool							AddInstanceBinder(Ptr<IGuiInstanceBinder> binder) = 0;
			virtual IGuiInstanceBinder*				GetInstanceBinder(GlobalStringKey bindingName) = 0;
			virtual bool							AddInstanceEventBinder(Ptr<IGuiInstanceEventBinder> binder) = 0;
			virtual IGuiInstanceEventBinder*		GetInstanceEventBinder(GlobalStringKey bindingName) = 0;
			virtual bool							AddInstanceDeserializer(Ptr<IGuiInstanceDeserializer> deserializer) = 0;
			virtual IGuiInstanceDeserializer*		GetInstanceDeserializer(const IGuiInstanceLoader::PropertyInfo& propertyInfo, description::ITypeInfo* typeInfo) = 0;

			virtual bool							CreateVirtualType(GlobalStringKey parentType, Ptr<IGuiInstanceLoader> loader) = 0;
			virtual bool							SetLoader(Ptr<IGuiInstanceLoader> loader) = 0;
			virtual IGuiInstanceLoader*				GetLoader(GlobalStringKey typeName) = 0;
			virtual IGuiInstanceLoader*				GetParentLoader(IGuiInstanceLoader* loader) = 0;
			virtual Ptr<description::ITypeInfo>		GetTypeInfoForType(GlobalStringKey typeName) = 0;
			virtual void							GetVirtualTypes(collections::List<GlobalStringKey>& typeNames) = 0;
			virtual GlobalStringKey					GetParentTypeForVirtualType(GlobalStringKey virtualType) = 0;
			virtual void							ClearReflectionCache() = 0;
		};

		extern IGuiInstanceLoaderManager*			GetInstanceLoaderManager();

/***********************************************************************
Helper Functions
***********************************************************************/

		extern void									SplitTypeName(const WString& input, collections::List<WString>& fragments);
		extern void									SplitBySemicolon(const WString& input, collections::List<WString>& fragments);
	}
}

#endif

/***********************************************************************
.\INSTANCEQUERY\GENERATED\GUIINSTANCEQUERY_ASSEMBLER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:GuiInstanceQuery
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PRESENTATION_INSTANCEQUERY_AST_ASSEMBLER
#define VCZH_PRESENTATION_INSTANCEQUERY_AST_ASSEMBLER


namespace vl::presentation::instancequery
{
	enum class GuiInstanceQueryClasses : vl::vint32_t
	{
		CascadeQuery = 0,
		PrimaryQuery = 1,
		Query = 2,
		SetQuery = 3,
	};

	enum class GuiInstanceQueryFields : vl::vint32_t
	{
		CascadeQuery_child = 0,
		CascadeQuery_parent = 1,
		PrimaryQuery_attributeName = 2,
		PrimaryQuery_attributeNameOption = 3,
		PrimaryQuery_childOption = 4,
		PrimaryQuery_referenceName = 5,
		PrimaryQuery_typeName = 6,
		PrimaryQuery_typeNameOption = 7,
		SetQuery_first = 8,
		SetQuery_op = 9,
		SetQuery_second = 10,
	};

	extern const wchar_t* GuiInstanceQueryTypeName(GuiInstanceQueryClasses type);
	extern const wchar_t* GuiInstanceQueryCppTypeName(GuiInstanceQueryClasses type);
	extern const wchar_t* GuiInstanceQueryFieldName(GuiInstanceQueryFields field);
	extern const wchar_t* GuiInstanceQueryCppFieldName(GuiInstanceQueryFields field);

	class GuiInstanceQueryAstInsReceiver : public vl::glr::AstInsReceiverBase
	{
	protected:
		vl::Ptr<vl::glr::ParsingAstBase> CreateAstNode(vl::vint32_t type) override;
		void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value) override;
		void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token, vl::vint32_t tokenIndex) override;
		void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem, bool weakAssignment) override;
		vl::Ptr<vl::glr::ParsingAstBase> ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates) override;
	};
}
#endif

/***********************************************************************
.\INSTANCEQUERY\GENERATED\GUIINSTANCEQUERY_LEXER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:GuiInstanceQuery
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PRESENTATION_INSTANCEQUERY_LEXER
#define VCZH_PRESENTATION_INSTANCEQUERY_LEXER


namespace vl::presentation::instancequery
{
	enum class GuiInstanceQueryTokens : vl::vint32_t
	{
		INDIRECT = 0,
		DIRECT = 1,
		NAME = 2,
		WILDCARD_INTERSECT = 3,
		OPEN = 4,
		CLOSE = 5,
		XOR = 6,
		UNION = 7,
		SUBSTRACT = 8,
		ATTRIBUTE = 9,
		COLON = 10,
		DOT = 11,
		SPACE = 12,
	};

	constexpr vl::vint GuiInstanceQueryTokenCount = 13;
	extern bool GuiInstanceQueryTokenDeleter(vl::vint token);
	extern const wchar_t* GuiInstanceQueryTokenId(GuiInstanceQueryTokens token);
	extern const wchar_t* GuiInstanceQueryTokenDisplayText(GuiInstanceQueryTokens token);
	extern const wchar_t* GuiInstanceQueryTokenRegex(GuiInstanceQueryTokens token);
	extern void GuiInstanceQueryLexerData(vl::stream::IStream& outputStream);
}
#endif

/***********************************************************************
.\INSTANCEQUERY\GENERATED\GUIINSTANCEQUERYPARSER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:GuiInstanceQuery
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PRESENTATION_INSTANCEQUERY_PARSER_SYNTAX
#define VCZH_PRESENTATION_INSTANCEQUERY_PARSER_SYNTAX


namespace vl::presentation::instancequery
{
	enum class ParserStates
	{
		QPrimaryFragment = 0,
		QPrimaryAttributed = 8,
		QPrimary = 15,
		Query0 = 24,
		Query1 = 29,
		Query2 = 38,
		QueryRoot = 47,
	};

	const wchar_t* ParserRuleName(vl::vint index);
	const wchar_t* ParserStateLabel(vl::vint index);
	extern void GuiInstanceQueryParserData(vl::stream::IStream& outputStream);

	class Parser
		: public vl::glr::ParserBase<GuiInstanceQueryTokens, ParserStates, GuiInstanceQueryAstInsReceiver>
		, protected vl::glr::automaton::IExecutor::ITypeCallback
	{
	protected:
		vl::WString GetClassName(vl::vint32_t classIndex) const override;
		vl::vint32_t FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2) const override;
	public:
		Parser();

		vl::Ptr<vl::presentation::instancequery::GuiIqQuery> ParseQueryRoot(const vl::WString& input, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::presentation::instancequery::GuiIqQuery> ParseQueryRoot(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
	};
}
#endif

/***********************************************************************
.\INSTANCEQUERY\GUIINSTANCEQUERY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Query

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY
#define VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY


namespace vl
{
	namespace presentation
	{
		extern void ExecuteQuery(Ptr<instancequery::GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& input, collections::List<Ptr<GuiConstructorRepr>>& output);
		extern void ExecuteQuery(Ptr<instancequery::GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& output);
		extern void ApplyStyle(Ptr<GuiInstanceStyle> style, Ptr<GuiConstructorRepr> ctor);
		extern void GuiIqPrint(Ptr<instancequery::GuiIqQuery> query, stream::StreamWriter& writer);
	}
}

#endif

/***********************************************************************
.\WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWCODEGEN.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Schema Representation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCESCHE_WORKFLOWCODEGEN
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCESCHE_WORKFLOWCODEGEN


namespace vl
{
	namespace presentation
	{
		namespace types
		{
			struct PropertyResolving
			{
				IGuiInstanceLoader*								loader = nullptr;
				IGuiInstanceLoader::PropertyInfo				propertyInfo;
				Ptr<GuiInstancePropertyInfo>					info;
			};

			typedef collections::Dictionary<GlobalStringKey, IGuiInstanceLoader::TypeInfo>		VariableTypeInfoMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<description::ITypeInfo>>		TypeOverrideMap;
			typedef collections::Dictionary<GuiValueRepr*, PropertyResolving>					PropertyResolvingMap;
			typedef collections::Group<GlobalStringKey, Ptr<GuiAttSetterRepr::EnvVarValue>>		EnvironmentVariableGroup;

			struct ResolvingResult : public Object, public Description<ResolvingResult>
			{
				Ptr<GuiResourceItem>							resource;						// compiling resource
				Ptr<GuiInstanceContext>							context;						// compiling context
				IGuiInstanceLoader::TypeInfo					rootTypeInfo;					// type of the context
				EnvironmentVariableGroup						envVars;						// current environment variable value stacks

				collections::List<GlobalStringKey>				referenceNames;					// all reference names
				IGuiInstanceLoader::ArgumentMap					rootCtorArguments;
				IGuiInstanceLoader*								rootLoader = nullptr;

				VariableTypeInfoMap								typeInfos;						// type of references
				PropertyResolvingMap							propertyResolvings;				// information of property values which are calling constructors
			};
		}
		extern workflow::analyzer::WfLexicalScopeManager*		Workflow_GetSharedManager(GuiResourceCpuArchitecture targetCpuArchitecture);
		extern Ptr<workflow::analyzer::WfLexicalScopeManager>	Workflow_TransferSharedManager();
		

/***********************************************************************
WorkflowCompiler (Parser)
***********************************************************************/

		extern Ptr<workflow::WfType>							Workflow_ParseType					(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, glr::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<workflow::WfExpression>						Workflow_ParseExpression			(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, glr::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<workflow::WfStatement>						Workflow_ParseStatement				(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, glr::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<workflow::WfStatement>						Workflow_ParseCoProviderStatement	(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, glr::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<workflow::WfModule>							Workflow_ParseModule				(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, glr::ParsingTextPos availableAfter = { 0,0 });

		extern WString											Workflow_ModuleToString(Ptr<workflow::WfModule> module);
		extern Ptr<workflow::WfExpression>						Workflow_ParseTextValue(GuiResourcePrecompileContext& precompileContext, description::ITypeDescriptor* typeDescriptor, GuiResourceLocation location, const WString& textValue, GuiResourceTextPos position, collections::List<GuiResourceError>& errors);

/***********************************************************************
WorkflowCompiler (Installation)
***********************************************************************/

		extern Ptr<workflow::WfExpression>						Workflow_GetUriProperty(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& protocol, const WString& path, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
		extern Ptr<workflow::WfStatement>						Workflow_InstallUriProperty(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& protocol, const WString& path, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
		extern Ptr<workflow::WfStatement>						Workflow_InstallBindProperty(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, Ptr<workflow::WfExpression> bindExpression);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvalProperty(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, Ptr<workflow::WfExpression> evalExpression, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvent(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& handlerName);
		extern Ptr<workflow::WfFunctionDeclaration>				Workflow_GenerateEventHandler(GuiResourcePrecompileContext& precompileContext, description::IEventInfo* eventInfo);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvalEvent(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IEventInfo* eventInfo, Ptr<workflow::WfStatement> evalStatement);

/***********************************************************************
WorkflowCompiler (Compile)
***********************************************************************/

		extern Ptr<workflow::WfModule>							Workflow_CreateModuleWithUsings(Ptr<GuiInstanceContext> context, const WString& moduleName);
		extern WString											Workflow_InstallWithClass(const WString& className, Ptr<workflow::WfModule> module, Ptr<workflow::WfDeclaration> decl);
		extern Ptr<workflow::WfClassDeclaration>				Workflow_InstallClass(const WString& className, Ptr<workflow::WfModule> module);
		extern Ptr<workflow::WfBlockStatement>					Workflow_InstallCtorClass(types::ResolvingResult& resolvingResult, Ptr<workflow::WfModule> module);

		extern void												Workflow_CreatePointerVariable(Ptr<workflow::WfClassDeclaration> ctorClass, GlobalStringKey name, description::ITypeInfo* typeInfo);
		extern void												Workflow_CreateVariablesForReferenceValues(Ptr<workflow::WfClassDeclaration> ctorClass, types::ResolvingResult& resolvingResult);
		
		struct InstanceLoadingSource
		{
			IGuiInstanceLoader*						loader;
			GlobalStringKey							typeName;
			Ptr<GuiResourceItem>					item;
			Ptr<GuiInstanceContext>					context;

			InstanceLoadingSource()
				:loader(0)
			{
			}

			InstanceLoadingSource(IGuiInstanceLoader* _loader, GlobalStringKey _typeName)
				:loader(_loader)
				, typeName(_typeName)
			{
			}

			InstanceLoadingSource(Ptr<GuiResourceItem> _item)
				:loader(0)
				, item(_item)
				, context(item->GetContent().Cast<GuiInstanceContext>())
			{
			}

			operator bool()const
			{
				return loader != 0 || context;
			}
		};

		extern IGuiInstanceLoader::TypeInfo						Workflow_AdjustPropertySearchType(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, IGuiInstanceLoader::TypeInfo resolvedTypeInfo, GlobalStringKey prop);
		extern bool												Workflow_GetPropertyTypes(GuiResourcePrecompileContext& precompileContext, WString& errorPrefix, types::ResolvingResult& resolvingResult, IGuiInstanceLoader* loader, IGuiInstanceLoader::TypeInfo resolvedTypeInfo, GlobalStringKey prop, Ptr<GuiAttSetterRepr::SetterValue> setter, collections::List<types::PropertyResolving>& possibleInfos, GuiResourceError::List& errors);
		extern Ptr<reflection::description::ITypeInfo>			Workflow_GetSuggestedParameterType(GuiResourcePrecompileContext& precompileContext, reflection::description::ITypeDescriptor* typeDescriptor);
		extern IGuiInstanceLoader::TypeInfo						Workflow_CollectReferences(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GuiResourceError::List& errors);
		extern void												Workflow_GenerateCreating(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, Ptr<workflow::WfBlockStatement> statements, GuiResourceError::List& errors);
		extern void												Workflow_GenerateBindings(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, Ptr<workflow::WfBlockStatement> statements, GuiResourceError::List& errors);

		extern InstanceLoadingSource							FindInstanceLoadingSource(Ptr<GuiInstanceContext> context, GlobalStringKey namespaceName, const WString& typeName);
		extern Ptr<GuiResourceItem>								FindInstanceResourceItem(Ptr<GuiInstanceContext> context, GuiConstructorRepr* ctor, Ptr<GuiResourceClassNameRecord> record);
		extern InstanceLoadingSource							FindInstanceLoadingSource(Ptr<GuiInstanceContext> context, GuiConstructorRepr* ctor);
		extern Ptr<workflow::WfModule>							Workflow_PrecompileInstanceContext(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, types::ResolvingResult& resolvingResult, GuiResourceError::List& errors);
		extern Ptr<workflow::WfModule>							Workflow_GenerateInstanceClass(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, types::ResolvingResult& resolvingResult, GuiResourceError::List& errors, vint passIndex);

#define WORKFLOW_ENVIRONMENT_VARIABLE_ADD\
		for (auto [envVar, index] : indexed(repr->environmentVariables.Keys()))\
		{\
			auto value = repr->environmentVariables.Values()[index];\
			resolvingResult.envVars.Add(envVar, value);\
		}\

#define WORKFLOW_ENVIRONMENT_VARIABLE_REMOVE\
		for (auto [envVar, index] : indexed(repr->environmentVariables.Keys()))\
		{\
			auto value = repr->environmentVariables.Values()[index];\
			resolvingResult.envVars.Remove(envVar, value.Obj());\
		}\

/***********************************************************************
WorkflowCompiler (ScriptPosition)
***********************************************************************/

		namespace types
		{
			struct ScriptPositionRecord
			{
				GuiResourceTextPos								position;
				glr::ParsingTextPos								availableAfter;
				GuiResourceTextPos								computedPosition;
			};

			class ScriptPosition : public Object, public Description<ScriptPosition>
			{
				using NodePositionMap = collections::Dictionary<Ptr<glr::ParsingAstBase>, ScriptPositionRecord>;
			public:
				NodePositionMap									nodePositions;
			};
		}

		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfType> node, glr::ParsingTextPos availableAfter = { 0,0 });
		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfExpression> node, glr::ParsingTextPos availableAfter = { 0,0 });
		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfStatement> node, glr::ParsingTextPos availableAfter = { 0,0 });
		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfDeclaration> node, glr::ParsingTextPos availableAfter = { 0,0 });
		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfModule> node, glr::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<types::ScriptPosition>						Workflow_GetScriptPosition(GuiResourcePrecompileContext& context);
		extern void												Workflow_ClearScriptPosition(GuiResourcePrecompileContext& context);

	}
}

#endif

/***********************************************************************
.\INSTANCELOADERS\GUIINSTANCELOADER_TEMPLATECONTROL.H
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCELOADERS_GUIINSTANCELOADER_TEMPLATECONTROL
#define VCZH_PRESENTATION_REFLECTION_INSTANCELOADERS_GUIINSTANCELOADER_TEMPLATECONTROL

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{
			using namespace collections;
			using namespace reflection::description;
			using namespace controls;
			using namespace compositions;
			using namespace theme;
			using namespace helper_types;

			using namespace elements;
			using namespace compositions;
			using namespace controls;
			using namespace templates;

			using namespace workflow;
			using namespace workflow::analyzer;

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
GuiVrtualTypeInstanceLoader
***********************************************************************/

			template<typename TControl>
			class GuiTemplateControlInstanceLoader : public Object, public IGuiInstanceLoader
			{
				typedef Ptr<WfExpression>							ArgumentRawFunctionType(ArgumentMap&);
				typedef void										InitRawFunctionType(const WString&, Ptr<WfBlockStatement>);
				typedef Func<ArgumentRawFunctionType>				ArgumentFunctionType;
				typedef Func<InitRawFunctionType>					InitFunctionType;

			protected:
				GlobalStringKey								typeName;
				theme::ThemeName							themeName;
				ArgumentFunctionType						argumentFunction;
				InitFunctionType							initFunction;

				virtual void AddAdditionalArguments(types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceError::List& errors, Ptr<WfNewClassExpression> createControl)
				{
				}
			public:
				static Ptr<WfExpression> CreateThemeName(theme::ThemeName themeName)
				{
					auto refExpr = Ptr(new WfChildExpression);
					refExpr->parent = GetExpressionFromTypeDescriptor(description::GetTypeDescriptor<ThemeName>());
					switch (themeName)
					{
#define THEME_NAME_CASE(TEMPLATE, CONTROL) case theme::ThemeName::CONTROL: refExpr->name.value = L ## #CONTROL; break;
						GUI_CONTROL_TEMPLATE_TYPES(THEME_NAME_CASE)
						THEME_NAME_CASE(WindowTemplate, Window)
#undef THEME_NAME_CASE
					default:
						CHECK_FAIL(L"GuiTemplateControlInstanceLoader::CreateThemeName()#Unknown theme name.");
					}
					return refExpr;
				}

			public:
				GuiTemplateControlInstanceLoader(const WString& _typeName, theme::ThemeName _themeName, ArgumentRawFunctionType* _argumentFunction = nullptr, InitRawFunctionType* _initFunction = nullptr)
					:typeName(GlobalStringKey::Get(_typeName))
					, themeName(_themeName)
				{
					if (_argumentFunction) argumentFunction = _argumentFunction;
					if (_initFunction) initFunction = _initFunction;
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				bool CanCreate(const TypeInfo& typeInfo)override
				{
					return typeName == typeInfo.typeName;
				}

				Ptr<workflow::WfBaseConstructorCall> CreateRootInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, ArgumentMap& arguments, GuiResourceError::List& errors)override
				{
					auto createControl = Ptr(new WfBaseConstructorCall);
					createControl->type = GetTypeFromTypeInfo(TypeInfoRetriver<TControl>::CreateTypeInfo().Obj());
					createControl->arguments.Add(CreateThemeName(themeName));
					return createControl;
				}

				Ptr<workflow::WfStatement> CreateInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceTextPos tagPosition, GuiResourceError::List& errors)override
				{
					CHECK_ERROR(CanCreate(typeInfo), L"GuiTemplateControlInstanceLoader::CreateInstance()#Wrong type info is provided.");

					auto block = Ptr(new WfBlockStatement);
					{
						auto controlType = TypeInfoRetriver<TControl*>::CreateTypeInfo();

						auto createControl = Ptr(new WfNewClassExpression);
						createControl->type = GetTypeFromTypeInfo(controlType.Obj());
						createControl->arguments.Add(CreateThemeName(themeName));

						if (argumentFunction)
						{
							createControl->arguments.Add(argumentFunction(arguments));
						}
						AddAdditionalArguments(resolvingResult, typeInfo, variableName, arguments, errors, createControl);

						auto refVariable = Ptr(new WfReferenceExpression);
						refVariable->name.value = variableName.ToString();

						auto assignExpr = Ptr(new WfBinaryExpression);
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refVariable;
						assignExpr->second = createControl;

						auto assignStat = Ptr(new WfExpressionStatement);
						assignStat->expression = assignExpr;
						block->statements.Add(assignStat);
					}

					if (initFunction)
					{
						initFunction(variableName.ToString(), block);
					}
					return block;
				}
			};
#endif
		}
	}
}
#endif

