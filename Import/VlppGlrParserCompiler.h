/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "VlppOS.h"
#include "Vlpp.h"
#include "VlppGlrParser.h"
#include "VlppReflection.h"
#include "VlppRegex.h"

/***********************************************************************
.\PARSERGEN\PARSERSYMBOL.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_PARSERSYMBOl
#define VCZH_PARSER2_PARSERGEN_PARSERSYMBOl


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			template<typename T>
			struct MappedOwning
			{
				collections::List<Ptr<T>>				items;
				collections::List<WString>				order;
				collections::Dictionary<WString, T*>	map;

				bool Add(const WString& name, T* item)
				{
					items.Add(item);
					if (map.Keys().Contains(name)) return false;
					order.Add(name);
					map.Add(name, item);
					return true;
				}
			};

			template<typename ...TArgs>
			void Fill(collections::List<WString>& ss, TArgs&& ...args)
			{
				WString items[] = { args... };
				for (auto& item : items)
				{
					ss.Add(item);
				}
			}

/***********************************************************************
ParserSymbolManager
***********************************************************************/

			enum class ParserErrorType
			{
				// AstSymbolManager -------------------------------------------------------------------
				DuplicatedFile,								// (fileName)
				FileDependencyNotExists,					// (fileName, dependency)
				FileCyclicDependency,						// (fileName, dependency)
				DuplicatedSymbol,							// (fileName, symbolName)
				DuplicatedSymbolGlobally,					// (fileName, symbolName, anotherFileName)
				DuplicatedClassProp,						// (fileName, className, propName)
				DuplicatedEnumItem,							// (fileName, enumName, propName)
				BaseClassNotExists,							// (fileName, className, typeName)
				BaseClassNotClass,							// (fileName, className, typeName)
				BaseClassCyclicDependency,					// (fileName, className)
				FieldTypeNotExists,							// (fileName, className, propName)
				FieldTypeNotClass,							// (fileName, className, propName)

				// LexerSymbolManager -----------------------------------------------------------------
				InvalidTokenDefinition,						// (code)
				DuplicatedToken,							// (tokenName)
				DuplicatedTokenByDisplayText,				// (tokenName)
				InvalidTokenRegex,							// (tokenName, errorMessage)
				TokenRegexNotPure,							// (tokenName)

				// SyntaxSymbolManager ----------------------------------------------------------------
				DuplicatedRule,								// (ruleName)
				RuleIsIndirectlyLeftRecursive,				// (ruleName)													: Indirect left recursion must be resolved before.

				// SyntaxAst (ResolveName) ------------------------------------------------------------
				RuleNameConflictedWithToken,				// (ruleName)
				TypeNotExistsInRule,						// (ruleName, name)
				TypeNotClassInRule,							// (ruleName, name)
				TokenOrRuleNotExistsInRule,					// (ruleName, name)

				// SyntaxAst (CalculateTypes) ---------------------------------------------------------
				RuleMixedPartialClauseWithOtherClause,		// (ruleName)
				RuleWithDifferentPartialTypes,				// (ruleName)
				RuleCannotResolveToDeterministicType,		// (ruleName)													: Unable to resolve to one type from clauses (token, type) or (create, partial).
				CyclicDependedRuleTypeIncompatible,			// (ruleName)													: Types of rules are not compatible to each other when they build cyclic dependency by reuse clauses.
				ReuseClauseCannotResolveToDeterministicType,// (ruleName)													: A reuse clause contains multiple use rule but their types are not compatible to each other.
				ReuseClauseContainsNoUseRule,				// (ruleName)													: A reuse clause contains no use rule therefore the type cannot be determined.

				// SyntaxAst (ValidateTypes) ----------------------------------------------------------
				FieldNotExistsInClause,						// (ruleName, clauseType, fieldName)							: The field does not exist in the type of the clause.
				RuleTypeMismatchedToField,					// (ruleName, clauseType, fieldName, fieldRuleType)				: The rule type is not compatible to the assigning field.
				AssignmentToNonEnumField,					// (ruleName, clauseType, fieldName)							: Assignment can only assign fields in enum types.
				EnumItemMismatchedToField,					// (ruleName, clauseType, fieldName, enumItem)					: Try to assign an unexisting or mismatched enum item to a field in an enum type.
				UseRuleWithPartialRule,						// (ruleName, useRuleName)										: A use rule should not be used with a partial rule.
				UseRuleInNonReuseClause,					// (ruleName, useRuleName)										: A use rule should only appear in reuse clause.
				PartialRuleUsedOnField,						// (ruleName, clauseType, partialRuleName, fieldName)			: A partial rule does not create object, it cannot be assigned to a field.
				ClauseTypeMismatchedToPartialRule,			// (ruleName, clauseType, partialRuleName, partialRuleType)		: A clause uses a partial rule of an incompatible type.

				// SyntaxAst (ValidateStructure, counting) --------------------------------------------
				ClauseNotCreateObject,						// (ruleName)													: A reuse clause does not contain use rule in some potential sequences.
				UseRuleUsedInOptionalBody,					// (ruleName, useRuleName)
				UseRuleUsedInLoopBody,						// (ruleName, useRuleName)
				ClauseTooManyUseRule,						// (ruleName)													: Multiple use rules in a potential sequence in a clause.
				NonArrayFieldAssignedInLoop,				// (ruleName, clauseType, fieldName)
				NonLoopablePartialRuleUsedInLoop,			// (ruleName, clauseType, partialRuleName)
				ClauseCouldExpandToEmptySequence,			// (ruleName)
				LoopBodyCouldExpandToEmptySequence,			// (ruleName)
				OptionalBodyCouldExpandToEmptySequence,		// (ruleName)
				NegativeOptionalEndsAClause,				// (ruleName)													: Negative optional syntax cannot ends a clause.
				MultiplePrioritySyntaxInAClause,			// (ruleName)													: Too many syntax with priority in the a clause.

				// SyntaxAst (ValidateStructure, relationship) ----------------------------------------
				FieldAssignedMoreThanOnce,					// (ruleName, clauseType, fieldName)
			};

			enum class ParserDefFileType
			{
				Ast,
				Lexer,
				Syntax,
			};

			struct ParserErrorLocation
			{
				ParserDefFileType			type;
				WString						name;
				ParsingTextRange			codeRange;
			};

			struct ParserError
			{
				ParserErrorType				type;
				ParserErrorLocation			location;
				WString						arg1;
				WString						arg2;
				WString						arg3;
				WString						arg4;
			};

			class ParserSymbolManager : public Object
			{
				using ErrorList = collections::List<ParserError>;
				using StringItems = collections::List<WString>;
			protected:

				ErrorList					errors;
			public:
				WString						name;
				StringItems					includes;
				StringItems					cppNss;
				WString						headerGuard;

				const auto&					Errors() { return errors; }

				template<typename ...TArgs>
				void AddError(ParserErrorType type, ParserErrorLocation location, TArgs&& ...args)
				{
					ParserError error;
					error.type = type;
					error.location = location;

					WString sargs[] = { WString(args)... };
					WString* dargs[] = { &error.arg1,&error.arg2,&error.arg3,&error.arg4 };
					constexpr vint sl = sizeof(sargs) / sizeof(*sargs);
					constexpr vint dl = sizeof(dargs) / sizeof(*dargs);
					constexpr vint ml = sl < dl ? sl : dl;
					for (vint i = 0; i < ml; i++)
					{
						*dargs[i] = sargs[i];
					}

					errors.Add(std::move(error));
				}
			};

/***********************************************************************
Utility
***********************************************************************/

			extern void						InitializeParserSymbolManager(ParserSymbolManager& manager);
		}
	}
}

#endif

/***********************************************************************
.\AST\ASTSYMBOL.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_AST_ASTSYMBOL
#define VCZH_PARSER2_AST_ASTSYMBOL


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			class AstEnumSymbol;
			class AstClassSymbol;
			class AstDefFile;
			class AstSymbolManager;

/***********************************************************************
AstSymbol
***********************************************************************/

			class AstSymbol : public Object
			{
			protected:
				AstDefFile*							ownerFile = nullptr;
				WString								name;

				AstSymbol(AstDefFile* _file, const WString& _name);
			public:
				AstDefFile*							Owner() { return ownerFile; }
				const WString&						Name() { return name; }
			};

/***********************************************************************
AstEnumSymbol
***********************************************************************/

			class AstEnumItemSymbol : public AstSymbol
			{
				friend class AstEnumSymbol;
			protected:
				AstEnumSymbol*						parent = nullptr;

				AstEnumItemSymbol(AstEnumSymbol* _parent, const WString& name);
			public:
				vint								value = 0;

				AstEnumSymbol*						Parent() { return parent; }
			};

			class AstEnumSymbol : public AstSymbol
			{
				friend class AstDefFile;
			protected:
				MappedOwning<AstEnumItemSymbol>		items;

				AstEnumSymbol(AstDefFile* _file, const WString& _name);
			public:
				AstEnumItemSymbol*					CreateItem(const WString& itemName, ParsingTextRange codeRange = {});
				const auto&							Items() { return items.map; }
				const auto&							ItemOrder() { return items.order; }
			};

/***********************************************************************
AstClassSymbol
***********************************************************************/

			enum class AstPropType
			{
				Token,
				Type,
				Array,
			};

			class AstClassPropSymbol : public AstSymbol
			{
				friend class AstClassSymbol;
			protected:
				AstClassSymbol*						parent = nullptr;

				AstClassPropSymbol(AstClassSymbol* _parent, const WString& name);
			public:
				AstPropType							propType = AstPropType::Token;
				AstSymbol*							propSymbol = nullptr;

				AstClassSymbol*						Parent() { return parent; }
				bool								SetPropType(AstPropType _type, const WString& typeName = WString::Empty, ParsingTextRange codeRange = {});
			};

			class AstClassSymbol : public AstSymbol
			{
				friend class AstDefFile;
			protected:
				MappedOwning<AstClassPropSymbol>	props;

				AstClassSymbol(AstDefFile* _file, const WString& _name);
			public:
				AstClassSymbol*						baseClass = nullptr;
				AstClassSymbol*						ambiguousDerivedClass = nullptr;
				collections::List<AstClassSymbol*>	derivedClasses;

				bool								SetBaseClass(const WString& typeName, ParsingTextRange codeRange = {});
				AstClassSymbol*						CreateAmbiguousDerivedClass(ParsingTextRange codeRange);
				AstClassPropSymbol*					CreateProp(const WString& propName, ParsingTextRange codeRange = {});
				const auto&							Props() { return props.map; }
				const auto&							PropOrder() { return props.order; }
			};

			extern AstClassSymbol*					FindCommonBaseClass(AstClassSymbol* c1, AstClassSymbol* c2);
			extern AstClassPropSymbol*				FindPropSymbol(AstClassSymbol*& type, const WString& name);

/***********************************************************************
AstDefFile
***********************************************************************/

			class AstDefFile : public Object
			{
				friend class AstSymbolManager;

				using DependenciesList = collections::List<WString>;
				using StringItems = collections::List<WString>;
			protected:
				ParserSymbolManager*		global = nullptr;
				AstSymbolManager*			ownerManager = nullptr;
				WString						name;
				MappedOwning<AstSymbol>		symbols;

				template<typename T>
				T*							CreateSymbol(const WString& symbolName, ParsingTextRange codeRange);

				AstDefFile(ParserSymbolManager* _global, AstSymbolManager* _ownerManager, const WString& _name);
			public:
				DependenciesList			dependencies;
				StringItems					cppNss;
				StringItems					refNss;
				WString						classPrefix;

				AstSymbolManager*			Owner() { return ownerManager; }
				const WString&				Name() { return name; }
				bool						AddDependency(const WString& dependency, ParsingTextRange codeRange = {});
				AstEnumSymbol*				CreateEnum(const WString& symbolName, ParsingTextRange codeRange = {});
				AstClassSymbol*				CreateClass(const WString& symbolName, ParsingTextRange codeRange = {});
				const auto&					Symbols() { return symbols.map; }
				const auto&					SymbolOrder() { return symbols.order; }

				template<typename ...TArgs>
				void AddError(ParserErrorType type, ParsingTextRange codeRange, TArgs&&... args)
				{
					global->AddError(type, { ParserDefFileType::Ast,name,codeRange }, std::forward<TArgs&&>(args)...);
				}
			};

/***********************************************************************
AstSymbolManager
***********************************************************************/

			class AstSymbolManager : public Object
			{
				using SymbolMap = collections::Dictionary<WString, AstSymbol*>;

				friend class AstDefFile;
			protected:
				MappedOwning<AstDefFile>	files;
				SymbolMap					symbolMap;
				ParserSymbolManager&		global;

			public:
				AstSymbolManager(ParserSymbolManager& _global);

				AstDefFile*					CreateFile(const WString& name);

				ParserSymbolManager&		Global() { return global; }
				const auto&					Files() { return files.map; }
				const auto&					FileOrder() { return files.order; }
				const auto&					Symbols() { return symbolMap; }
			};

			extern AstDefFile*				CreateParserGenTypeAst(AstSymbolManager& manager);
			extern AstDefFile*				CreateParserGenRuleAst(AstSymbolManager& manager);
		}
	}
}

#endif

/***********************************************************************
.\LEXER\LEXERSYMBOL.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_LEXER_LEXERSYMBOL
#define VCZH_PARSER2_LEXER_LEXERSYMBOL


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			class LexerSymbolManager;

/***********************************************************************
LexerSymbolManager
***********************************************************************/

			class TokenSymbol : public Object
			{
				friend class LexerSymbolManager;
			protected:
				LexerSymbolManager*			ownerManager;
				WString						name;

				TokenSymbol(LexerSymbolManager* _ownerManager, const WString& _name);
			public:
				WString						regex;
				WString						displayText;
				bool						discarded = false;
				
				LexerSymbolManager*			Owner() { return ownerManager; }
				const WString&				Name() { return name; }
			};

			class LexerSymbolManager : public Object
			{
				using TokenMap = collections::Dictionary<WString, TokenSymbol*>;
			protected:
				MappedOwning<TokenSymbol>	tokens;
				TokenMap					tokensByDisplayText;
				ParserSymbolManager&		global;

			public:
				LexerSymbolManager(ParserSymbolManager& _global);

				TokenSymbol*				CreateToken(const WString& _name, const WString& _regex, ParsingTextRange codeRange = {});
				TokenSymbol*				CreateDiscardedToken(const WString& _name, const WString& _regex, ParsingTextRange codeRange = {});

				ParserSymbolManager&		Global() { return global; }
				const auto&					Tokens() { return tokens.map; }
				const auto&					TokensByDisplayText() { return tokensByDisplayText; }
				const auto&					TokenOrder() { return tokens.order; }

				template<typename ...TArgs>
				void AddError(ParserErrorType type, ParsingTextRange codeRange, TArgs&&... args)
				{
					global.AddError(type, { ParserDefFileType::Lexer,WString::Empty,codeRange }, std::forward<TArgs&&>(args)...);
				}
			};

			extern void						CreateParserGenLexer(LexerSymbolManager& manager);
		}
	}
}

#endif

/***********************************************************************
.\PARSERGEN\PARSERCPPGEN.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_PARSERCPPGEN
#define VCZH_PARSER2_PARSERGEN_PARSERCPPGEN


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			class AstDefFile;
			class AstClassPropSymbol;
			class AstClassSymbol;
			class TokenSymbol;
			class SyntaxSymbolManager;

/***********************************************************************
Output
***********************************************************************/

			struct CppAstGenOutput
			{
				WString			astH;
				WString			astCpp;
				WString			builderH;
				WString			builderCpp;
				WString			emptyH;
				WString			emptyCpp;
				WString			copyH;
				WString			copyCpp;
				WString			traverseH;
				WString			traverseCpp;
				WString			jsonH;
				WString			jsonCpp;
			};

			struct CppSyntaxGenOutput
			{
				WString			syntaxH;
				WString			syntaxCpp;
			};

			struct CppParserGenOutput
			{
				WString																	assemblyH;
				WString																	assemblyCpp;
				WString																	lexerH;
				WString																	lexerCpp;
				collections::Dictionary<AstDefFile*, Ptr<CppAstGenOutput>>				astOutputs;
				collections::Dictionary<SyntaxSymbolManager*, Ptr<CppSyntaxGenOutput>>	syntaxOutputs;

				collections::Dictionary<AstClassSymbol*, vint32_t>						classIds;
				collections::Dictionary<AstClassPropSymbol*, vint32_t>					fieldIds;
				collections::Dictionary<TokenSymbol*, vint32_t>							tokenIds;
			};

/***********************************************************************
Utility
***********************************************************************/

			extern Ptr<CppParserGenOutput>		GenerateParserFileNames(ParserSymbolManager& manager);

			extern void							WriteCppStringBody(const WString& body, stream::StreamWriter& writer);
			extern void							WriteFileComment(const WString& name, stream::StreamWriter& writer);
			extern WString						WriteNssBegin(collections::List<WString>& cppNss, stream::StreamWriter& writer);
			extern void							WriteNssEnd(collections::List<WString>& cppNss, stream::StreamWriter& writer);
			extern void							WriteLoadDataFunctionHeader(const WString& prefix, const WString& functionName, stream::StreamWriter& writer);
			extern void							WriteLoadDataFunctionCpp(const WString& prefix, const WString& functionName, stream::MemoryStream& rawData, bool compressData, stream::StreamWriter& writer);
		}
	}
}

#endif

/***********************************************************************
.\AST\ASTCPPGEN.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_AST_ASTCPPGEN
#define VCZH_PARSER2_AST_ASTCPPGEN


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			extern void											GenerateAstFileNames(AstSymbolManager& manager, Ptr<CppParserGenOutput> parserOutput);

			extern void			WriteAstHeaderFile				(AstDefFile* file, stream::StreamWriter& writer);
			extern void			WriteAstCppFile					(AstDefFile* file, const WString& astHeaderName, stream::StreamWriter& writer);

			extern void			WriteAstUtilityHeaderFile		(AstDefFile* file, Ptr<CppAstGenOutput> output, const WString& extraNss, stream::StreamWriter& writer, Func<void(const WString&)> callback);
			extern void			WriteAstUtilityCppFile			(AstDefFile* file, const WString& utilityHeaderFile, const WString& extraNss, stream::StreamWriter& writer, Func<void(const WString&)> callback);
			extern void			WriteParserUtilityHeaderFile	(AstSymbolManager& manager, Ptr<CppParserGenOutput> output, const WString& guardPostfix, stream::StreamWriter& writer, Func<void(const WString&)> callback);
			extern void			WriteParserUtilityCppFile		(AstSymbolManager& manager, const WString& utilityHeaderFile, stream::StreamWriter& writer, Func<void(const WString&)> callback);

			extern void			WriteAstBuilderHeaderFile		(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteAstBuilderCppFile			(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteEmptyVisitorHeaderFile		(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteEmptyVisitorCppFile		(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteCopyVisitorHeaderFile		(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteCopyVisitorCppFile			(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteTraverseVisitorHeaderFile	(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteTraverseVisitorCppFile		(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteJsonVisitorHeaderFile		(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteJsonVisitorCppFile			(AstDefFile* file, Ptr<CppAstGenOutput> output, stream::StreamWriter& writer);

			extern void			WriteAstAssemblerHeaderFile		(AstSymbolManager& manager, Ptr<CppParserGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteAstAssemblerCppFile		(AstSymbolManager& manager, Ptr<CppParserGenOutput> output, stream::StreamWriter& writer);

			extern void			WriteAstFiles					(AstDefFile* file, Ptr<CppAstGenOutput> output, collections::Dictionary<WString, WString>& files);
			extern void			WriteAstFiles					(AstSymbolManager& manager, Ptr<CppParserGenOutput> output, collections::Dictionary<WString, WString>& files);
		}
	}
}

#endif

/***********************************************************************
.\LEXER\LEXERCPPGEN.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_LEXER_LEXERCPPGEN
#define VCZH_PARSER2_LEXER_LEXERCPPGEN


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			extern void			WriteLexerHeaderFile			(LexerSymbolManager& manager, Ptr<CppParserGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteLexerCppFile				(LexerSymbolManager& manager, Ptr<CppParserGenOutput> output, stream::StreamWriter& writer);
			extern void			WriteLexerFiles					(LexerSymbolManager& manager, Ptr<CppParserGenOutput> output, collections::Dictionary<WString, WString>& files);
		}
	}
}

#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENRULEAST.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			class GlrAlternativeSyntax;
			class GlrAssignment;
			class GlrClause;
			class GlrCreateClause;
			class GlrLiteralSyntax;
			class GlrLoopSyntax;
			class GlrOptionalSyntax;
			class GlrPartialClause;
			class GlrRefSyntax;
			class GlrReuseClause;
			class GlrRule;
			class GlrSequenceSyntax;
			class GlrSyntax;
			class GlrSyntaxFile;
			class GlrUseSyntax;

			enum class GlrOptionalPriority
			{
				UNDEFINED_ENUM_ITEM_VALUE = -1,
				Equal = 0,
				PreferTake = 1,
				PreferSkip = 2,
			};

			class GlrSyntax abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrSyntax>
			{
			public:
				class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
				{
				public:
					virtual void Visit(GlrRefSyntax* node) = 0;
					virtual void Visit(GlrLiteralSyntax* node) = 0;
					virtual void Visit(GlrUseSyntax* node) = 0;
					virtual void Visit(GlrLoopSyntax* node) = 0;
					virtual void Visit(GlrOptionalSyntax* node) = 0;
					virtual void Visit(GlrSequenceSyntax* node) = 0;
					virtual void Visit(GlrAlternativeSyntax* node) = 0;
				};

				virtual void Accept(GlrSyntax::IVisitor* visitor) = 0;

			};

			class GlrRefSyntax : public GlrSyntax, vl::reflection::Description<GlrRefSyntax>
			{
			public:
				vl::glr::ParsingToken name;
				vl::glr::ParsingToken field;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrLiteralSyntax : public GlrSyntax, vl::reflection::Description<GlrLiteralSyntax>
			{
			public:
				vl::glr::ParsingToken value;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrUseSyntax : public GlrSyntax, vl::reflection::Description<GlrUseSyntax>
			{
			public:
				vl::glr::ParsingToken name;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrLoopSyntax : public GlrSyntax, vl::reflection::Description<GlrLoopSyntax>
			{
			public:
				vl::Ptr<GlrSyntax> syntax;
				vl::Ptr<GlrSyntax> delimiter;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrOptionalSyntax : public GlrSyntax, vl::reflection::Description<GlrOptionalSyntax>
			{
			public:
				GlrOptionalPriority priority = GlrOptionalPriority::UNDEFINED_ENUM_ITEM_VALUE;
				vl::Ptr<GlrSyntax> syntax;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrSequenceSyntax : public GlrSyntax, vl::reflection::Description<GlrSequenceSyntax>
			{
			public:
				vl::Ptr<GlrSyntax> first;
				vl::Ptr<GlrSyntax> second;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrAlternativeSyntax : public GlrSyntax, vl::reflection::Description<GlrAlternativeSyntax>
			{
			public:
				vl::Ptr<GlrSyntax> first;
				vl::Ptr<GlrSyntax> second;

				void Accept(GlrSyntax::IVisitor* visitor) override;
			};

			class GlrClause abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrClause>
			{
			public:
				class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
				{
				public:
					virtual void Visit(GlrCreateClause* node) = 0;
					virtual void Visit(GlrPartialClause* node) = 0;
					virtual void Visit(GlrReuseClause* node) = 0;
				};

				virtual void Accept(GlrClause::IVisitor* visitor) = 0;

			};

			class GlrAssignment : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrAssignment>
			{
			public:
				vl::glr::ParsingToken field;
				vl::glr::ParsingToken value;
			};

			class GlrCreateClause : public GlrClause, vl::reflection::Description<GlrCreateClause>
			{
			public:
				vl::glr::ParsingToken type;
				vl::Ptr<GlrSyntax> syntax;
				vl::collections::List<vl::Ptr<GlrAssignment>> assignments;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrPartialClause : public GlrClause, vl::reflection::Description<GlrPartialClause>
			{
			public:
				vl::glr::ParsingToken type;
				vl::Ptr<GlrSyntax> syntax;
				vl::collections::List<vl::Ptr<GlrAssignment>> assignments;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrReuseClause : public GlrClause, vl::reflection::Description<GlrReuseClause>
			{
			public:
				vl::Ptr<GlrSyntax> syntax;
				vl::collections::List<vl::Ptr<GlrAssignment>> assignments;

				void Accept(GlrClause::IVisitor* visitor) override;
			};

			class GlrRule : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrRule>
			{
			public:
				vl::glr::ParsingToken name;
				vl::collections::List<vl::Ptr<GlrClause>> clauses;
			};

			class GlrSyntaxFile : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrSyntaxFile>
			{
			public:
				vl::collections::List<vl::Ptr<GlrRule>> rules;
			};
		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSyntax::IVisitor)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrRefSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrLiteralSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrUseSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrLoopSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrOptionalPriority)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrOptionalSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSequenceSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrAlternativeSyntax)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClause::IVisitor)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrAssignment)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrCreateClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrPartialClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrReuseClause)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrRule)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrSyntaxFile)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::glr::parsergen::GlrSyntax::IVisitor)
				void Visit(vl::glr::parsergen::GlrRefSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrLiteralSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrUseSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrLoopSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrOptionalSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrSequenceSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrAlternativeSyntax* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::glr::parsergen::GlrSyntax::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::glr::parsergen::GlrClause::IVisitor)
				void Visit(vl::glr::parsergen::GlrCreateClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrPartialClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrReuseClause* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::glr::parsergen::GlrClause::IVisitor)

#endif
#endif
			/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			extern bool ParserGenRuleAstLoadTypes();
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENRULEAST_BUILDER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST_BUILDER
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST_BUILDER


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace builder
			{
				class MakeAlternativeSyntax : public vl::glr::ParsingAstBuilder<GlrAlternativeSyntax>
				{
				public:
					MakeAlternativeSyntax& first(const vl::Ptr<GlrSyntax>& value);
					MakeAlternativeSyntax& second(const vl::Ptr<GlrSyntax>& value);
				};

				class MakeAssignment : public vl::glr::ParsingAstBuilder<GlrAssignment>
				{
				public:
					MakeAssignment& field(const vl::WString& value);
					MakeAssignment& value(const vl::WString& value);
				};

				class MakeCreateClause : public vl::glr::ParsingAstBuilder<GlrCreateClause>
				{
				public:
					MakeCreateClause& assignments(const vl::Ptr<GlrAssignment>& value);
					MakeCreateClause& syntax(const vl::Ptr<GlrSyntax>& value);
					MakeCreateClause& type(const vl::WString& value);
				};

				class MakeLiteralSyntax : public vl::glr::ParsingAstBuilder<GlrLiteralSyntax>
				{
				public:
					MakeLiteralSyntax& value(const vl::WString& value);
				};

				class MakeLoopSyntax : public vl::glr::ParsingAstBuilder<GlrLoopSyntax>
				{
				public:
					MakeLoopSyntax& delimiter(const vl::Ptr<GlrSyntax>& value);
					MakeLoopSyntax& syntax(const vl::Ptr<GlrSyntax>& value);
				};

				class MakeOptionalSyntax : public vl::glr::ParsingAstBuilder<GlrOptionalSyntax>
				{
				public:
					MakeOptionalSyntax& priority(GlrOptionalPriority value);
					MakeOptionalSyntax& syntax(const vl::Ptr<GlrSyntax>& value);
				};

				class MakePartialClause : public vl::glr::ParsingAstBuilder<GlrPartialClause>
				{
				public:
					MakePartialClause& assignments(const vl::Ptr<GlrAssignment>& value);
					MakePartialClause& syntax(const vl::Ptr<GlrSyntax>& value);
					MakePartialClause& type(const vl::WString& value);
				};

				class MakeRefSyntax : public vl::glr::ParsingAstBuilder<GlrRefSyntax>
				{
				public:
					MakeRefSyntax& field(const vl::WString& value);
					MakeRefSyntax& name(const vl::WString& value);
				};

				class MakeReuseClause : public vl::glr::ParsingAstBuilder<GlrReuseClause>
				{
				public:
					MakeReuseClause& assignments(const vl::Ptr<GlrAssignment>& value);
					MakeReuseClause& syntax(const vl::Ptr<GlrSyntax>& value);
				};

				class MakeRule : public vl::glr::ParsingAstBuilder<GlrRule>
				{
				public:
					MakeRule& clauses(const vl::Ptr<GlrClause>& value);
					MakeRule& name(const vl::WString& value);
				};

				class MakeSequenceSyntax : public vl::glr::ParsingAstBuilder<GlrSequenceSyntax>
				{
				public:
					MakeSequenceSyntax& first(const vl::Ptr<GlrSyntax>& value);
					MakeSequenceSyntax& second(const vl::Ptr<GlrSyntax>& value);
				};

				class MakeSyntaxFile : public vl::glr::ParsingAstBuilder<GlrSyntaxFile>
				{
				public:
					MakeSyntaxFile& rules(const vl::Ptr<GlrRule>& value);
				};

				class MakeUseSyntax : public vl::glr::ParsingAstBuilder<GlrUseSyntax>
				{
				public:
					MakeUseSyntax& name(const vl::WString& value);
				};

			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENRULEAST_COPY.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST_COPY_VISITOR
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST_COPY_VISITOR


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace copy_visitor
			{
				/// <summary>A copy visitor, overriding all abstract methods with AST copying code.</summary>
				class RuleAstVisitor
					: public virtual vl::glr::CopyVisitorBase
					, protected virtual GlrSyntax::IVisitor
					, protected virtual GlrClause::IVisitor
				{
				protected:
					void CopyFields(GlrAlternativeSyntax* from, GlrAlternativeSyntax* to);
					void CopyFields(GlrAssignment* from, GlrAssignment* to);
					void CopyFields(GlrClause* from, GlrClause* to);
					void CopyFields(GlrCreateClause* from, GlrCreateClause* to);
					void CopyFields(GlrLiteralSyntax* from, GlrLiteralSyntax* to);
					void CopyFields(GlrLoopSyntax* from, GlrLoopSyntax* to);
					void CopyFields(GlrOptionalSyntax* from, GlrOptionalSyntax* to);
					void CopyFields(GlrPartialClause* from, GlrPartialClause* to);
					void CopyFields(GlrRefSyntax* from, GlrRefSyntax* to);
					void CopyFields(GlrReuseClause* from, GlrReuseClause* to);
					void CopyFields(GlrRule* from, GlrRule* to);
					void CopyFields(GlrSequenceSyntax* from, GlrSequenceSyntax* to);
					void CopyFields(GlrSyntax* from, GlrSyntax* to);
					void CopyFields(GlrSyntaxFile* from, GlrSyntaxFile* to);
					void CopyFields(GlrUseSyntax* from, GlrUseSyntax* to);

				protected:
					virtual void Visit(GlrAssignment* node);
					virtual void Visit(GlrRule* node);
					virtual void Visit(GlrSyntaxFile* node);

					void Visit(GlrRefSyntax* node) override;
					void Visit(GlrLiteralSyntax* node) override;
					void Visit(GlrUseSyntax* node) override;
					void Visit(GlrLoopSyntax* node) override;
					void Visit(GlrOptionalSyntax* node) override;
					void Visit(GlrSequenceSyntax* node) override;
					void Visit(GlrAlternativeSyntax* node) override;

					void Visit(GlrCreateClause* node) override;
					void Visit(GlrPartialClause* node) override;
					void Visit(GlrReuseClause* node) override;

				public:
					virtual vl::Ptr<GlrSyntax> CopyNode(GlrSyntax* node);
					virtual vl::Ptr<GlrClause> CopyNode(GlrClause* node);
					virtual vl::Ptr<GlrAssignment> CopyNode(GlrAssignment* node);
					virtual vl::Ptr<GlrRule> CopyNode(GlrRule* node);
					virtual vl::Ptr<GlrSyntaxFile> CopyNode(GlrSyntaxFile* node);

					vl::Ptr<GlrAlternativeSyntax> CopyNode(GlrAlternativeSyntax* node);
					vl::Ptr<GlrCreateClause> CopyNode(GlrCreateClause* node);
					vl::Ptr<GlrLiteralSyntax> CopyNode(GlrLiteralSyntax* node);
					vl::Ptr<GlrLoopSyntax> CopyNode(GlrLoopSyntax* node);
					vl::Ptr<GlrOptionalSyntax> CopyNode(GlrOptionalSyntax* node);
					vl::Ptr<GlrPartialClause> CopyNode(GlrPartialClause* node);
					vl::Ptr<GlrRefSyntax> CopyNode(GlrRefSyntax* node);
					vl::Ptr<GlrReuseClause> CopyNode(GlrReuseClause* node);
					vl::Ptr<GlrSequenceSyntax> CopyNode(GlrSequenceSyntax* node);
					vl::Ptr<GlrUseSyntax> CopyNode(GlrUseSyntax* node);
				};
			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENRULEAST_EMPTY.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST_EMPTY_VISITOR
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST_EMPTY_VISITOR


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace empty_visitor
			{
				/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
				class SyntaxVisitor : public vl::Object, public GlrSyntax::IVisitor
				{
				protected:
					// Dispatch (virtual) --------------------------------

				public:
					// Visitor Members -----------------------------------
					void Visit(GlrRefSyntax* node) override;
					void Visit(GlrLiteralSyntax* node) override;
					void Visit(GlrUseSyntax* node) override;
					void Visit(GlrLoopSyntax* node) override;
					void Visit(GlrOptionalSyntax* node) override;
					void Visit(GlrSequenceSyntax* node) override;
					void Visit(GlrAlternativeSyntax* node) override;
				};

				/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
				class ClauseVisitor : public vl::Object, public GlrClause::IVisitor
				{
				protected:
					// Dispatch (virtual) --------------------------------

				public:
					// Visitor Members -----------------------------------
					void Visit(GlrCreateClause* node) override;
					void Visit(GlrPartialClause* node) override;
					void Visit(GlrReuseClause* node) override;
				};

			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENRULEAST_JSON.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST_JSON_VISITOR
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST_JSON_VISITOR


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace json_visitor
			{
				/// <summary>A JSON visitor, overriding all abstract methods with AST to JSON serialization code.</summary>
				class RuleAstVisitor
					: public vl::glr::JsonVisitorBase
					, protected virtual GlrSyntax::IVisitor
					, protected virtual GlrClause::IVisitor
				{
				protected:
					virtual void PrintFields(GlrAlternativeSyntax* node);
					virtual void PrintFields(GlrAssignment* node);
					virtual void PrintFields(GlrClause* node);
					virtual void PrintFields(GlrCreateClause* node);
					virtual void PrintFields(GlrLiteralSyntax* node);
					virtual void PrintFields(GlrLoopSyntax* node);
					virtual void PrintFields(GlrOptionalSyntax* node);
					virtual void PrintFields(GlrPartialClause* node);
					virtual void PrintFields(GlrRefSyntax* node);
					virtual void PrintFields(GlrReuseClause* node);
					virtual void PrintFields(GlrRule* node);
					virtual void PrintFields(GlrSequenceSyntax* node);
					virtual void PrintFields(GlrSyntax* node);
					virtual void PrintFields(GlrSyntaxFile* node);
					virtual void PrintFields(GlrUseSyntax* node);

				protected:
					void Visit(GlrRefSyntax* node) override;
					void Visit(GlrLiteralSyntax* node) override;
					void Visit(GlrUseSyntax* node) override;
					void Visit(GlrLoopSyntax* node) override;
					void Visit(GlrOptionalSyntax* node) override;
					void Visit(GlrSequenceSyntax* node) override;
					void Visit(GlrAlternativeSyntax* node) override;

					void Visit(GlrCreateClause* node) override;
					void Visit(GlrPartialClause* node) override;
					void Visit(GlrReuseClause* node) override;

				public:
					RuleAstVisitor(vl::stream::StreamWriter& _writer);

					void Print(GlrSyntax* node);
					void Print(GlrClause* node);
					void Print(GlrAssignment* node);
					void Print(GlrRule* node);
					void Print(GlrSyntaxFile* node);
				};
			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENRULEAST_TRAVERSE.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:RuleAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEAST_AST_TRAVERSE_VISITOR
#define VCZH_PARSER2_PARSERGEN_RULEAST_AST_TRAVERSE_VISITOR


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace traverse_visitor
			{
				/// <summary>A traverse visitor, overriding all abstract methods with AST visiting code.</summary>
				class RuleAstVisitor
					: public vl::Object
					, protected virtual GlrSyntax::IVisitor
					, protected virtual GlrClause::IVisitor
				{
				protected:
					virtual void Traverse(vl::glr::ParsingToken& token);
					virtual void Traverse(vl::glr::ParsingAstBase* node);
					virtual void Traverse(GlrAlternativeSyntax* node);
					virtual void Traverse(GlrAssignment* node);
					virtual void Traverse(GlrClause* node);
					virtual void Traverse(GlrCreateClause* node);
					virtual void Traverse(GlrLiteralSyntax* node);
					virtual void Traverse(GlrLoopSyntax* node);
					virtual void Traverse(GlrOptionalSyntax* node);
					virtual void Traverse(GlrPartialClause* node);
					virtual void Traverse(GlrRefSyntax* node);
					virtual void Traverse(GlrReuseClause* node);
					virtual void Traverse(GlrRule* node);
					virtual void Traverse(GlrSequenceSyntax* node);
					virtual void Traverse(GlrSyntax* node);
					virtual void Traverse(GlrSyntaxFile* node);
					virtual void Traverse(GlrUseSyntax* node);

				protected:
					virtual void Finishing(vl::glr::ParsingAstBase* node);
					virtual void Finishing(GlrAlternativeSyntax* node);
					virtual void Finishing(GlrAssignment* node);
					virtual void Finishing(GlrClause* node);
					virtual void Finishing(GlrCreateClause* node);
					virtual void Finishing(GlrLiteralSyntax* node);
					virtual void Finishing(GlrLoopSyntax* node);
					virtual void Finishing(GlrOptionalSyntax* node);
					virtual void Finishing(GlrPartialClause* node);
					virtual void Finishing(GlrRefSyntax* node);
					virtual void Finishing(GlrReuseClause* node);
					virtual void Finishing(GlrRule* node);
					virtual void Finishing(GlrSequenceSyntax* node);
					virtual void Finishing(GlrSyntax* node);
					virtual void Finishing(GlrSyntaxFile* node);
					virtual void Finishing(GlrUseSyntax* node);

				protected:
					void Visit(GlrRefSyntax* node) override;
					void Visit(GlrLiteralSyntax* node) override;
					void Visit(GlrUseSyntax* node) override;
					void Visit(GlrLoopSyntax* node) override;
					void Visit(GlrOptionalSyntax* node) override;
					void Visit(GlrSequenceSyntax* node) override;
					void Visit(GlrAlternativeSyntax* node) override;

					void Visit(GlrCreateClause* node) override;
					void Visit(GlrPartialClause* node) override;
					void Visit(GlrReuseClause* node) override;

				public:
					void InspectInto(GlrSyntax* node);
					void InspectInto(GlrClause* node);
					void InspectInto(GlrAssignment* node);
					void InspectInto(GlrRule* node);
					void InspectInto(GlrSyntaxFile* node);
				};
			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENTYPEAST.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:TypeAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_TYPEAST_AST
#define VCZH_PARSER2_PARSERGEN_TYPEAST_AST


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			class GlrAstFile;
			class GlrClass;
			class GlrClassProp;
			class GlrEnum;
			class GlrEnumItem;
			class GlrType;

			enum class GlrPropType
			{
				UNDEFINED_ENUM_ITEM_VALUE = -1,
				Token = 0,
				Type = 1,
				Array = 2,
			};

			enum class GlrClassAmbiguity
			{
				UNDEFINED_ENUM_ITEM_VALUE = -1,
				No = 0,
				Yes = 1,
			};

			class GlrType abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrType>
			{
			public:
				class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
				{
				public:
					virtual void Visit(GlrEnum* node) = 0;
					virtual void Visit(GlrClass* node) = 0;
				};

				virtual void Accept(GlrType::IVisitor* visitor) = 0;

				vl::glr::ParsingToken name;
			};

			class GlrEnumItem : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrEnumItem>
			{
			public:
				vl::glr::ParsingToken name;
			};

			class GlrEnum : public GlrType, vl::reflection::Description<GlrEnum>
			{
			public:
				vl::collections::List<vl::Ptr<GlrEnumItem>> items;

				void Accept(GlrType::IVisitor* visitor) override;
			};

			class GlrClassProp : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrClassProp>
			{
			public:
				vl::glr::ParsingToken name;
				GlrPropType propType = GlrPropType::UNDEFINED_ENUM_ITEM_VALUE;
				vl::glr::ParsingToken propTypeName;
			};

			class GlrClass : public GlrType, vl::reflection::Description<GlrClass>
			{
			public:
				vl::glr::ParsingToken baseClass;
				GlrClassAmbiguity ambiguity = GlrClassAmbiguity::UNDEFINED_ENUM_ITEM_VALUE;
				vl::collections::List<vl::Ptr<GlrClassProp>> props;

				void Accept(GlrType::IVisitor* visitor) override;
			};

			class GlrAstFile : public vl::glr::ParsingAstBase, vl::reflection::Description<GlrAstFile>
			{
			public:
				vl::collections::List<vl::Ptr<GlrType>> types;
			};
		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::glr::parsergen::GlrType)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrType::IVisitor)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrEnumItem)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrEnum)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrPropType)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClassProp)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClassAmbiguity)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrClass)
			DECL_TYPE_INFO(vl::glr::parsergen::GlrAstFile)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::glr::parsergen::GlrType::IVisitor)
				void Visit(vl::glr::parsergen::GlrEnum* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::glr::parsergen::GlrClass* node) override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::glr::parsergen::GlrType::IVisitor)

#endif
#endif
			/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			extern bool ParserGenTypeAstLoadTypes();
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENTYPEAST_BUILDER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:TypeAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_TYPEAST_AST_BUILDER
#define VCZH_PARSER2_PARSERGEN_TYPEAST_AST_BUILDER


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace builder
			{
				class MakeAstFile : public vl::glr::ParsingAstBuilder<GlrAstFile>
				{
				public:
					MakeAstFile& types(const vl::Ptr<GlrType>& value);
				};

				class MakeClass : public vl::glr::ParsingAstBuilder<GlrClass>
				{
				public:
					MakeClass& ambiguity(GlrClassAmbiguity value);
					MakeClass& baseClass(const vl::WString& value);
					MakeClass& props(const vl::Ptr<GlrClassProp>& value);
					MakeClass& name(const vl::WString& value);
				};

				class MakeClassProp : public vl::glr::ParsingAstBuilder<GlrClassProp>
				{
				public:
					MakeClassProp& name(const vl::WString& value);
					MakeClassProp& propType(GlrPropType value);
					MakeClassProp& propTypeName(const vl::WString& value);
				};

				class MakeEnum : public vl::glr::ParsingAstBuilder<GlrEnum>
				{
				public:
					MakeEnum& items(const vl::Ptr<GlrEnumItem>& value);
					MakeEnum& name(const vl::WString& value);
				};

				class MakeEnumItem : public vl::glr::ParsingAstBuilder<GlrEnumItem>
				{
				public:
					MakeEnumItem& name(const vl::WString& value);
				};

				class MakeType : public vl::glr::ParsingAstBuilder<GlrType>
				{
				public:
					MakeType& name(const vl::WString& value);
				};

			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENTYPEAST_COPY.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:TypeAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_TYPEAST_AST_COPY_VISITOR
#define VCZH_PARSER2_PARSERGEN_TYPEAST_AST_COPY_VISITOR


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace copy_visitor
			{
				/// <summary>A copy visitor, overriding all abstract methods with AST copying code.</summary>
				class TypeAstVisitor
					: public virtual vl::glr::CopyVisitorBase
					, protected virtual GlrType::IVisitor
				{
				protected:
					void CopyFields(GlrAstFile* from, GlrAstFile* to);
					void CopyFields(GlrClass* from, GlrClass* to);
					void CopyFields(GlrClassProp* from, GlrClassProp* to);
					void CopyFields(GlrEnum* from, GlrEnum* to);
					void CopyFields(GlrEnumItem* from, GlrEnumItem* to);
					void CopyFields(GlrType* from, GlrType* to);

				protected:
					virtual void Visit(GlrEnumItem* node);
					virtual void Visit(GlrClassProp* node);
					virtual void Visit(GlrAstFile* node);

					void Visit(GlrEnum* node) override;
					void Visit(GlrClass* node) override;

				public:
					virtual vl::Ptr<GlrType> CopyNode(GlrType* node);
					virtual vl::Ptr<GlrEnumItem> CopyNode(GlrEnumItem* node);
					virtual vl::Ptr<GlrClassProp> CopyNode(GlrClassProp* node);
					virtual vl::Ptr<GlrAstFile> CopyNode(GlrAstFile* node);

					vl::Ptr<GlrClass> CopyNode(GlrClass* node);
					vl::Ptr<GlrEnum> CopyNode(GlrEnum* node);
				};
			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENTYPEAST_EMPTY.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:TypeAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_TYPEAST_AST_EMPTY_VISITOR
#define VCZH_PARSER2_PARSERGEN_TYPEAST_AST_EMPTY_VISITOR


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace empty_visitor
			{
				/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
				class TypeVisitor : public vl::Object, public GlrType::IVisitor
				{
				protected:
					// Dispatch (virtual) --------------------------------

				public:
					// Visitor Members -----------------------------------
					void Visit(GlrEnum* node) override;
					void Visit(GlrClass* node) override;
				};

			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENTYPEAST_JSON.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:TypeAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_TYPEAST_AST_JSON_VISITOR
#define VCZH_PARSER2_PARSERGEN_TYPEAST_AST_JSON_VISITOR


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace json_visitor
			{
				/// <summary>A JSON visitor, overriding all abstract methods with AST to JSON serialization code.</summary>
				class TypeAstVisitor
					: public vl::glr::JsonVisitorBase
					, protected virtual GlrType::IVisitor
				{
				protected:
					virtual void PrintFields(GlrAstFile* node);
					virtual void PrintFields(GlrClass* node);
					virtual void PrintFields(GlrClassProp* node);
					virtual void PrintFields(GlrEnum* node);
					virtual void PrintFields(GlrEnumItem* node);
					virtual void PrintFields(GlrType* node);

				protected:
					void Visit(GlrEnum* node) override;
					void Visit(GlrClass* node) override;

				public:
					TypeAstVisitor(vl::stream::StreamWriter& _writer);

					void Print(GlrType* node);
					void Print(GlrEnumItem* node);
					void Print(GlrClassProp* node);
					void Print(GlrAstFile* node);
				};
			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENTYPEAST_TRAVERSE.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:TypeAst
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_TYPEAST_AST_TRAVERSE_VISITOR
#define VCZH_PARSER2_PARSERGEN_TYPEAST_AST_TRAVERSE_VISITOR


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace traverse_visitor
			{
				/// <summary>A traverse visitor, overriding all abstract methods with AST visiting code.</summary>
				class TypeAstVisitor
					: public vl::Object
					, protected virtual GlrType::IVisitor
				{
				protected:
					virtual void Traverse(vl::glr::ParsingToken& token);
					virtual void Traverse(vl::glr::ParsingAstBase* node);
					virtual void Traverse(GlrAstFile* node);
					virtual void Traverse(GlrClass* node);
					virtual void Traverse(GlrClassProp* node);
					virtual void Traverse(GlrEnum* node);
					virtual void Traverse(GlrEnumItem* node);
					virtual void Traverse(GlrType* node);

				protected:
					virtual void Finishing(vl::glr::ParsingAstBase* node);
					virtual void Finishing(GlrAstFile* node);
					virtual void Finishing(GlrClass* node);
					virtual void Finishing(GlrClassProp* node);
					virtual void Finishing(GlrEnum* node);
					virtual void Finishing(GlrEnumItem* node);
					virtual void Finishing(GlrType* node);

				protected:
					void Visit(GlrEnum* node) override;
					void Visit(GlrClass* node) override;

				public:
					void InspectInto(GlrType* node);
					void InspectInto(GlrEnumItem* node);
					void InspectInto(GlrClassProp* node);
					void InspectInto(GlrAstFile* node);
				};
			}
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGEN_ASSEMBLER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ParserGen
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_AST_ASSEMBLER
#define VCZH_PARSER2_PARSERGEN_AST_ASSEMBLER


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			enum class ParserGenClasses : vl::vint32_t
			{
				AlternativeSyntax = 0,
				Assignment = 1,
				AstFile = 2,
				Class = 3,
				ClassProp = 4,
				Clause = 5,
				CreateClause = 6,
				Enum = 7,
				EnumItem = 8,
				LiteralSyntax = 9,
				LoopSyntax = 10,
				OptionalSyntax = 11,
				PartialClause = 12,
				RefSyntax = 13,
				ReuseClause = 14,
				Rule = 15,
				SequenceSyntax = 16,
				Syntax = 17,
				SyntaxFile = 18,
				Type = 19,
				UseSyntax = 20,
			};

			enum class ParserGenFields : vl::vint32_t
			{
				AlternativeSyntax_first = 0,
				AlternativeSyntax_second = 1,
				Assignment_field = 2,
				Assignment_value = 3,
				AstFile_types = 4,
				Class_ambiguity = 5,
				Class_baseClass = 6,
				Class_props = 7,
				ClassProp_name = 8,
				ClassProp_propType = 9,
				ClassProp_propTypeName = 10,
				CreateClause_assignments = 11,
				CreateClause_syntax = 12,
				CreateClause_type = 13,
				Enum_items = 14,
				EnumItem_name = 15,
				LiteralSyntax_value = 16,
				LoopSyntax_delimiter = 17,
				LoopSyntax_syntax = 18,
				OptionalSyntax_priority = 19,
				OptionalSyntax_syntax = 20,
				PartialClause_assignments = 21,
				PartialClause_syntax = 22,
				PartialClause_type = 23,
				RefSyntax_field = 24,
				RefSyntax_name = 25,
				ReuseClause_assignments = 26,
				ReuseClause_syntax = 27,
				Rule_clauses = 28,
				Rule_name = 29,
				SequenceSyntax_first = 30,
				SequenceSyntax_second = 31,
				SyntaxFile_rules = 32,
				Type_name = 33,
				UseSyntax_name = 34,
			};

			extern const wchar_t* ParserGenTypeName(ParserGenClasses type);
			extern const wchar_t* ParserGenCppTypeName(ParserGenClasses type);
			extern const wchar_t* ParserGenFieldName(ParserGenFields field);
			extern const wchar_t* ParserGenCppFieldName(ParserGenFields field);

			class ParserGenAstInsReceiver : public vl::glr::AstInsReceiverBase
			{
			protected:
				vl::Ptr<vl::glr::ParsingAstBase> CreateAstNode(vl::vint32_t type) override;
				void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value) override;
				void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token, vl::vint32_t tokenIndex) override;
				void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem) override;
				vl::Ptr<vl::glr::ParsingAstBase> ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates) override;
			};
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGEN_LEXER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ParserGen
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_LEXER
#define VCZH_PARSER2_PARSERGEN_LEXER


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			enum class ParserGenTokens : vl::vint32_t
			{
				AMBIGUOUS = 0,
				CLASS = 1,
				ENUM = 2,
				VAR = 3,
				TOKEN = 4,
				AS = 5,
				PARTIAL = 6,
				OPEN_ROUND = 7,
				CLOSE_ROUND = 8,
				OPEN_SQUARE = 9,
				CLOSE_SQUARE = 10,
				OPEN_CURLY = 11,
				CLOSE_CURLY = 12,
				COMMA = 13,
				COLON = 14,
				SEMICOLON = 15,
				INFER = 16,
				ALTERNATIVE = 17,
				USE = 18,
				ASSIGN = 19,
				POSITIVE = 20,
				NEGATIVE = 21,
				ID = 22,
				STRING = 23,
				SPACE = 24,
				COMMENT = 25,
			};

			constexpr vl::vint ParserGenTokenCount = 26;
			extern bool ParserGenTokenDeleter(vl::vint token);
			extern const wchar_t* ParserGenTokenId(ParserGenTokens token);
			extern const wchar_t* ParserGenTokenDisplayText(ParserGenTokens token);
			extern const wchar_t* ParserGenTokenRegex(ParserGenTokens token);
			extern void ParserGenLexerData(vl::stream::IStream& outputStream);
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENRULEPARSER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ParserGen
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_RULEPARSER_SYNTAX
#define VCZH_PARSER2_PARSERGEN_RULEPARSER_SYNTAX


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			enum class RuleParserStates
			{
				OptionalBody = 0,
				Syntax0 = 5,
				Syntax1 = 26,
				Syntax2 = 31,
				Syntax = 37,
				Assignment = 40,
				Clause = 45,
				Rule = 67,
				File = 73,
			};

			const wchar_t* RuleParserRuleName(vl::vint index);
			const wchar_t* RuleParserStateLabel(vl::vint index);
			extern void ParserGenRuleParserData(vl::stream::IStream& outputStream);

			class RuleParser
				: public vl::glr::ParserBase<ParserGenTokens, RuleParserStates, ParserGenAstInsReceiver>				, protected vl::glr::automaton::TraceManager::ITypeCallback
			{
			protected:
				vl::vint32_t FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2) const override;
			public:
				RuleParser();

				vl::Ptr<vl::glr::parsergen::GlrSyntaxFile> ParseFile(const vl::WString& input, vl::vint codeIndex = -1) const;
				vl::Ptr<vl::glr::parsergen::GlrSyntaxFile> ParseFile(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
			};
		}
	}
}
#endif

/***********************************************************************
.\PARSERGEN_GENERATED\PARSERGENTYPEPARSER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ParserGen
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_TYPEPARSER_SYNTAX
#define VCZH_PARSER2_PARSERGEN_TYPEPARSER_SYNTAX


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			enum class TypeParserStates
			{
				EnumItem = 0,
				Enum = 4,
				ClassPropType = 11,
				classProp = 18,
				ClassBody = 25,
				Class = 33,
				Type = 40,
				File = 44,
			};

			const wchar_t* TypeParserRuleName(vl::vint index);
			const wchar_t* TypeParserStateLabel(vl::vint index);
			extern void ParserGenTypeParserData(vl::stream::IStream& outputStream);

			class TypeParser
				: public vl::glr::ParserBase<ParserGenTokens, TypeParserStates, ParserGenAstInsReceiver>				, protected vl::glr::automaton::TraceManager::ITypeCallback
			{
			protected:
				vl::vint32_t FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2) const override;
			public:
				TypeParser();

				vl::Ptr<vl::glr::parsergen::GlrAstFile> ParseFile(const vl::WString& input, vl::vint codeIndex = -1) const;
				vl::Ptr<vl::glr::parsergen::GlrAstFile> ParseFile(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
			};
		}
	}
}
#endif

/***********************************************************************
.\SYNTAX\SYNTAXSYMBOL.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_SYNTAX_SYNTAXSYMBOL
#define VCZH_PARSER2_SYNTAX_SYNTAXSYMBOL


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			class AstClassSymbol;
			class StateSymbol;
			class EdgeSymbol;
			class RuleSymbol;
			class SyntaxSymbolManager;
			class CompactSyntaxBuilder;

/***********************************************************************
StateSymbol
***********************************************************************/

			class StateSymbol : public Object
			{
				friend class EdgeSymbol;
				friend class SyntaxSymbolManager;
				friend class CompactSyntaxBuilder;

				using EdgeList = collections::List<EdgeSymbol*>;
			protected:
				SyntaxSymbolManager*		ownerManager;
				RuleSymbol*					rule;
				vint32_t					clauseId;
				EdgeList					inEdges;
				EdgeList					outEdges;

				StateSymbol(RuleSymbol* _rule, vint32_t _clauseId);
			public:
				WString						label;
				bool						endingState = false;

				SyntaxSymbolManager*		Owner() { return ownerManager; }
				RuleSymbol*					Rule() { return rule; }
				vint32_t					ClauseId() { return clauseId; }
				const EdgeList&				InEdges() { return inEdges; }
				const EdgeList&				OutEdges() { return outEdges; }

				void						GetOutEdgesInStableOrder(collections::List<StateSymbol*>& orderedStates, EdgeList& orderedEdges);
			};

/***********************************************************************
EdgeSymbol
***********************************************************************/

			enum class EdgeInputType
			{
				Epsilon,		// No input is needed to execute this edge.
				Ending,			// An epsilon edge that reduces the current rule.
				LeftRec,		// An epsilon edge that reduces the current rule, which is the first input of one of its left recursive clause.
				Token,			// An token is read to execute this edge.
				Rule,			// A rule is reduced to execute this edge.
			};

			struct EdgeInput
			{
				EdgeInputType				type = EdgeInputType::Epsilon;
				vint32_t					token = -1;
				RuleSymbol*					rule = nullptr;
			};

			enum class EdgeImportancy
			{
				NoCompetition,
				HighPriority,
				LowPriority,
			};

			class EdgeSymbol : public Object
			{
				friend class SyntaxSymbolManager;
				friend class CompactSyntaxBuilder;

				using InsList = collections::List<AstIns>;
				using EdgeList = collections::List<EdgeSymbol*>;
			protected:
				SyntaxSymbolManager*		ownerManager;
				StateSymbol*				fromState;
				StateSymbol*				toState;

				EdgeSymbol(StateSymbol* _from, StateSymbol* _to);
			public:
				EdgeInput					input;											// Input of this edge.
				bool						important = false;								// true and false are the only two priorites of edges.
				EdgeImportancy				importancy = EdgeImportancy::NoCompetition;		// important -> HighPriority, !important with important sibling -> LowPriority.
																							// (filled by BuildCompactNFA)
																							// If any important edge forms a cross referenced NFA edge, it becomes important too.
				InsList						insBeforeInput;									// Instructions to execute before pushing the value from a token or a reduced rule.
				InsList						insAfterInput;									// Instructions to execute after pushing the value from a token or a reduced rule.
				EdgeList					returnEdges;									// Edges of rule reduction.
																							// InsBeforeInput will be copied to a cross-referenced edge.
																							// When a reduction is done, only insAfterInput need to execute.

				SyntaxSymbolManager*		Owner() { return ownerManager; }
				StateSymbol*				From() { return fromState; }
				StateSymbol*				To() { return toState; }
			};

/***********************************************************************
RuleSymbol
***********************************************************************/

			class RuleSymbol : public Object
			{
				friend class SyntaxSymbolManager;

				using StateList = collections::List<StateSymbol*>;
			protected:
				SyntaxSymbolManager*		ownerManager;
				WString						name;
				vint32_t					currentClauseId = -1;

				RuleSymbol(SyntaxSymbolManager* _ownerManager, const WString& _name);
			public:
				StateList					startStates;
				bool						isPartial = false;
				bool						assignedNonArrayField = false;
				AstClassSymbol*				ruleType = nullptr;

				SyntaxSymbolManager*		Owner() { return ownerManager; }
				const WString&				Name() { return name; }
				void						NewClause() { currentClauseId++; }
				vint32_t					CurrentClauseId() { return currentClauseId; }
			};

/***********************************************************************
SyntaxSymbolManager
***********************************************************************/

			enum class SyntaxPhase
			{
				EpsilonNFA,					// An automaton that has edges of Epsilon, Token, Rule.
				CompactNFA,					// Epsilon edges are eliminated by compressing multiple edges into one.
											// Epsilon edges to the ending state will be compressed to an Ending edge.
											// The first edge of Rule in left-recursive clauses becomes a LeftRec edge, with its fromState changed to the ending state.
											// fromState and toState of non-LeftRec edges belong to the same clause.
				CrossReferencedNFA,			// Edges of Rule are compressed to an edge that pointing towards states in other clauses.
											// Multiple edges of rule are stored in returnEdges in the order of execution.
											// insBeforeInput of an edge contains insBeforeInput from its returnEdges.
											// returnEdges of an edge will be pushed to a stack when it is executed.
											// Executing an Ending edge pops a returnEdges and execute its insAfterInput only.
											// automaton::Executable is exactly the same to CrossReferencedNFA, stored a more cache friendly way.
			};

			class SyntaxSymbolManager : public Object
			{
				using StateList = collections::List<Ptr<StateSymbol>>;
				using EdgeList = collections::List<Ptr<EdgeSymbol>>;
				using RuleTypeMap = collections::Dictionary<RuleSymbol*, WString>;
				using RuleList = collections::List<RuleSymbol*>;
			protected:
				MappedOwning<RuleSymbol>	rules;
				StateList					states;
				EdgeList					edges;
				ParserSymbolManager&		global;
				SyntaxPhase					phase = SyntaxPhase::EpsilonNFA;

				void						BuildLeftRecEdge(EdgeSymbol* newEdge, EdgeSymbol* endingEdge, EdgeSymbol* lrecPrefixEdge);
				void						EliminateLeftRecursion(RuleSymbol* rule, StateSymbol* startState, StateSymbol* endState, StateList& newStates, EdgeList& newEdges);
				void						EliminateSingleRulePrefix(RuleSymbol* rule, StateSymbol* startState, StateSymbol* endState, StateList& newStates, EdgeList& newEdges);
				StateSymbol*				EliminateEpsilonEdges(RuleSymbol* rule, StateList& newStates, EdgeList& newEdges);
				void						BuildCompactNFAInternal();

				void						FixCrossReferencedRuleEdge(StateSymbol* startState, collections::Group<StateSymbol*, EdgeSymbol*>& orderedEdges, collections::List<EdgeSymbol*>& accumulatedEdges);
				void						BuildCrossReferencedNFAInternal();
			public:
				SyntaxSymbolManager(ParserSymbolManager& _global);

				WString						name;
				RuleTypeMap					ruleTypes;
				RuleList					parsableRules;

				RuleSymbol*					CreateRule(const WString& name, ParsingTextRange codeRange = {});
				StateSymbol*				CreateState(RuleSymbol* rule, vint32_t clauseId);
				EdgeSymbol*					CreateEdge(StateSymbol* from, StateSymbol* to);

				void						BuildCompactNFA();
				void						BuildCrossReferencedNFA();
				void						BuildAutomaton(vint tokenCount, automaton::Executable& executable, automaton::Metadata& metadata);
				void						GetStatesInStableOrder(collections::List<StateSymbol*>& order);
				WString						GetStateGlobalLabel(StateSymbol* state, vint index);

				ParserSymbolManager&		Global() { return global; }
				const auto&					Rules() { return rules.map; }
				const auto&					RuleOrder() { return rules.order; }
				SyntaxPhase					Phase() { return phase; }

				template<typename ...TArgs>
				void AddError(ParserErrorType type, ParsingTextRange codeRange, TArgs&&... args)
				{
					global.AddError(type, { ParserDefFileType::Syntax,name,codeRange }, std::forward<TArgs&&>(args)...);
				}
			};

			extern void						CreateParserGenTypeSyntax(SyntaxSymbolManager& manager);
			extern void						CreateParserGenRuleSyntax(SyntaxSymbolManager& manager);
		}
	}
}

#endif

/***********************************************************************
.\PARSERGEN\COMPILER.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_PARSERGEN_COMPILER
#define VCZH_PARSER2_PARSERGEN_COMPILER


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace compile_syntax
			{
				using GlrRuleMap = collections::Dictionary<RuleSymbol*, GlrRule*>;
				using LiteralTokenMap = collections::Dictionary<GlrLiteralSyntax*, vint32_t>;
				using RuleReuseDependencies = collections::Group<RuleSymbol*, RuleSymbol*>;
				using RuleKnownTypes = collections::Group<RuleSymbol*, AstClassSymbol*>;
				using ClauseReuseDependencies = collections::Group<GlrClause*, RuleSymbol*>;
				using ClauseTypeMap = collections::Dictionary<GlrClause*, AstClassSymbol*>;

				struct VisitorContext
				{
					ParserSymbolManager&		global;
					AstSymbolManager&			astManager;
					LexerSymbolManager&			lexerManager;
					SyntaxSymbolManager&		syntaxManager;
					Ptr<CppParserGenOutput>		output;

					GlrRuleMap					astRules;
					LiteralTokenMap				literalTokens;
					RuleReuseDependencies		ruleReuseDependencies;
					RuleKnownTypes				ruleKnownTypes;
					ClauseReuseDependencies		clauseReuseDependencies;
					ClauseTypeMap				clauseTypes;

					VisitorContext(
						AstSymbolManager& _astManager,
						LexerSymbolManager& _lexerManager,
						SyntaxSymbolManager& _syntaxManager,
						Ptr<CppParserGenOutput> _output
					)
						: global(_syntaxManager.Global())
						, astManager(_astManager)
						, lexerManager(_lexerManager)
						, syntaxManager(_syntaxManager)
						, output(_output)
					{
					}
				};
			}

/***********************************************************************
Compiler
***********************************************************************/

			extern void							CompileAst(AstSymbolManager& astManager, AstDefFile* astDefFile, Ptr<GlrAstFile> file);
			extern void							CompileLexer(LexerSymbolManager& lexerManager, const WString& input);
			extern void							CompileSyntax(AstSymbolManager& astManager, LexerSymbolManager& lexerManager, SyntaxSymbolManager& syntaxManager, Ptr<CppParserGenOutput> output, collections::List<Ptr<GlrSyntaxFile>>& files);
		}
	}
}

#endif

/***********************************************************************
.\SYNTAX\SYNTAXCPPGEN.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_SYNTAX_SYNTAXCPPGEN
#define VCZH_PARSER2_SYNTAX_SYNTAXCPPGEN


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			extern Ptr<CppSyntaxGenOutput>		GenerateSyntaxFileNames			(SyntaxSymbolManager& manager, Ptr<CppParserGenOutput> output);
			extern void							WriteSyntaxHeaderFile			(SyntaxSymbolManager& manager, automaton::Executable& executable, automaton::Metadata& metadata, Ptr<CppParserGenOutput> output, stream::StreamWriter& writer);
			extern void							WriteSyntaxCppFile				(SyntaxSymbolManager& manager, automaton::Executable& executable, automaton::Metadata& metadata, Ptr<CppParserGenOutput> output, stream::StreamWriter& writer);
			extern void							WriteSyntaxFiles				(SyntaxSymbolManager& manager, automaton::Executable& executable, automaton::Metadata& metadata, Ptr<CppParserGenOutput> output, collections::Dictionary<WString, WString>& files);
		}
	}
}

#endif

/***********************************************************************
.\SYNTAX\SYNTAXSYMBOLWRITER.H
***********************************************************************/
/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSER2_SYNTAX_SYNTAXWRITER
#define VCZH_PARSER2_SYNTAX_SYNTAXWRITER


namespace vl
{
	namespace glr
	{
		namespace parsergen
		{
			namespace syntax_writer
			{

/***********************************************************************
Clause
***********************************************************************/

				struct Token
				{
					vint32_t				id;
					vint32_t				field;
					WString					display;
				};

				struct Rule
				{
					static const vint		Partial = -2;
					static const vint		Discard = -1;

					RuleSymbol*				rule;
					vint32_t				field;
				};

				struct Use
				{
					RuleSymbol*				rule;
				};

				template<typename T>
				struct Loop
				{
					T						body;
				};

				template<typename T, typename U>
				struct LoopSep
				{
					T						body;
					U						delimiter;
				};

				template<typename T>
				struct Opt
				{
					T						body;
				};

				template<typename T, typename U>
				struct Seq
				{
					T						first;
					U						second;
				};

				template<typename T, typename U>
				struct Alt
				{
					T						first;
					U						second;
				};

				template<typename T>
				struct With
				{
					T						body;
					vint32_t				field;
					vint32_t				enumItem;
				};

				template<typename T>
				struct Create
				{
					T						body;
					vint32_t				type;

					template<typename F, typename E>
					Create<With<T>> with(F field, E enumItem)
					{
						return { { body,(vint32_t)field,(vint32_t)enumItem }, type };
					}
				};

				template<typename T>
				struct Partial
				{
					T						body;

					template<typename F, typename E>
					Partial<With<T>> with(F field, E enumItem)
					{
						return { { body,(vint32_t)field,(vint32_t)enumItem } };
					}
				};

				template<typename T>
				struct Reuse
				{
					T						body;

					template<typename F, typename E>
					Reuse<With<T>> with(F field, E enumItem)
					{
						return { { body,(vint32_t)field,(vint32_t)enumItem } };
					}
				};

/***********************************************************************
Verification
***********************************************************************/

				template<typename T>
				struct IsClause_ { static constexpr bool Value = false; };

				template<>
				struct IsClause_<Token> { static constexpr bool Value = true; };

				template<>
				struct IsClause_<Rule> { static constexpr bool Value = true; };

				template<>
				struct IsClause_<Use> { static constexpr bool Value = true; };

				template<typename T>
				struct IsClause_<Loop<T>> { static constexpr bool Value = IsClause_<T>::Value; };

				template<typename T, typename U>
				struct IsClause_<LoopSep<T, U>> { static constexpr bool Value = IsClause_<T>::Value && IsClause_<U>::Value; };

				template<typename T>
				struct IsClause_<Opt<T>> { static constexpr bool Value = IsClause_<T>::Value; };

				template<typename T, typename U>
				struct IsClause_<Seq<T, U>> { static constexpr bool Value = IsClause_<T>::Value && IsClause_<U>::Value; };

				template<typename T, typename U>
				struct IsClause_<Alt<T, U>> { static constexpr bool Value = IsClause_<T>::Value && IsClause_<U>::Value; };

				template<typename T>
				struct IsClause_<With<T>> { static constexpr bool Value = IsClause_<T>::Value; };

				template<typename T>
				struct IsClause_<Create<T>> { static constexpr bool Value = IsClause_<T>::Value; };

				template<typename T>
				struct IsClause_<Partial<T>> { static constexpr bool Value = IsClause_<T>::Value; };

				template<typename T>
				struct IsClause_<Reuse<T>> { static constexpr bool Value = IsClause_<T>::Value; };

				template<typename T>
				constexpr bool IsClause = IsClause_<T>::Value;

/***********************************************************************
Operators
***********************************************************************/

				template<typename T>
				inline Token tok(T id, const WString& display)
				{
					return { (vint32_t)id,-1,display };
				}

				template<typename T, typename F>
				inline Token tok(T id, const WString& display, F field = -1)
				{
					return { (vint32_t)id,(vint32_t)field,display };
				}

				inline Rule drule(RuleSymbol* r)
				{
					return { r,Rule::Discard };
				}

				inline Rule prule(RuleSymbol* r)
				{
					return { r,Rule::Partial };
				}

				template<typename F>
				inline Rule rule(RuleSymbol* r, F field)
				{
					return { r,(vint32_t)field };
				}

				inline Use use(RuleSymbol* r)
				{
					return { r };
				}

				template<typename C>
				inline std::enable_if_t<IsClause<C>, Loop<C>> loop(const C& clause)
				{
					return { clause };
				}

				template<typename C1, typename C2>
				inline std::enable_if_t<IsClause<C1> && IsClause<C2>, LoopSep<C1, C2>> loop(const C1& c1, const C2& c2)
				{
					return { c1,c2 };
				}

				template<typename C>
				inline std::enable_if_t<IsClause<C>, Opt<C>> opt(const C& clause)
				{
					return { clause };
				}

				template<typename C1, typename C2>
				inline std::enable_if_t<IsClause<C1> && IsClause<C2>, Seq<C1, C2>> operator+(const C1& c1, const C2& c2)
				{
					return { c1,c2 };
				}

				template<typename C1, typename C2>
				inline std::enable_if_t<IsClause<C1>&& IsClause<C2>, Alt<C1, C2>> operator|(const C1& c1, const C2& c2)
				{
					return { c1,c2 };
				}

				template<typename C, typename T>
				inline std::enable_if_t<IsClause<C>, Create<C>> create(const C& clause, T type)
				{
					return { clause,(vint32_t)type };
				}

				template<typename C>
				inline std::enable_if_t<IsClause<C>, Partial<C>> partial(const C& clause)
				{
					return { clause };
				}

				template<typename C>
				inline std::enable_if_t<IsClause<C>, Reuse<C>> reuse(const C& clause)
				{
					return { clause };
				}

/***********************************************************************
Builder
***********************************************************************/

				struct Clause
				{
					using StatePosMap = collections::Dictionary<StateSymbol*, vint>;
				private:
					struct StatePair
					{
						StateSymbol*			begin;
						StateSymbol*			end;
					};

					RuleSymbol*					ruleSymbol;
					WString						clauseDisplayText;
					StatePosMap					startPoses;
					StatePosMap					endPoses;

					StateSymbol* CreateState()
					{
						return ruleSymbol->Owner()->CreateState(ruleSymbol, ruleSymbol->CurrentClauseId());
					}

					EdgeSymbol* CreateEdge(StateSymbol* from, StateSymbol* to)
					{
						return ruleSymbol->Owner()->CreateEdge(from, to);
					}

					StatePair Build(const Token& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						{
							auto edge = CreateEdge(pair.begin, pair.end);
							edge->input.type = EdgeInputType::Token;
							edge->input.token = clause.id;
							if (clause.field != -1)
							{
								edge->insAfterInput.Add({ AstInsType::Token });
								edge->insAfterInput.Add({ AstInsType::Field,clause.field });
							}
						}

						clauseDisplayText += clause.display;
						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					StatePair Build(const Rule& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						{
							auto edge = CreateEdge(pair.begin, pair.end);
							edge->input.type = EdgeInputType::Rule;
							edge->input.rule = clause.rule;
							switch (clause.field)
							{
							case Rule::Partial:
								break;
							case Rule::Discard:
								edge->insAfterInput.Add({ AstInsType::DiscardValue });
								break;
							default:
								edge->insAfterInput.Add({ AstInsType::Field,clause.field });
							}
						}

						clauseDisplayText += clause.rule->Name();
						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					StatePair Build(const Use& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						{
							auto edge = CreateEdge(pair.begin, pair.end);
							edge->input.type = EdgeInputType::Rule;
							edge->input.rule = clause.rule;
							edge->insAfterInput.Add({ AstInsType::ReopenObject });
						}

						clauseDisplayText += L"!" + clause.rule->Name();
						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					template<typename C>
					StatePair Build(const Loop<C>& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						clauseDisplayText += L"{ ";
						auto bodyPair = Build(clause.body);
						clauseDisplayText += L" }";

						CreateEdge(pair.begin, bodyPair.begin);
						CreateEdge(bodyPair.end, pair.end);
						CreateEdge(pair.begin, pair.end);
						CreateEdge(bodyPair.end, bodyPair.begin);

						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					template<typename C1, typename C2>
					StatePair Build(const LoopSep<C1, C2>& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						clauseDisplayText += L"{ ";
						auto bodyPair = Build(clause.body);
						clauseDisplayText += L" ; ";
						auto delimiterPair = Build(clause.delimiter);
						clauseDisplayText += L" }";

						CreateEdge(pair.begin, bodyPair.begin);
						CreateEdge(bodyPair.end, pair.end);
						CreateEdge(pair.begin, pair.end);
						CreateEdge(bodyPair.end, delimiterPair.begin);
						CreateEdge(delimiterPair.end, bodyPair.begin);

						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					template<typename C>
					StatePair Build(const Opt<C>& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						clauseDisplayText += L"[ ";
						auto bodyPair = Build(clause.body);
						clauseDisplayText += L" ]";

						CreateEdge(pair.begin, bodyPair.begin);
						CreateEdge(bodyPair.end, pair.end);
						CreateEdge(pair.begin, pair.end);

						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					template<typename C1, typename C2>
					StatePair Build(const Seq<C1, C2>& clause)
					{
						auto firstPair = Build(clause.first);
						clauseDisplayText += L" ";
						auto secondPair = Build(clause.second);
						CreateEdge(firstPair.end, secondPair.begin);
						return { firstPair.begin,secondPair.end };
					}

					template<typename C1, typename C2>
					StatePair Build(const Alt<C1, C2>& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						clauseDisplayText += L"( ";
						auto firstPair = Build(clause.first);
						clauseDisplayText += L" | ";
						auto secondPair = Build(clause.second);
						clauseDisplayText += L" )";

						CreateEdge(pair.begin, firstPair.begin);
						CreateEdge(firstPair.end, pair.end);
						CreateEdge(pair.begin, secondPair.begin);
						CreateEdge(secondPair.end, pair.end);

						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					template<typename C>
					StatePair Build(const With<C>& clause)
					{
						auto pair = Build(clause.body);
						auto withState = CreateState();
						auto edge = CreateEdge(pair.end, withState);
						edge->insBeforeInput.Add({ AstInsType::EnumItem,clause.enumItem });
						edge->insBeforeInput.Add({ AstInsType::Field,clause.field });

						endPoses.Add(withState, clauseDisplayText.Length());
						return { pair.begin,withState };
					}

					template<typename C>
					StatePair Build(const Create<C>& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						clauseDisplayText += L"< ";
						auto bodyPair = Build(clause.body);
						clauseDisplayText += L" >";
						{
							auto edge = CreateEdge(pair.begin, bodyPair.begin);
							edge->insBeforeInput.Add({ AstInsType::BeginObject,clause.type });
						}
						{
							auto edge = CreateEdge(bodyPair.end, pair.end);
							edge->insBeforeInput.Add({ AstInsType::EndObject });
						}
						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					template<typename C>
					StatePair Build(const Partial<C>& clause)
					{
						return Build(clause.body);
					}

					template<typename C>
					StatePair Build(const Reuse<C>& clause)
					{
						StatePair pair;
						pair.begin = CreateState();
						pair.end = CreateState();
						startPoses.Add(pair.begin, clauseDisplayText.Length());

						clauseDisplayText += L"<< ";
						auto bodyPair = Build(clause.body);
						clauseDisplayText += L" >>";
						{
							auto edge = CreateEdge(pair.begin, bodyPair.begin);
							edge->insBeforeInput.Add({ AstInsType::DelayFieldAssignment });
						}
						{
							auto edge = CreateEdge(bodyPair.end, pair.end);
							edge->insBeforeInput.Add({ AstInsType::EndObject });
						}
						endPoses.Add(pair.end, clauseDisplayText.Length());
						return pair;
					}

					template<typename C>
					void Assign(const C& clause)
					{
						ruleSymbol->NewClause();

						clauseDisplayText = L"";
						startPoses.Clear();
						endPoses.Clear();

						auto pair = Build(clause);
						ruleSymbol->startStates.Add(pair.begin);
						pair.end->endingState = true;

						vint l = clauseDisplayText.Length();
						for (auto [state, pos] : startPoses)
						{
							state->label = clauseDisplayText.Left(pos) + L"@ " + clauseDisplayText.Right(l - pos);
						}
						for (auto [state, pos] : endPoses)
						{
							state->label = clauseDisplayText.Left(pos) + L" @" + clauseDisplayText.Right(l - pos);
						}
					}
				public:
					Clause(RuleSymbol* _ruleSymbol) : ruleSymbol(_ruleSymbol) {}

					template<typename C>
					Clause& operator=(const Create<C>& clause)
					{
						Assign(clause);
						return *this;
					}

					template<typename C>
					Clause& operator=(const Partial<C>& clause)
					{
						Assign(clause);
						return *this;
					}

					template<typename C>
					Clause& operator=(const Reuse<C>& clause)
					{
						Assign(clause);
						return *this;
					}

					template<typename C>
					Clause& operator=(const C& clause)
					{
						return operator=(reuse(clause));
					}
				};
			}
		}
	}
}

#endif
