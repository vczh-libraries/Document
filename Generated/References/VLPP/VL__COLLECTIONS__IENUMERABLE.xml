<Document accessor="" category="Class" name="IEnumerable"><summary>
 An enumerable interface representing all types that provide multiple values in order.
 range-based for-loop is not supported on enumerable yet, current we have &quot;FOREACH&quot; and &quot;FOREACH_INDEXER&quot; for iterating values.
 <symbols><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [Ss] const &amp;, bool)"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, ::vl::vint, bool)"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, [S] const *, bool)"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, ::vl::ObjectString&lt;[S]&gt; const &amp;, bool)"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void(::vl::ObjectString&lt;[D]&gt; &amp;, [Ss] const &amp;, bool)"/></symbols> functions work for all enumerable implementation.
 <symbol name="LazyList" docId="vl::collections::LazyList"/> provides high-level operations for enumerables, you can create a lazy list by calling <symbols><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::LazyList&lt;[T]&gt; const &amp;)"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const *, [T] const *)"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] [*] &amp;)"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const [*] &amp;)"/></symbols> on any enumerables.
 </summary><example index="0"/><typeparam name="T">Type of the values in the enumerable.</typeparam><signature><![CDATA[template <
    typename T
>
class IEnumerable
    : Interface;
]]></signature><basetypes><symbol name="Interface" docId="vl::Interface"/></basetypes></Document>