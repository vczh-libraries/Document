<!DOCTYPE html>
<html>
<head>
    <title>Interfaces.h</title>
    <link rel="stylesheet" href="../Cpp.css" />
    <link rel="shortcut icon" href="../favicon.ico" />
    <script type="text/javascript" src="../Cpp.js" ></script>
</head>
<body>
<a class="button" href="./FileIndex.html">File Index</a>
<a class="button" href="./SymbolIndex.html">Symbol Index</a>
<br>
<br>
<div class="codebox"><div class="cpp_default"><div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Stream::Interfaces

Interfaces:
	IStream							: Stream
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_STREAM_INTERFACES</div>
<div class="disabled">#define VCZH_STREAM_INTERFACES</div>

<div class="disabled">#include &lt;Vlpp.h&gt;</div>

<div class="token cpp_keyword ">namespace</div> <div class="def" id="NF[37]$vl"><div class="ref" onclick="jumpToSymbol([], ['vl'], [], [])">vl</div></div>
{
	<div class="token cpp_keyword ">namespace</div> <div class="def" id="NF[0]$vl::stream"><div class="ref" onclick="jumpToSymbol([], ['vl::stream'], [], [])">stream</div></div>
	{
		<div class="token cpp_comment ">/// &lt;summary&gt;</div>
		<div class="token cpp_comment ">/// Interface for streams. Stream functions are grouped into 5 categories:</div>
		<div class="token cpp_comment ">/// 1) Feature testing functions.</div>
		<div class="token cpp_comment ">/// 2) Read functions, available only if [M:vl.stream.IStream.CanRead] returns true.</div>
		<div class="token cpp_comment ">/// 3) Peek functions, available only if [M:vl.stream.IStream.CanPeek] returns true.</div>
		<div class="token cpp_comment ">/// 4) Write functions, available only if [M:vl.stream.IStream.CanWrite] returns true.</div>
		<div class="token cpp_comment ">/// 5) Seek functions, available only if [M:vl.stream.IStream.CanSeek] returns true.</div>
		<div class="token cpp_comment ">/// 6) Size functions, available only if [M:vl.stream.IStream.IsLimited] returns true. But there are still some streams knows that the content is limited, but the size is unknown. In this case, [M:vl.stream.IStream.Size] will return -1.</div>
		<div class="token cpp_comment ">/// &lt;/summary&gt;</div>
		<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::stream::IStream"><div><div class="token cpp_type">IStream</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Interface'], [], [])"><div class="token cpp_type">Interface</div></div>
		{
		<div class="token cpp_keyword ">public</div>:
			<div class="token cpp_comment ">/// &lt;summary&gt;Test if the stream is readable.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the stream is readable.&lt;/returns&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">bool</div>					<div class="def" id="FB$vl::stream::IStream::CanRead@bool()[decl0]"><div><div class="token cpp_function">CanRead</div></div></div>()<div class="token cpp_keyword ">const</div>=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Test if the stream is writable.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the stream is writable.&lt;/returns&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">bool</div>					<div class="def" id="FB$vl::stream::IStream::CanWrite@bool()[decl0]"><div><div class="token cpp_function">CanWrite</div></div></div>()<div class="token cpp_keyword ">const</div>=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Test if the stream is seekable.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the stream is seekable.&lt;/returns&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">bool</div>					<div class="def" id="FB$vl::stream::IStream::CanSeek@bool()[decl0]"><div><div class="token cpp_function">CanSeek</div></div></div>()<div class="token cpp_keyword ">const</div>=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Test if the stream is peekable.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the stream is peekable.&lt;/returns&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">bool</div>					<div class="def" id="FB$vl::stream::IStream::CanPeek@bool()[decl0]"><div><div class="token cpp_function">CanPeek</div></div></div>()<div class="token cpp_keyword ">const</div>=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Test if the content of the stream is limited. A writable stream can also be limited, it means that you can only write a limited content to the stream.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the content of the stream is limited.&lt;/returns&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">bool</div>					<div class="def" id="FB$vl::stream::IStream::IsLimited@bool()[decl0]"><div><div class="token cpp_function">IsLimited</div></div></div>()<div class="token cpp_keyword ">const</div>=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Test if the stream is available. For example, if you create a readable [T:vl.stream.FileStream] giving a wrong file name, it will be unavailable.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the stream is available.&lt;/returns&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">bool</div>					<div class="def" id="FB$vl::stream::IStream::IsAvailable@bool()[decl0]"><div><div class="token cpp_function">IsAvailable</div></div></div>()<div class="token cpp_keyword ">const</div>=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Close the stream.&lt;/summary&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div>					<div class="def" id="FB$vl::stream::IStream::Close@void()[decl0]"><div><div class="token cpp_function">Close</div></div></div>()=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Get the current position in the stream.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;The position in the stream. Returns -1 if the stream is not available.&lt;/returns&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['vl::pos_t'], [], [])"><div class="token cpp_type">pos_t</div></div>					<div class="def" id="FB$vl::stream::IStream::Position@::vl::pos_t()[decl0]"><div><div class="token cpp_function">Position</div></div></div>()<div class="token cpp_keyword ">const</div>=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Get the size of the content..&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;The size of the content. Returns -1 if the size is unknown or the stream is not available.&lt;/returns&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['vl::pos_t'], [], [])"><div class="token cpp_type">pos_t</div></div>					<div class="def" id="FB$vl::stream::IStream::Size@::vl::pos_t()[decl0]"><div><div class="token cpp_function">Size</div></div></div>()<div class="token cpp_keyword ">const</div>=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Step forward or backward from the current position. Will throw exception if the stream is not seekable or not available.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_size&quot;&gt;The length of the step.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div>					<div class="def" id="FB$vl::stream::IStream::Seek@void(::vl::pos_t)[decl0]"><div><div class="token cpp_function">Seek</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::pos_t'], [], [])"><div class="token cpp_type">pos_t</div></div> <div class="def" id="NI$vl::stream::IStream::Seek@void(::vl::pos_t)[decl0]::_size"><div>_size</div></div>)=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Step fowward from the beginning. Will throw exception if the stream is not seekable or not available.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_size&quot;&gt;The length of the step.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div>					<div class="def" id="FB$vl::stream::IStream::SeekFromBegin@void(::vl::pos_t)[decl0]"><div><div class="token cpp_function">SeekFromBegin</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::pos_t'], [], [])"><div class="token cpp_type">pos_t</div></div> <div class="def" id="NI$vl::stream::IStream::SeekFromBegin@void(::vl::pos_t)[decl0]::_size"><div>_size</div></div>)=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Step backward from the end. Will throw exception if the stream is not seekable or not available.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_size&quot;&gt;The length of the step.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div>					<div class="def" id="FB$vl::stream::IStream::SeekFromEnd@void(::vl::pos_t)[decl0]"><div><div class="token cpp_function">SeekFromEnd</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::pos_t'], [], [])"><div class="token cpp_type">pos_t</div></div> <div class="def" id="NI$vl::stream::IStream::SeekFromEnd@void(::vl::pos_t)[decl0]::_size"><div>_size</div></div>)=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Read from the current position and step forward. Will throw exception if the stream is not readable or not available.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns the actual size of the content that is read. Returns 0 indicates that the stream reaches the end if the stream is limited.&lt;/returns&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_buffer&quot;&gt;A buffer to store the content.&lt;/param&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_size&quot;&gt;The size of the content that is expected to read.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>					<div class="def" id="FB$vl::stream::IStream::Read@::vl::vint(void *, ::vl::vint)[decl0]"><div><div class="token cpp_function">Read</div></div></div>(<div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::stream::IStream::Read@::vl::vint(void *, ::vl::vint)[decl0]::_buffer"><div>_buffer</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::stream::IStream::Read@::vl::vint(void *, ::vl::vint)[decl0]::_size"><div>_size</div></div>)=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Write to the current position and step forward. Will throw exception if the stream is not writable or not available.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns the actual size of the content that is written. Returns 0 indicates that the stream reaches the end if the stream is limited.&lt;/returns&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_buffer&quot;&gt;A buffer storing the content to write.&lt;/param&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_size&quot;&gt;The size of the content that is expected to write.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>					<div class="def" id="FB$vl::stream::IStream::Write@::vl::vint(void *, ::vl::vint)[decl0]"><div><div class="token cpp_function">Write</div></div></div>(<div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::stream::IStream::Write@::vl::vint(void *, ::vl::vint)[decl0]::_buffer"><div>_buffer</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::stream::IStream::Write@::vl::vint(void *, ::vl::vint)[decl0]::_size"><div>_size</div></div>)=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Read from the current position but not step forward. Will throw exception if the stream is not peekable or not available.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns the actual size of the content that is read. Returns 0 indicates that the stream reaches the end if the stream is limited.&lt;/returns&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_buffer&quot;&gt;A buffer to store the content.&lt;/param&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_size&quot;&gt;The size of the content that is expected to peek.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>					<div class="def" id="FB$vl::stream::IStream::Peek@::vl::vint(void *, ::vl::vint)[decl0]"><div><div class="token cpp_function">Peek</div></div></div>(<div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::stream::IStream::Peek@::vl::vint(void *, ::vl::vint)[decl0]::_buffer"><div>_buffer</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::stream::IStream::Peek@::vl::vint(void *, ::vl::vint)[decl0]::_size"><div>_size</div></div>)=<div class="token cpp_number ">0</div>;
		};

		<div class="token cpp_comment ">/// &lt;summary&gt;Encoder interface. This interface defines a writable transformation from one stream to another stream. You can create a [T:vl.stream.EncoderStream] after you have an encoder.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::stream::IEncoder"><div><div class="token cpp_type">IEncoder</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Interface'], [], [])"><div class="token cpp_type">Interface</div></div>
		{
		<div class="token cpp_keyword ">public</div>:
			<div class="token cpp_comment ">/// &lt;summary&gt;Set a target writable stream. The &lt;see cref=&quot;Write&quot;/&gt; function will transform the content and write to this tream.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_stream&quot;&gt;The target writable stream.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div>					<div class="def" id="FB$vl::stream::IEncoder::Setup@void(::vl::stream::IStream *)[decl0]"><div><div class="token cpp_function">Setup</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::stream::IStream'], [], [])"><div class="token cpp_type">IStream</div></div>* <div class="def" id="NI$vl::stream::IEncoder::Setup@void(::vl::stream::IStream *)[decl0]::_stream"><div>_stream</div></div>)=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Stop the transformation, ensuring all written content is transformed to the target stream.&lt;/summary&gt;</div>
			<div class="token cpp_keyword ">virtual</div>	<div class="token cpp_keyword ">void</div>					<div class="def" id="FB$vl::stream::IEncoder::Close@void()[decl0]"><div><div class="token cpp_function">Close</div></div></div>()=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Transform content and write to the target stream. This function may cache something to increase performance, so it cannot expect that all transformed content will be written to the target stream immediately.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns the actual size of the content before transforming that is written. The content is treated as being written even it is cached and not actually write to the target stream.&lt;/returns&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_buffer&quot;&gt;A buffer storing the content to write.&lt;/param&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_size&quot;&gt;The size of the content that is expected to write.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>					<div class="def" id="FB$vl::stream::IEncoder::Write@::vl::vint(void *, ::vl::vint)[decl0]"><div><div class="token cpp_function">Write</div></div></div>(<div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::stream::IEncoder::Write@::vl::vint(void *, ::vl::vint)[decl0]::_buffer"><div>_buffer</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::stream::IEncoder::Write@::vl::vint(void *, ::vl::vint)[decl0]::_size"><div>_size</div></div>)=<div class="token cpp_number ">0</div>;
		};
		
		<div class="token cpp_comment ">/// &lt;summary&gt;Decoder interface. This interface defines a readable transformation from one stream to another stream. You can create a [T:vl.stream.DecoderStream] after you have an decoder.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::stream::IDecoder"><div><div class="token cpp_type">IDecoder</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Interface'], [], [])"><div class="token cpp_type">Interface</div></div>
		{
		<div class="token cpp_keyword ">public</div>:
			<div class="token cpp_comment ">/// &lt;summary&gt;Set a target readable stream. The &lt;see cref=&quot;Read&quot;/&gt; function will read from this tream and transform the content.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_stream&quot;&gt;The target readable stream.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div>					<div class="def" id="FB$vl::stream::IDecoder::Setup@void(::vl::stream::IStream *)[decl0]"><div><div class="token cpp_function">Setup</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::stream::IStream'], [], [])"><div class="token cpp_type">IStream</div></div>* <div class="def" id="NI$vl::stream::IDecoder::Setup@void(::vl::stream::IStream *)[decl0]::_stream"><div>_stream</div></div>)=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Stop the transformation.&lt;/summary&gt;</div>
			<div class="token cpp_keyword ">virtual</div>	<div class="token cpp_keyword ">void</div>					<div class="def" id="FB$vl::stream::IDecoder::Close@void()[decl0]"><div><div class="token cpp_function">Close</div></div></div>()=<div class="token cpp_number ">0</div>;
			<div class="token cpp_comment ">/// &lt;summary&gt;Read from the target stream and transform the content.&lt;/summary&gt;</div>
			<div class="token cpp_comment ">/// &lt;returns&gt;Returns the actual size of the content after transforming that is read.&lt;/returns&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_buffer&quot;&gt;A buffer to store the content.&lt;/param&gt;</div>
			<div class="token cpp_comment ">/// &lt;param name=&quot;_size&quot;&gt;The size of the content that is expected to read.&lt;/param&gt;</div>
			<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>					<div class="def" id="FB$vl::stream::IDecoder::Read@::vl::vint(void *, ::vl::vint)[decl0]"><div><div class="token cpp_function">Read</div></div></div>(<div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::stream::IDecoder::Read@::vl::vint(void *, ::vl::vint)[decl0]::_buffer"><div>_buffer</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::stream::IDecoder::Read@::vl::vint(void *, ::vl::vint)[decl0]::_size"><div>_size</div></div>)=<div class="token cpp_number ">0</div>;
		};
	}
}

<div class="disabled">#endif</div>
</div></div>
<script type="text/javascript">
referencedSymbols = {
    'vl': {
        'displayNameInHtml': 'vl',
        'impls': [],
        'decls': [
            'NF[0]$vl',
            'NF[1]$vl',
            'NF[2]$vl',
            'NF[3]$vl',
            'NF[4]$vl',
            'NF[5]$vl',
            'NF[6]$vl',
            'NF[7]$vl',
            'NF[8]$vl',
            'NF[9]$vl',
            'NF[10]$vl',
            'NF[11]$vl',
            'NF[12]$vl',
            'NF[13]$vl',
            'NF[14]$vl',
            'NF[15]$vl',
            'NF[16]$vl',
            'NF[17]$vl',
            'NF[18]$vl',
            'NF[19]$vl',
            'NF[20]$vl',
            'NF[21]$vl',
            'NF[22]$vl',
            'NF[23]$vl',
            'NF[24]$vl',
            'NF[25]$vl',
            'NF[26]$vl',
            'NF[27]$vl',
            'NF[28]$vl',
            'NF[29]$vl',
            'NF[30]$vl',
            'NF[31]$vl',
            'NF[32]$vl',
            'NF[33]$vl',
            'NF[34]$vl',
            'NF[35]$vl',
            'NF[36]$vl',
            'NF[37]$vl',
            'NF[38]$vl',
            'NF[39]$vl',
            'NF[40]$vl',
            'NF[41]$vl',
            'NF[42]$vl',
            'NF[43]$vl',
            'NF[44]$vl',
            'NF[45]$vl',
            'NF[46]$vl',
            'NF[47]$vl',
            'NF[48]$vl',
            'NF[49]$vl',
            'NF[50]$vl',
            'NF[51]$vl',
            'NF[52]$vl',
            'NF[53]$vl',
            'NF[54]$vl',
            'NF[55]$vl',
            'NF[56]$vl',
            'NF[57]$vl',
            'NF[58]$vl',
            'NF[59]$vl',
            'NF[60]$vl',
            'NF[61]$vl',
            'NF[62]$vl',
            'NF[63]$vl',
            'NF[64]$vl',
            'NF[65]$vl',
            'NF[66]$vl',
            'NF[67]$vl',
            'NF[68]$vl',
            'NF[69]$vl',
            'NF[70]$vl',
            'NF[71]$vl',
            'NF[72]$vl',
            'NF[73]$vl',
            'NF[74]$vl',
            'NF[75]$vl',
            'NF[76]$vl'
        ]
    },
    'vl::Interface': {
        'displayNameInHtml': '<span class="cpp_type">Interface</span>',
        'impls': [
            'NI$vl::Interface'
        ],
        'decls': []
    },
    'vl::pos_t': {
        'displayNameInHtml': '<span class="cpp_type">pos_t</span>',
        'impls': [
            'NI$vl::pos_t'
        ],
        'decls': []
    },
    'vl::stream': {
        'displayNameInHtml': 'vl::stream',
        'impls': [],
        'decls': [
            'NF[0]$vl::stream',
            'NF[1]$vl::stream',
            'NF[2]$vl::stream',
            'NF[3]$vl::stream',
            'NF[4]$vl::stream',
            'NF[5]$vl::stream',
            'NF[6]$vl::stream',
            'NF[7]$vl::stream',
            'NF[8]$vl::stream',
            'NF[9]$vl::stream',
            'NF[10]$vl::stream',
            'NF[11]$vl::stream',
            'NF[12]$vl::stream',
            'NF[13]$vl::stream',
            'NF[14]$vl::stream',
            'NF[15]$vl::stream',
            'NF[16]$vl::stream',
            'NF[17]$vl::stream',
            'NF[18]$vl::stream'
        ]
    },
    'vl::stream::IStream': {
        'displayNameInHtml': '<span class="cpp_type">IStream</span>',
        'impls': [
            'NI$vl::stream::IStream'
        ],
        'decls': []
    },
    'vl::vint': {
        'displayNameInHtml': '<span class="cpp_type">vint</span>',
        'impls': [
            'NI$vl::vint'
        ],
        'decls': []
    }
};
symbolToFiles = {
    'NF[0]$vl': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' },
    'NF[0]$vl::stream': null,
    'NF[10]$vl': { 'htmlFileName': 'Interfaces.h', 'displayName': 'Interfaces.h' },
    'NF[10]$vl::stream': { 'htmlFileName': 'Accessor.cpp', 'displayName': 'Accessor.cpp' },
    'NF[11]$vl': { 'htmlFileName': 'List.h', 'displayName': 'List.h' },
    'NF[11]$vl::stream': { 'htmlFileName': 'BroadcastStream.cpp', 'displayName': 'BroadcastStream.cpp' },
    'NF[12]$vl': { 'htmlFileName': 'Dictionary.h', 'displayName': 'Dictionary.h' },
    'NF[12]$vl::stream': { 'htmlFileName': 'CacheStream.cpp', 'displayName': 'CacheStream.cpp' },
    'NF[13]$vl': { 'htmlFileName': 'OperationCopyFrom.h', 'displayName': 'OperationCopyFrom.h' },
    'NF[13]$vl::stream': { 'htmlFileName': 'CharFormat.cpp', 'displayName': 'CharFormat.cpp' },
    'NF[14]$vl': { 'htmlFileName': 'OperationEnumerable.h', 'displayName': 'OperationEnumerable.h' },
    'NF[14]$vl::stream': { 'htmlFileName': 'CompressionStream.cpp', 'displayName': 'CompressionStream.cpp' },
    'NF[15]$vl': { 'htmlFileName': 'OperationConcat.h', 'displayName': 'OperationConcat.h' },
    'NF[15]$vl::stream': { 'htmlFileName': 'FileStream.cpp', 'displayName': 'FileStream.cpp' },
    'NF[16]$vl': { 'htmlFileName': 'OperationForEach.h', 'displayName': 'OperationForEach.h' },
    'NF[16]$vl::stream': { 'htmlFileName': 'MemoryStream.cpp', 'displayName': 'MemoryStream.cpp' },
    'NF[17]$vl': { 'htmlFileName': 'OperationPair.h', 'displayName': 'OperationPair.h' },
    'NF[17]$vl::stream': { 'htmlFileName': 'MemoryWrapperStream.cpp', 'displayName': 'MemoryWrapperStream.cpp' },
    'NF[18]$vl': { 'htmlFileName': 'OperationSelect.h', 'displayName': 'OperationSelect.h' },
    'NF[18]$vl::stream': { 'htmlFileName': 'RecorderStream.cpp', 'displayName': 'RecorderStream.cpp' },
    'NF[19]$vl': { 'htmlFileName': 'OperationSequence.h', 'displayName': 'OperationSequence.h' },
    'NF[1]$vl': { 'htmlFileName': 'Pointer.h', 'displayName': 'Pointer.h' },
    'NF[1]$vl::stream': { 'htmlFileName': 'BroadcastStream.h', 'displayName': 'BroadcastStream.h' },
    'NF[20]$vl': { 'htmlFileName': 'OperationSet.h', 'displayName': 'OperationSet.h' },
    'NF[21]$vl': { 'htmlFileName': 'OperationString.h', 'displayName': 'OperationString.h' },
    'NF[22]$vl': { 'htmlFileName': 'OperationWhere.h', 'displayName': 'OperationWhere.h' },
    'NF[23]$vl': { 'htmlFileName': 'Operation.h', 'displayName': 'Operation.h' },
    'NF[24]$vl': { 'htmlFileName': 'Event.h', 'displayName': 'Event.h' },
    'NF[25]$vl': { 'htmlFileName': 'PartialOrdering.h', 'displayName': 'PartialOrdering.h' },
    'NF[26]$vl': { 'htmlFileName': 'UnitTest.h', 'displayName': 'UnitTest.h' },
    'NF[27]$vl': { 'htmlFileName': 'Basic.cpp', 'displayName': 'Basic.cpp' },
    'NF[28]$vl': { 'htmlFileName': 'Console.cpp', 'displayName': 'Console.cpp' },
    'NF[29]$vl': { 'htmlFileName': 'Exception.cpp', 'displayName': 'Exception.cpp' },
    'NF[2]$vl': { 'htmlFileName': 'Function.h', 'displayName': 'Function.h' },
    'NF[2]$vl::stream': { 'htmlFileName': 'CacheStream.h', 'displayName': 'CacheStream.h' },
    'NF[30]$vl': { 'htmlFileName': 'GlobalStorage.cpp', 'displayName': 'GlobalStorage.cpp' },
    'NF[31]$vl': { 'htmlFileName': 'String.cpp', 'displayName': 'String.cpp' },
    'NF[32]$vl': { 'htmlFileName': 'PartialOrdering.cpp', 'displayName': 'PartialOrdering.cpp' },
    'NF[33]$vl': { 'htmlFileName': 'UnitTest.cpp', 'displayName': 'UnitTest.cpp' },
    'NF[34]$vl': { 'htmlFileName': 'HttpUtility.h', 'displayName': 'HttpUtility.h' },
    'NF[35]$vl': { 'htmlFileName': 'Locale.h', 'displayName': 'Locale.h' },
    'NF[36]$vl': { 'htmlFileName': 'Threading.h', 'displayName': 'Threading.h' },
    'NF[37]$vl': null,
    'NF[38]$vl': { 'htmlFileName': 'BroadcastStream.h', 'displayName': 'BroadcastStream.h' },
    'NF[39]$vl': { 'htmlFileName': 'CacheStream.h', 'displayName': 'CacheStream.h' },
    'NF[3]$vl': { 'htmlFileName': 'Lazy.h', 'displayName': 'Lazy.h' },
    'NF[3]$vl::stream': { 'htmlFileName': 'CompressionStream.h', 'displayName': 'CompressionStream.h' },
    'NF[40]$vl': { 'htmlFileName': 'CompressionStream.h', 'displayName': 'CompressionStream.h' },
    'NF[41]$vl': { 'htmlFileName': 'FileStream.h', 'displayName': 'FileStream.h' },
    'NF[42]$vl': { 'htmlFileName': 'MemoryStream.h', 'displayName': 'MemoryStream.h' },
    'NF[43]$vl': { 'htmlFileName': 'Accessor.h', 'displayName': 'Accessor.h' },
    'NF[44]$vl': { 'htmlFileName': 'MemoryWrapperStream.h', 'displayName': 'MemoryWrapperStream.h' },
    'NF[45]$vl': { 'htmlFileName': 'CharFormat.h', 'displayName': 'CharFormat.h' },
    'NF[46]$vl': { 'htmlFileName': 'FileSystem.h', 'displayName': 'FileSystem.h' },
    'NF[47]$vl': { 'htmlFileName': 'RecorderStream.h', 'displayName': 'RecorderStream.h' },
    'NF[48]$vl': { 'htmlFileName': 'FileSystem.cpp', 'displayName': 'FileSystem.cpp' },
    'NF[49]$vl': { 'htmlFileName': 'HttpUtility.cpp', 'displayName': 'HttpUtility.cpp' },
    'NF[4]$vl': { 'htmlFileName': 'String.h', 'displayName': 'String.h' },
    'NF[4]$vl::stream': { 'htmlFileName': 'FileStream.h', 'displayName': 'FileStream.h' },
    'NF[50]$vl': { 'htmlFileName': 'Locale.cpp', 'displayName': 'Locale.cpp' },
    'NF[51]$vl': { 'htmlFileName': 'Threading.cpp', 'displayName': 'Threading.cpp' },
    'NF[52]$vl': { 'htmlFileName': 'Threading.cpp', 'displayName': 'Threading.cpp' },
    'NF[53]$vl': { 'htmlFileName': 'Accessor.cpp', 'displayName': 'Accessor.cpp' },
    'NF[54]$vl': { 'htmlFileName': 'BroadcastStream.cpp', 'displayName': 'BroadcastStream.cpp' },
    'NF[55]$vl': { 'htmlFileName': 'CacheStream.cpp', 'displayName': 'CacheStream.cpp' },
    'NF[56]$vl': { 'htmlFileName': 'CharFormat.cpp', 'displayName': 'CharFormat.cpp' },
    'NF[57]$vl': { 'htmlFileName': 'CompressionStream.cpp', 'displayName': 'CompressionStream.cpp' },
    'NF[58]$vl': { 'htmlFileName': 'FileStream.cpp', 'displayName': 'FileStream.cpp' },
    'NF[59]$vl': { 'htmlFileName': 'MemoryStream.cpp', 'displayName': 'MemoryStream.cpp' },
    'NF[5]$vl': { 'htmlFileName': 'Console.h', 'displayName': 'Console.h' },
    'NF[5]$vl::stream': { 'htmlFileName': 'MemoryStream.h', 'displayName': 'MemoryStream.h' },
    'NF[60]$vl': { 'htmlFileName': 'MemoryWrapperStream.cpp', 'displayName': 'MemoryWrapperStream.cpp' },
    'NF[61]$vl': { 'htmlFileName': 'RecorderStream.cpp', 'displayName': 'RecorderStream.cpp' },
    'NF[62]$vl': { 'htmlFileName': 'Regex.h', 'displayName': 'Regex.h' },
    'NF[63]$vl': { 'htmlFileName': 'RegexData.h', 'displayName': 'RegexData.h' },
    'NF[64]$vl': { 'htmlFileName': 'RegexAutomaton.h', 'displayName': 'RegexAutomaton.h' },
    'NF[65]$vl': { 'htmlFileName': 'RegexExpression.h', 'displayName': 'RegexExpression.h' },
    'NF[66]$vl': { 'htmlFileName': 'RegexPure.h', 'displayName': 'RegexPure.h' },
    'NF[67]$vl': { 'htmlFileName': 'RegexRich.h', 'displayName': 'RegexRich.h' },
    'NF[68]$vl': { 'htmlFileName': 'RegexWriter.h', 'displayName': 'RegexWriter.h' },
    'NF[69]$vl': { 'htmlFileName': 'Regex.cpp', 'displayName': 'Regex.cpp' },
    'NF[6]$vl': { 'htmlFileName': 'Exception.h', 'displayName': 'Exception.h' },
    'NF[6]$vl::stream': { 'htmlFileName': 'Accessor.h', 'displayName': 'Accessor.h' },
    'NF[70]$vl': { 'htmlFileName': 'RegexAutomaton.cpp', 'displayName': 'RegexAutomaton.cpp' },
    'NF[71]$vl': { 'htmlFileName': 'RegexData.cpp', 'displayName': 'RegexData.cpp' },
    'NF[72]$vl': { 'htmlFileName': 'RegexExpression.cpp', 'displayName': 'RegexExpression.cpp' },
    'NF[73]$vl': { 'htmlFileName': 'RegexParser.cpp', 'displayName': 'RegexParser.cpp' },
    'NF[74]$vl': { 'htmlFileName': 'RegexPure.cpp', 'displayName': 'RegexPure.cpp' },
    'NF[75]$vl': { 'htmlFileName': 'RegexRich.cpp', 'displayName': 'RegexRich.cpp' },
    'NF[76]$vl': { 'htmlFileName': 'RegexWriter.cpp', 'displayName': 'RegexWriter.cpp' },
    'NF[7]$vl': { 'htmlFileName': 'GlobalStorage.h', 'displayName': 'GlobalStorage.h' },
    'NF[7]$vl::stream': { 'htmlFileName': 'MemoryWrapperStream.h', 'displayName': 'MemoryWrapperStream.h' },
    'NF[8]$vl': { 'htmlFileName': 'Tuple.h', 'displayName': 'Tuple.h' },
    'NF[8]$vl::stream': { 'htmlFileName': 'CharFormat.h', 'displayName': 'CharFormat.h' },
    'NF[9]$vl': { 'htmlFileName': 'Pair.h', 'displayName': 'Pair.h' },
    'NF[9]$vl::stream': { 'htmlFileName': 'RecorderStream.h', 'displayName': 'RecorderStream.h' },
    'NI$vl::Interface': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' },
    'NI$vl::pos_t': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' },
    'NI$vl::stream::IStream': null,
    'NI$vl::vint': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' }
};
turnOnSymbol();
</script>
</body>
</html>
