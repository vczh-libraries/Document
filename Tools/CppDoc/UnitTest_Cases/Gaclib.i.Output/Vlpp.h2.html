<!DOCTYPE html>
<html>
<head>
    <title>Vlpp.h</title>
    <link rel="stylesheet" href="../Cpp.css" />
    <link rel="shortcut icon" href="../favicon.ico" />
    <script type="text/javascript" src="../Cpp.js" ></script>
</head>
<body>
<a class="button" href="./FileIndex.html">File Index</a>
<a class="button" href="./SymbolIndex.html">Symbol Index</a>
<br>
<br>
<div class="codebox"><div class="cpp_default"><div class="token cpp_comment ">/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/</div>

<div class="token cpp_comment ">/***********************************************************************
.\BASIC.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Framework::Basic

Classes:
	NotCopyable									: Object inherits from this type cannot be copied
	Error										: Error, unlike exception, is not encouraged to catch
	Object										: Base class of all classes

Macros:
	CHECK_ERROR(CONDITION,DESCRIPTION)			: Assert, throws an Error if failed
	CHECK_FAIL(DESCRIPTION)						: Force an assert failure
	SCOPE_VARIABLE(TYPE,VARIABLE,VALUE){ ... }	: Scoped variable
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_BASIC</div>
<div class="disabled">#define VCZH_BASIC</div>

<div class="disabled">#ifdef VCZH_CHECK_MEMORY_LEAKS</div>
<div class="disabled">#define _CRTDBG_MAP_ALLOC</div>
<div class="disabled">#include &lt;stdlib.h&gt;</div>
<div class="disabled">#include &lt;crtdbg.h&gt;</div>
<div class="disabled">#define VCZH_CHECK_MEMORY_LEAKS_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)</div>
<div class="disabled">#define new VCZH_CHECK_MEMORY_LEAKS_NEW</div>
<div class="disabled">#endif</div>

<div class="disabled">#if defined _WIN64 || __x86_64 || __LP64__</div>
<div class="disabled">#define VCZH_64</div>
<div class="disabled">#endif</div>

<div class="disabled">#if defined _MSC_VER</div>
<div class="disabled">#define VCZH_MSVC</div>
<div class="disabled">#else</div>
<div class="disabled">#define VCZH_GCC</div>
<div class="disabled">#if defined(__APPLE__)</div>
<div class="disabled">#define VCZH_APPLE</div>
<div class="disabled">#endif</div>
<div class="disabled">#endif</div>

<div class="disabled">#if defined VCZH_CLANG_AST_DUMP</div>
<div class="disabled">#define abstract</div>
<div class="disabled">#endif</div>

<div class="disabled">#if defined VCZH_MSVC</div>
<div class="disabled">#include &lt;intrin.h&gt;</div>
<div class="disabled">#elif defined VCZH_GCC</div>
<div class="disabled">#include &lt;x86intrin.h&gt;</div>
<div class="disabled">#include &lt;stdint.h&gt;</div>
<div class="disabled">#include &lt;stddef.h&gt;</div>
<div class="disabled">#include &lt;wchar.h&gt;</div>
<div class="disabled">#define abstract</div>
<div class="disabled">#define __thiscall</div>
<div class="disabled">#define __forceinline inline</div>

<div class="disabled">#define _I8_MIN     ((vint8_t)0x80)</div>
<div class="disabled">#define _I8_MAX     ((vint8_t)0x7F)</div>
<div class="disabled">#define _UI8_MAX    ((vuint8_t)0xFF)</div>

<div class="disabled">#define _I16_MIN    ((vint16_t)0x8000)</div>
<div class="disabled">#define _I16_MAX    ((vint16_t)0x7FFF)</div>
<div class="disabled">#define _UI16_MAX   ((vuint16_t)0xFFFF)</div>

<div class="disabled">#define _I32_MIN    ((vint32_t)0x80000000)</div>
<div class="disabled">#define _I32_MAX    ((vint32_t)0x7FFFFFFF)</div>
<div class="disabled">#define _UI32_MAX   ((vuint32_t)0xFFFFFFFF)</div>

<div class="disabled">#define _I64_MIN    ((vint64_t)0x8000000000000000L)</div>
<div class="disabled">#define _I64_MAX    ((vint64_t)0x7FFFFFFFFFFFFFFFL)</div>
<div class="disabled">#define _UI64_MAX   ((vuint64_t)0xFFFFFFFFFFFFFFFFL)</div>
<div class="disabled">#endif</div>

<div class="disabled">#define L_(x) L__(x)</div>
<div class="disabled">#define L__(x) L ## x</div>

<div class="disabled">namespace vl</div>
<div class="disabled">{</div>

<div class="disabled">	/***********************************************************************</div>
<div class="disabled">	x86 and x64 Compatbility</div>
<div class="disabled">	***********************************************************************/</div>

<div class="disabled">#if defined VCZH_MSVC</div>
<div class="disabled">	/// &lt;summary&gt;1-byte signed integer.&lt;/summary&gt;</div>
<div class="disabled">	typedef signed __int8			vint8_t;</div>
<div class="disabled">	/// &lt;summary&gt;1-byte unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	typedef unsigned __int8			vuint8_t;</div>
<div class="disabled">	/// &lt;summary&gt;2-bytes signed integer.&lt;/summary&gt;</div>
<div class="disabled">	typedef signed __int16			vint16_t;</div>
<div class="disabled">	/// &lt;summary&gt;2-bytes unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	typedef unsigned __int16		vuint16_t;</div>
<div class="disabled">	/// &lt;summary&gt;4-bytes signed integer.&lt;/summary&gt;</div>
<div class="disabled">	typedef signed __int32			vint32_t;</div>
<div class="disabled">	/// &lt;summary&gt;4-bytes unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	typedef unsigned __int32		vuint32_t;</div>
<div class="disabled">	/// &lt;summary&gt;8-bytes signed integer.&lt;/summary&gt;</div>
<div class="disabled">	typedef signed __int64			vint64_t;</div>
<div class="disabled">	/// &lt;summary&gt;8-bytes unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	typedef unsigned __int64		vuint64_t;</div>
<div class="disabled">#elif defined VCZH_GCC</div>
<div class="disabled">	typedef int8_t					vint8_t;</div>
<div class="disabled">	typedef uint8_t					vuint8_t;</div>
<div class="disabled">	typedef int16_t					vint16_t;</div>
<div class="disabled">	typedef uint16_t				vuint16_t;</div>
<div class="disabled">	typedef int32_t					vint32_t;</div>
<div class="disabled">	typedef uint32_t				vuint32_t;</div>
<div class="disabled">	typedef int64_t					vint64_t;</div>
<div class="disabled">	typedef uint64_t				vuint64_t;</div>
<div class="disabled">#endif</div>

<div class="disabled">#ifdef VCZH_64</div>
<div class="disabled">	/// &lt;summary&gt;Signed interface whose size is equal to sizeof(void*).&lt;/summary&gt;</div>
<div class="disabled">	typedef vint64_t				vint;</div>
<div class="disabled">	/// &lt;summary&gt;Signed interface whose size is equal to sizeof(void*).&lt;/summary&gt;</div>
<div class="disabled">	typedef vint64_t				vsint;</div>
<div class="disabled">	/// &lt;summary&gt;Unsigned interface whose size is equal to sizeof(void*).&lt;/summary&gt;</div>
<div class="disabled">	typedef vuint64_t				vuint;</div>
<div class="disabled">#else</div>
<div class="disabled">	/// &lt;summary&gt;Signed interface whose size is equal to sizeof(void*).&lt;/summary&gt;</div>
<div class="disabled">	typedef vint32_t				vint;</div>
<div class="disabled">	/// &lt;summary&gt;Signed interface whose size is equal to sizeof(void*).&lt;/summary&gt;</div>
<div class="disabled">	typedef vint32_t				vsint;</div>
<div class="disabled">	/// &lt;summary&gt;Unsigned interface whose size is equal to sizeof(void*).&lt;/summary&gt;</div>
<div class="disabled">	typedef vuint32_t				vuint;</div>
<div class="disabled">#endif</div>
<div class="disabled">	/// &lt;summary&gt;Signed interger representing position.&lt;/summary&gt;</div>
<div class="disabled">	typedef vint64_t				pos_t;</div>

<div class="disabled">#ifdef VCZH_64</div>
<div class="disabled">#define ITOA_S		_i64toa_s</div>
<div class="disabled">#define ITOW_S		_i64tow_s</div>
<div class="disabled">#define I64TOA_S	_i64toa_s</div>
<div class="disabled">#define I64TOW_S	_i64tow_s</div>
<div class="disabled">#define UITOA_S		_ui64toa_s</div>
<div class="disabled">#define UITOW_S		_ui64tow_s</div>
<div class="disabled">#define UI64TOA_S	_ui64toa_s</div>
<div class="disabled">#define UI64TOW_S	_ui64tow_s</div>
<div class="disabled">#if defined VCZH_MSVC</div>
<div class="disabled">#define INCRC(x)	(_InterlockedIncrement64(x))</div>
<div class="disabled">#define DECRC(x)	(_InterlockedDecrement64(x))</div>
<div class="disabled">#elif defined VCZH_GCC</div>
<div class="disabled">#define INCRC(x)	(__sync_add_and_fetch(x, 1))</div>
<div class="disabled">#define DECRC(x)	(__sync_sub_and_fetch(x, 1))</div>
<div class="disabled">#endif</div>
<div class="disabled">#else</div>
<div class="disabled">#define ITOA_S		_itoa_s</div>
<div class="disabled">#define ITOW_S		_itow_s</div>
<div class="disabled">#define I64TOA_S	_i64toa_s</div>
<div class="disabled">#define I64TOW_S	_i64tow_s</div>
<div class="disabled">#define UITOA_S		_ui64toa_s</div>
<div class="disabled">#define UITOW_S		_ui64tow_s</div>
<div class="disabled">#define UI64TOA_S	_ui64toa_s</div>
<div class="disabled">#define UI64TOW_S	_ui64tow_s</div>
<div class="disabled">#if defined VCZH_MSVC</div>
<div class="disabled">#define INCRC(x)	(_InterlockedIncrement((volatile long*)(x)))</div>
<div class="disabled">#define DECRC(x)	(_InterlockedDecrement((volatile long*)(x)))</div>
<div class="disabled">#elif defined VCZH_GCC</div>
<div class="disabled">#define INCRC(x)	(__sync_add_and_fetch(x, 1))</div>
<div class="disabled">#define DECRC(x)	(__sync_sub_and_fetch(x, 1))</div>
<div class="disabled">#endif</div>
<div class="disabled">#endif</div>

<div class="disabled">	/***********************************************************************</div>
<div class="disabled">	Basic Types</div>
<div class="disabled">	***********************************************************************/</div>

<div class="disabled">	class NotCopyable</div>
<div class="disabled">	{</div>
<div class="disabled">	private:</div>
<div class="disabled">		NotCopyable(const NotCopyable&amp;);</div>
<div class="disabled">		NotCopyable&amp; operator=(const NotCopyable&amp;);</div>
<div class="disabled">	public:</div>
<div class="disabled">		NotCopyable();</div>
<div class="disabled">	};</div>

<div class="disabled">	/// &lt;summary&gt;Base type of all errors. An error is an exception that you are not allowed to catch. Raising it means there is a fatal error in the code.&lt;/summary&gt;</div>
<div class="disabled">	class Error</div>
<div class="disabled">	{</div>
<div class="disabled">	private:</div>
<div class="disabled">		const wchar_t*		description;</div>
<div class="disabled">	public:</div>
<div class="disabled">		Error(const wchar_t* _description);</div>

<div class="disabled">		const wchar_t*		Description()const;</div>
<div class="disabled">	};</div>

<div class="disabled">#if defined VCZH_MSVC || defined VCZH_GCC || defined _DEBUG</div>
<div class="disabled">#define CHECK_ERROR(CONDITION,DESCRIPTION) do{if(!(CONDITION))throw Error(DESCRIPTION);}while(0)</div>
<div class="disabled">#elif defined NDEBUG</div>
<div class="disabled">#define CHECK_ERROR(CONDITION,DESCRIPTION)</div>
<div class="disabled">#endif</div>

<div class="disabled">#define CHECK_FAIL(DESCRIPTION) do{throw Error(DESCRIPTION);}while(0)</div>

<div class="disabled">#define SCOPE_VARIABLE(TYPE, VARIABLE, VALUE)\</div>
<div class="disabled">	if(bool __scope_variable_flag__=true)\</div>
<div class="disabled">		for(TYPE VARIABLE = VALUE;__scope_variable_flag__;__scope_variable_flag__=false)</div>

<div class="disabled">	/***********************************************************************</div>
<div class="disabled">	Type Traits</div>
<div class="disabled">	***********************************************************************/</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveReference</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T			Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveReference&lt;T&amp;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T			Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveReference&lt;T&amp;&amp;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T			Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveConst</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T			Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveConst&lt;const T&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T			Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveVolatile</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T			Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveVolatile&lt;volatile T&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T			Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveCVR</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T								Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveCVR&lt;T&amp;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef typename RemoveCVR&lt;T&gt;::Type		Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveCVR&lt;T&amp;&amp;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef typename RemoveCVR&lt;T&gt;::Type		Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveCVR&lt;const T&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef typename RemoveCVR&lt;T&gt;::Type		Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct RemoveCVR&lt;volatile T&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef typename RemoveCVR&lt;T&gt;::Type		Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	typename RemoveReference&lt;T&gt;::Type&amp;&amp; MoveValue(T&amp;&amp; value)</div>
<div class="disabled">	{</div>
<div class="disabled">		return (typename RemoveReference&lt;T&gt;::Type&amp;&amp;)value;</div>
<div class="disabled">	}</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	T&amp;&amp; ForwardValue(typename RemoveReference&lt;T&gt;::Type&amp;&amp; value)</div>
<div class="disabled">	{</div>
<div class="disabled">		return (T&amp;&amp;)value;</div>
<div class="disabled">	}</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	T&amp;&amp; ForwardValue(typename RemoveReference&lt;T&gt;::Type&amp; value)</div>
<div class="disabled">	{</div>
<div class="disabled">		return (T&amp;&amp;)value;</div>
<div class="disabled">	}</div>

<div class="disabled">	template&lt;typename ...TArgs&gt;</div>
<div class="disabled">	struct TypeTuple</div>
<div class="disabled">	{</div>
<div class="disabled">	};</div>

<div class="disabled">	/***********************************************************************</div>
<div class="disabled">	Basic Types</div>
<div class="disabled">	***********************************************************************/</div>

<div class="disabled">	/// &lt;summary&gt;Base type of all classes.&lt;/summary&gt;</div>
<div class="disabled">	class Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		virtual ~Object();</div>
<div class="disabled">	};</div>

<div class="disabled">	/// &lt;summary&gt;Type for storing a value to wherever requiring a [T:vl.Ptr`1] to [T:vl.Object].&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;Type of the value.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	class ObjectBox : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	private:</div>
<div class="disabled">		T					object;</div>
<div class="disabled">	public:</div>
<div class="disabled">		/// &lt;summary&gt;Box a value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_object&quot;&gt;The value to box.&lt;/param&gt;</div>
<div class="disabled">		ObjectBox(const T&amp; _object)</div>
<div class="disabled">			:object(_object)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Box a movable value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_object&quot;&gt;The value to box.&lt;/param&gt;</div>
<div class="disabled">		ObjectBox(T&amp;&amp; _object)</div>
<div class="disabled">			:object(MoveValue(_object))</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy a box.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The box.&lt;/param&gt;</div>
<div class="disabled">		ObjectBox(const ObjectBox&lt;T&gt;&amp; value)</div>
<div class="disabled">			:object(value.object)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Move a box.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The box.&lt;/param&gt;</div>
<div class="disabled">		ObjectBox(ObjectBox&lt;T&gt;&amp;&amp; value)</div>
<div class="disabled">			:object(MoveValue(value.object))</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Box a value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The boxed value.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_object&quot;&gt;The value to box.&lt;/param&gt;</div>
<div class="disabled">		ObjectBox&lt;T&gt;&amp; operator=(const T&amp; _object)</div>
<div class="disabled">		{</div>
<div class="disabled">			object = _object;</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy a box.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The boxed value.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The box.&lt;/param&gt;</div>
<div class="disabled">		ObjectBox&lt;T&gt;&amp; operator=(const ObjectBox&lt;T&gt;&amp; value)</div>
<div class="disabled">		{</div>
<div class="disabled">			object = value.object;</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Move a box.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The boxed value.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The box.&lt;/param&gt;</div>
<div class="disabled">		ObjectBox&lt;T&gt;&amp; operator=(ObjectBox&lt;T&gt;&amp;&amp; value)</div>
<div class="disabled">		{</div>
<div class="disabled">			object = MoveValue(value.object);</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Unbox the value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The original value.&lt;/returns&gt;</div>
<div class="disabled">		const T&amp; Unbox()</div>
<div class="disabled">		{</div>
<div class="disabled">			return object;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">	/// &lt;summary&gt;Type for optionally storing a value.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;Type of the value.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	class Nullable</div>
<div class="disabled">	{</div>
<div class="disabled">	private:</div>
<div class="disabled">		T*					object;</div>
<div class="disabled">	public:</div>
<div class="disabled">		/// &lt;summary&gt;Create a null value.&lt;/summary&gt;</div>
<div class="disabled">		Nullable()</div>
<div class="disabled">			:object(0)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create a non-null value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The value to copy.&lt;/param&gt;</div>
<div class="disabled">		Nullable(const T&amp; value)</div>
<div class="disabled">			:object(new T(value))</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create a non-null value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The value to move.&lt;/param&gt;</div>
<div class="disabled">		Nullable(T&amp;&amp; value)</div>
<div class="disabled">			:object(new T(MoveValue(value)))</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy a nullable value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;nullable&quot;&gt;The nullable value to copy.&lt;/param&gt;</div>
<div class="disabled">		Nullable(const Nullable&lt;T&gt;&amp; nullable)</div>
<div class="disabled">			:object(nullable.object ? new T(*nullable.object) : 0)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Move a nullable value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;nullable&quot;&gt;The nullable value to move.&lt;/param&gt;</div>
<div class="disabled">		Nullable(Nullable&lt;T&gt;&amp;&amp; nullable)</div>
<div class="disabled">			:object(nullable.object)</div>
<div class="disabled">		{</div>
<div class="disabled">			nullable.object = 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		~Nullable()</div>
<div class="disabled">		{</div>
<div class="disabled">			if (object)</div>
<div class="disabled">			{</div>
<div class="disabled">				delete object;</div>
<div class="disabled">				object = 0;</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create a non-null value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The created nullable value.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The value to copy.&lt;/param&gt;</div>
<div class="disabled">		Nullable&lt;T&gt;&amp; operator=(const T&amp; value)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (object)</div>
<div class="disabled">			{</div>
<div class="disabled">				delete object;</div>
<div class="disabled">				object = 0;</div>
<div class="disabled">			}</div>
<div class="disabled">			object = new T(value);</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy a nullable value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The created nullable value.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;nullable&quot;&gt;The nullable value to copy.&lt;/param&gt;</div>
<div class="disabled">		Nullable&lt;T&gt;&amp; operator=(const Nullable&lt;T&gt;&amp; nullable)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (this != &amp;nullable)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (object)</div>
<div class="disabled">				{</div>
<div class="disabled">					delete object;</div>
<div class="disabled">					object = 0;</div>
<div class="disabled">				}</div>
<div class="disabled">				if (nullable.object)</div>
<div class="disabled">				{</div>
<div class="disabled">					object = new T(*nullable.object);</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Move a nullable value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The created nullable value.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;nullable&quot;&gt;The nullable value to move.&lt;/param&gt;</div>
<div class="disabled">		Nullable&lt;T&gt;&amp; operator=(Nullable&lt;T&gt;&amp;&amp; nullable)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (this != &amp;nullable)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (object)</div>
<div class="disabled">				{</div>
<div class="disabled">					delete object;</div>
<div class="disabled">					object = 0;</div>
<div class="disabled">				}</div>
<div class="disabled">				object = nullable.object;</div>
<div class="disabled">				nullable.object = 0;</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		static bool Equals(const Nullable&lt;T&gt;&amp; a, const Nullable&lt;T&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			return</div>
<div class="disabled">				a.object</div>
<div class="disabled">				? b.object</div>
<div class="disabled">				? *a.object == *b.object</div>
<div class="disabled">				: false</div>
<div class="disabled">				: b.object</div>
<div class="disabled">				? false</div>
<div class="disabled">				: true;</div>
<div class="disabled">		}</div>

<div class="disabled">		static vint Compare(const Nullable&lt;T&gt;&amp; a, const Nullable&lt;T&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			return</div>
<div class="disabled">				a.object</div>
<div class="disabled">				? b.object</div>
<div class="disabled">				? (*a.object == *b.object ? 0 : *a.object &lt; *b.object ? -1 : 1)</div>
<div class="disabled">				: 1</div>
<div class="disabled">				: b.object</div>
<div class="disabled">				? -1</div>
<div class="disabled">				: 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator==(const Nullable&lt;T&gt;&amp; nullable)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Equals(*this, nullable);</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator!=(const Nullable&lt;T&gt;&amp; nullable)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return !Equals(*this, nullable);</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;(const Nullable&lt;T&gt;&amp; nullable)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, nullable) &lt; 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;=(const Nullable&lt;T&gt;&amp; nullable)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, nullable) &lt;= 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;(const Nullable&lt;T&gt;&amp; nullable)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, nullable) &gt; 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;=(const Nullable&lt;T&gt;&amp; nullable)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, nullable) &gt;= 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Convert the nullable value to a bool value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;Returns true if it is not null.&lt;/returns&gt;</div>
<div class="disabled">		operator bool()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return object != 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Unbox the value. This operation will cause an access violation of it is null.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The original value.&lt;/returns&gt;</div>
<div class="disabled">		const T&amp; Value()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return *object;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T, size_t minSize&gt;</div>
<div class="disabled">	union BinaryRetriver</div>
<div class="disabled">	{</div>
<div class="disabled">		T t;</div>
<div class="disabled">		char binary[sizeof(T) &gt; minSize ? sizeof(T) : minSize];</div>
<div class="disabled">	};</div>

<div class="disabled">	/***********************************************************************</div>
<div class="disabled">	Type Traits</div>
<div class="disabled">	***********************************************************************/</div>

<div class="disabled">	/// &lt;summary&gt;Get the index type of a value for containers.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;Type of the value.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct KeyType</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		/// &lt;summary&gt;The index type of a value for containers.&lt;/summary&gt;</div>
<div class="disabled">		typedef T Type;</div>

<div class="disabled">		/// &lt;summary&gt;Convert a value to its index type.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The corresponding index value.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;</div>
<div class="disabled">		static const T&amp; GetKeyValue(const T&amp; value)</div>
<div class="disabled">		{</div>
<div class="disabled">			return value;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">	/// &lt;summary&gt;Test is a type a Plain-Old-Data type for containers.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;The type to test.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct POD</div>
<div class="disabled">	{</div>
<div class="disabled">		/// &lt;summary&gt;Returns true if the type is a Plain-Old-Data type.&lt;/summary&gt;</div>
<div class="disabled">		static const bool Result = false;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;&gt;struct POD&lt;bool&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;vint8_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;vuint8_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;vint16_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;vuint16_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;vint32_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;vuint32_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;vint64_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;vuint64_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;char&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;&gt;struct POD&lt;wchar_t&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;typename T&gt;struct POD&lt;T*&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;typename T&gt;struct POD&lt;T&amp;&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;typename T&gt;struct POD&lt;T&amp;&amp;&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;typename T, typename C&gt;struct POD&lt;T C::*&gt; { static const bool Result = true; };</div>
<div class="disabled">	template&lt;typename T, vint _Size&gt;struct POD&lt;T[_Size]&gt; { static const bool Result = POD&lt;T&gt;::Result; };</div>
<div class="disabled">	template&lt;typename T&gt;struct POD&lt;const T&gt; { static const bool Result = POD&lt;T&gt;::Result; };</div>
<div class="disabled">	template&lt;typename T&gt;struct POD&lt;volatile T&gt; { static const bool Result = POD&lt;T&gt;::Result; };</div>
<div class="disabled">	template&lt;typename T&gt;struct POD&lt;const volatile T&gt; { static const bool Result = POD&lt;T&gt;::Result; };</div>

<div class="disabled">	/***********************************************************************</div>
<div class="disabled">	Date and Time</div>
<div class="disabled">	***********************************************************************/</div>

<div class="disabled">	/// &lt;summary&gt;A type representing the combination of date and time.&lt;/summary&gt;</div>
<div class="disabled">	struct DateTime</div>
<div class="disabled">	{</div>
<div class="disabled">		vint				year;</div>
<div class="disabled">		vint				month;</div>
<div class="disabled">		vint				dayOfWeek;</div>
<div class="disabled">		vint				day;</div>
<div class="disabled">		vint				hour;</div>
<div class="disabled">		vint				minute;</div>
<div class="disabled">		vint				second;</div>
<div class="disabled">		vint				milliseconds;</div>

<div class="disabled">		vuint64_t			totalMilliseconds;</div>

<div class="disabled">		// in gcc, this will be mktime(t) * 1000 + gettimeofday().tv_usec / 1000</div>
<div class="disabled">		vuint64_t			filetime;</div>

<div class="disabled">		/// &lt;summary&gt;Get the current local time.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The current local time.&lt;/returns&gt;</div>
<div class="disabled">		static DateTime		LocalTime();</div>

<div class="disabled">		/// &lt;summary&gt;Get the current UTC time.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The current UTC time.&lt;/returns&gt;</div>
<div class="disabled">		static DateTime		UtcTime();</div>

<div class="disabled">		/// &lt;summary&gt;Create a date time value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The created date time value.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_year&quot;&gt;The year.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_month&quot;&gt;The month.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_day&quot;&gt;The day.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_hour&quot;&gt;The hour.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_minute&quot;&gt;The minute.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_second&quot;&gt;The second.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_milliseconds&quot;&gt;The millisecond.&lt;/param&gt;</div>
<div class="disabled">		static DateTime		FromDateTime(vint _year, vint _month, vint _day, vint _hour = 0, vint _minute = 0, vint _second = 0, vint _milliseconds = 0);</div>

<div class="disabled">		static DateTime		FromFileTime(vuint64_t filetime);</div>

<div class="disabled">		/// &lt;summary&gt;Create an empty date time value.&lt;/summary&gt;</div>
<div class="disabled">		DateTime();</div>

<div class="disabled">		/// &lt;summary&gt;Convert the UTC time to the local time.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The UTC time.&lt;/returns&gt;</div>
<div class="disabled">		DateTime			ToLocalTime();</div>
<div class="disabled">		/// &lt;summary&gt;Convert the local time to the UTC time.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The local time.&lt;/returns&gt;</div>
<div class="disabled">		DateTime			ToUtcTime();</div>
<div class="disabled">		/// &lt;summary&gt;Move forward.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The moved time.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;milliseconds&quot;&gt;The delta in milliseconds.&lt;/param&gt;</div>
<div class="disabled">		DateTime			Forward(vuint64_t milliseconds);</div>
<div class="disabled">		/// &lt;summary&gt;Move Backward.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The moved time.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;milliseconds&quot;&gt;The delta in milliseconds.&lt;/param&gt;</div>
<div class="disabled">		DateTime			Backward(vuint64_t milliseconds);</div>

<div class="disabled">		bool operator==(const DateTime&amp; value)const { return filetime == value.filetime; }</div>
<div class="disabled">		bool operator!=(const DateTime&amp; value)const { return filetime != value.filetime; }</div>
<div class="disabled">		bool operator&lt;(const DateTime&amp; value)const { return filetime &lt; value.filetime; }</div>
<div class="disabled">		bool operator&lt;=(const DateTime&amp; value)const { return filetime &lt;= value.filetime; }</div>
<div class="disabled">		bool operator&gt;(const DateTime&amp; value)const { return filetime &gt; value.filetime; }</div>
<div class="disabled">		bool operator&gt;=(const DateTime&amp; value)const { return filetime &gt;= value.filetime; }</div>
<div class="disabled">	};</div>

<div class="disabled">	/***********************************************************************</div>
<div class="disabled">	Interface</div>
<div class="disabled">	***********************************************************************/</div>

<div class="disabled">	/// &lt;summary&gt;Base type of all interfaces. All interface types are encouraged to be virtual inherited.&lt;/summary&gt;</div>
<div class="disabled">	class Interface : private NotCopyable</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		virtual ~Interface();</div>
<div class="disabled">	};</div>

<div class="disabled">	/***********************************************************************</div>
<div class="disabled">	Type Traits</div>
<div class="disabled">	***********************************************************************/</div>

<div class="disabled">	struct YesType {};</div>
<div class="disabled">	struct NoType {};</div>

<div class="disabled">	template&lt;typename T, typename YesOrNo&gt;</div>
<div class="disabled">	struct AcceptType</div>
<div class="disabled">	{</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct AcceptType&lt;T, YesType&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T1, typename T2&gt;</div>
<div class="disabled">	struct YesNoAnd</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef NoType Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;&gt;</div>
<div class="disabled">	struct YesNoAnd&lt;YesType, YesType&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef YesType Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T1, typename T2&gt;</div>
<div class="disabled">	struct YesNoOr</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef YesType Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;&gt;</div>
<div class="disabled">	struct YesNoOr&lt;NoType, NoType&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef NoType Type;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename YesOrNo&gt;</div>
<div class="disabled">	struct AcceptValue</div>
<div class="disabled">	{</div>
<div class="disabled">		static const bool Result = false;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;&gt;</div>
<div class="disabled">	struct AcceptValue&lt;YesType&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		static const bool Result = true;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	T ValueOf();</div>

<div class="disabled">	template&lt;typename TFrom, typename TTo&gt;</div>
<div class="disabled">	struct PointerConvertable</div>
<div class="disabled">	{</div>
<div class="disabled">		static YesType Test(TTo* value);</div>
<div class="disabled">		static NoType Test(void* value);</div>

<div class="disabled">		typedef decltype(Test(ValueOf&lt;TFrom*&gt;())) YesNoType;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename TFrom, typename TTo&gt;</div>
<div class="disabled">	struct ReturnConvertable</div>
<div class="disabled">	{</div>
<div class="disabled">		static YesType Test(TTo&amp;&amp; value);</div>
<div class="disabled">		static NoType Test(...);</div>

<div class="disabled">		typedef decltype(Test(ValueOf&lt;TFrom&amp;&amp;&gt;())) YesNoType;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename TFrom&gt;</div>
<div class="disabled">	struct ReturnConvertable&lt;TFrom, void&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef YesType YesNoType;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename TTo&gt;</div>
<div class="disabled">	struct ReturnConvertable&lt;void, TTo&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef NoType YesNoType;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;&gt;</div>
<div class="disabled">	struct ReturnConvertable&lt;void, void&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef YesType YesNoType;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T, typename U&gt;</div>
<div class="disabled">	struct AcceptAlways</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T Type;</div>
<div class="disabled">	};</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\STRING.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::String

Classes:
	AString										: Mbcs using the code page of the current locale
	WString										: UTF-16 (for Windows), or UTF-32 (for Linux and macOS)
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_STRING</div>
<div class="disabled">#define VCZH_STRING</div>

<div class="disabled">#include &lt;memory.h&gt;</div>

<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	/// &lt;summary&gt;A type representing a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;Type of a character.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	class ObjectString : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	private:</div>
<div class="disabled">		static const T				zero;</div>

<div class="disabled">		mutable T*					buffer;</div>
<div class="disabled">		mutable volatile vint*		counter;</div>
<div class="disabled">		mutable vint				start;</div>
<div class="disabled">		mutable vint				length;</div>
<div class="disabled">		mutable vint				realLength;</div>

<div class="disabled">		static vint CalculateLength(const T* buffer)</div>
<div class="disabled">		{</div>
<div class="disabled">			vint result=0;</div>
<div class="disabled">			while(*buffer++)result++;</div>
<div class="disabled">			return result;</div>
<div class="disabled">		}</div>

<div class="disabled">		static vint Compare(const T* bufA, const ObjectString&lt;T&gt;&amp; strB)</div>
<div class="disabled">		{</div>
<div class="disabled">			const T* bufB=strB.buffer+strB.start;</div>
<div class="disabled">			const T* bufAOld=bufA;</div>
<div class="disabled">			vint length=strB.length;</div>
<div class="disabled">			while(length-- &amp;&amp; *bufA)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint diff=*bufA++-*bufB++;</div>
<div class="disabled">				if(diff!=0)</div>
<div class="disabled">				{</div>
<div class="disabled">					return diff;</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">			return CalculateLength(bufAOld)-strB.length;</div>
<div class="disabled">		}</div>

<div class="disabled">	public:</div>

<div class="disabled">		static vint Compare(const ObjectString&lt;T&gt;&amp; strA, const ObjectString&lt;T&gt;&amp; strB)</div>
<div class="disabled">		{</div>
<div class="disabled">			const T* bufA=strA.buffer+strA.start;</div>
<div class="disabled">			const T* bufB=strB.buffer+strB.start;</div>
<div class="disabled">			vint length=strA.length&lt;strB.length?strA.length:strB.length;</div>
<div class="disabled">			while(length--)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint diff=*bufA++-*bufB++;</div>
<div class="disabled">				if(diff!=0)</div>
<div class="disabled">				{</div>
<div class="disabled">					return diff;</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">			return strA.length-strB.length;</div>
<div class="disabled">		}</div>

<div class="disabled">	private:</div>

<div class="disabled">		void Inc()const</div>
<div class="disabled">		{</div>
<div class="disabled">			if(counter)</div>
<div class="disabled">			{</div>
<div class="disabled">				INCRC(counter);</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		void Dec()const</div>
<div class="disabled">		{</div>
<div class="disabled">			if(counter)</div>
<div class="disabled">			{</div>
<div class="disabled">				if(DECRC(counter)==0)</div>
<div class="disabled">				{</div>
<div class="disabled">					delete[] buffer;</div>
<div class="disabled">					delete counter;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		ObjectString(const ObjectString&lt;T&gt;&amp; string, vint _start, vint _length)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(_length&lt;=0)</div>
<div class="disabled">			{</div>
<div class="disabled">				buffer=(T*)&amp;zero;</div>
<div class="disabled">				counter=0;</div>
<div class="disabled">				start=0;</div>
<div class="disabled">				length=0;</div>
<div class="disabled">				realLength=0;</div>
<div class="disabled">			}</div>
<div class="disabled">			else</div>
<div class="disabled">			{</div>
<div class="disabled">				buffer=string.buffer;</div>
<div class="disabled">				counter=string.counter;</div>
<div class="disabled">				start=string.start+_start;</div>
<div class="disabled">				length=_length;</div>
<div class="disabled">				realLength=string.realLength;</div>
<div class="disabled">				Inc();</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		ObjectString(const ObjectString&lt;T&gt;&amp; dest, const ObjectString&lt;T&gt;&amp; source, vint index, vint count)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(index==0 &amp;&amp; count==dest.length &amp;&amp; source.length==0)</div>
<div class="disabled">			{</div>
<div class="disabled">				buffer=(T*)&amp;zero;</div>
<div class="disabled">				counter=0;</div>
<div class="disabled">				start=0;</div>
<div class="disabled">				length=0;</div>
<div class="disabled">				realLength=0;</div>
<div class="disabled">			}</div>
<div class="disabled">			else</div>
<div class="disabled">			{</div>
<div class="disabled">				counter=new vint(1);</div>
<div class="disabled">				start=0;</div>
<div class="disabled">				length=dest.length-count+source.length;</div>
<div class="disabled">				realLength=length;</div>
<div class="disabled">				buffer=new T[length+1];</div>
<div class="disabled">				memcpy(buffer, dest.buffer+dest.start, sizeof(T)*index);</div>
<div class="disabled">				memcpy(buffer+index, source.buffer+source.start, sizeof(T)*source.length);</div>
<div class="disabled">				memcpy(buffer+index+source.length, (dest.buffer+dest.start+index+count), sizeof(T)*(dest.length-index-count));</div>
<div class="disabled">				buffer[length]=0;</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>
<div class="disabled">	public:</div>
<div class="disabled">		static ObjectString&lt;T&gt;	Empty;</div>

<div class="disabled">		/// &lt;summary&gt;Create an empty string.&lt;/summary&gt;</div>
<div class="disabled">		ObjectString()</div>
<div class="disabled">		{</div>
<div class="disabled">			buffer=(T*)&amp;zero;</div>
<div class="disabled">			counter=0;</div>
<div class="disabled">			start=0;</div>
<div class="disabled">			length=0;</div>
<div class="disabled">			realLength=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create a string continaing one character.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_char&quot;&gt;The character.&lt;/param&gt;</div>
<div class="disabled">		ObjectString(const T&amp; _char)</div>
<div class="disabled">		{</div>
<div class="disabled">			counter=new vint(1);</div>
<div class="disabled">			start=0;</div>
<div class="disabled">			length=1;</div>
<div class="disabled">			buffer=new T[2];</div>
<div class="disabled">			buffer[0]=_char;</div>
<div class="disabled">			buffer[1]=0;</div>
<div class="disabled">			realLength=length;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy a string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_buffer&quot;&gt;Memory to copy. It does not have to contain the zero terminator.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_length&quot;&gt;Size of the content in characters.&lt;/param&gt;</div>
<div class="disabled">		ObjectString(const T* _buffer, vint _length)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(_length&lt;=0)</div>
<div class="disabled">			{</div>
<div class="disabled">				buffer=(T*)&amp;zero;</div>
<div class="disabled">				counter=0;</div>
<div class="disabled">				start=0;</div>
<div class="disabled">				length=0;</div>
<div class="disabled">				realLength=0;</div>
<div class="disabled">			}</div>
<div class="disabled">			else</div>
<div class="disabled">			{</div>
<div class="disabled">				buffer=new T[_length+1];</div>
<div class="disabled">				memcpy(buffer, _buffer, _length*sizeof(T));</div>
<div class="disabled">				buffer[_length]=0;</div>
<div class="disabled">				counter=new vint(1);</div>
<div class="disabled">				start=0;</div>
<div class="disabled">				length=_length;</div>
<div class="disabled">				realLength=_length;</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Copy a string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;_buffer&quot;&gt;Memory to copy. It should have to contain the zero terminator.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;copy&quot;&gt;Set to true to copy the memory. Set to false to use the memory directly.&lt;/param&gt;</div>
<div class="disabled">		ObjectString(const T* _buffer, bool copy = true)</div>
<div class="disabled">		{</div>
<div class="disabled">			CHECK_ERROR(_buffer!=0, L&quot;ObjectString&lt;T&gt;::ObjectString(const T*, bool)#Cannot construct a string from nullptr.&quot;);</div>
<div class="disabled">			if(copy)</div>
<div class="disabled">			{</div>
<div class="disabled">				counter=new vint(1);</div>
<div class="disabled">				start=0;</div>
<div class="disabled">				length=CalculateLength(_buffer);</div>
<div class="disabled">				buffer=new T[length+1];</div>
<div class="disabled">				memcpy(buffer, _buffer, sizeof(T)*(length+1));</div>
<div class="disabled">				realLength=length;</div>
<div class="disabled">			}</div>
<div class="disabled">			else</div>
<div class="disabled">			{</div>
<div class="disabled">				buffer=(T*)_buffer;</div>
<div class="disabled">				counter=0;</div>
<div class="disabled">				start=0;</div>
<div class="disabled">				length=CalculateLength(_buffer);</div>
<div class="disabled">				realLength=length;</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Copy a string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;string&quot;&gt;The string to copy.&lt;/param&gt;</div>
<div class="disabled">		ObjectString(const ObjectString&lt;T&gt;&amp; string)</div>
<div class="disabled">		{</div>
<div class="disabled">			buffer=string.buffer;</div>
<div class="disabled">			counter=string.counter;</div>
<div class="disabled">			start=string.start;</div>
<div class="disabled">			length=string.length;</div>
<div class="disabled">			realLength=string.realLength;</div>
<div class="disabled">			Inc();</div>
<div class="disabled">		}</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Move a string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;string&quot;&gt;The string to move.&lt;/param&gt;</div>
<div class="disabled">		ObjectString(ObjectString&lt;T&gt;&amp;&amp; string)</div>
<div class="disabled">		{</div>
<div class="disabled">			buffer=string.buffer;</div>
<div class="disabled">			counter=string.counter;</div>
<div class="disabled">			start=string.start;</div>
<div class="disabled">			length=string.length;</div>
<div class="disabled">			realLength=string.realLength;</div>
<div class="disabled">			</div>
<div class="disabled">			string.buffer=(T*)&amp;zero;</div>
<div class="disabled">			string.counter=0;</div>
<div class="disabled">			string.start=0;</div>
<div class="disabled">			string.length=0;</div>
<div class="disabled">			string.realLength=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		~ObjectString()</div>
<div class="disabled">		{</div>
<div class="disabled">			Dec();</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Get the zero-terminated buffer in the string. Copying parts of a string does not necessarily create a new buffer, so in some situation the string will not actually points to a zero-terminated buffer. In this case, this function will copy the content to a new buffer with a zero terminator and return.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;Returns the buffer.&lt;/returns&gt;</div>
<div class="disabled">		const T* Buffer()const</div>
<div class="disabled">		{</div>
<div class="disabled">			if(start+length!=realLength)</div>
<div class="disabled">			{</div>
<div class="disabled">				T* newBuffer=new T[length+1];</div>
<div class="disabled">				memcpy(newBuffer, buffer+start, sizeof(T)*length);</div>
<div class="disabled">				newBuffer[length]=0;</div>
<div class="disabled">				Dec();</div>
<div class="disabled">				buffer=newBuffer;</div>
<div class="disabled">				counter=new vint(1);</div>
<div class="disabled">				start=0;</div>
<div class="disabled">				realLength=length;</div>
<div class="disabled">			}</div>
<div class="disabled">			return buffer+start;</div>
<div class="disabled">		}</div>

<div class="disabled">		ObjectString&lt;T&gt;&amp; operator=(const ObjectString&lt;T&gt;&amp; string)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(this!=&amp;string)</div>
<div class="disabled">			{</div>
<div class="disabled">				Dec();</div>
<div class="disabled">				buffer=string.buffer;</div>
<div class="disabled">				counter=string.counter;</div>
<div class="disabled">				start=string.start;</div>
<div class="disabled">				length=string.length;</div>
<div class="disabled">				realLength=string.realLength;</div>
<div class="disabled">				Inc();</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		ObjectString&lt;T&gt;&amp; operator=(ObjectString&lt;T&gt;&amp;&amp; string)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(this!=&amp;string)</div>
<div class="disabled">			{</div>
<div class="disabled">				Dec();</div>
<div class="disabled">				buffer=string.buffer;</div>
<div class="disabled">				counter=string.counter;</div>
<div class="disabled">				start=string.start;</div>
<div class="disabled">				length=string.length;</div>
<div class="disabled">				realLength=string.realLength;</div>
<div class="disabled">			</div>
<div class="disabled">				string.buffer=(T*)&amp;zero;</div>
<div class="disabled">				string.counter=0;</div>
<div class="disabled">				string.start=0;</div>
<div class="disabled">				string.length=0;</div>
<div class="disabled">				string.realLength=0;</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		ObjectString&lt;T&gt;&amp; operator+=(const ObjectString&lt;T&gt;&amp; string)</div>
<div class="disabled">		{</div>
<div class="disabled">			return *this=*this+string;</div>
<div class="disabled">		}</div>

<div class="disabled">		ObjectString&lt;T&gt; operator+(const ObjectString&lt;T&gt;&amp; string)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return ObjectString&lt;T&gt;(*this, string, length, 0);</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator==(const ObjectString&lt;T&gt;&amp; string)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, string)==0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator!=(const ObjectString&lt;T&gt;&amp; string)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, string)!=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;(const ObjectString&lt;T&gt;&amp; string)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, string)&gt;0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;=(const ObjectString&lt;T&gt;&amp; string)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, string)&gt;=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;(const ObjectString&lt;T&gt;&amp; string)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, string)&lt;0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;=(const ObjectString&lt;T&gt;&amp; string)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(*this, string)&lt;=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator==(const T* buffer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(buffer, *this)==0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator!=(const T* buffer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(buffer, *this)!=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;(const T* buffer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(buffer, *this)&lt;0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;=(const T* buffer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(buffer, *this)&lt;=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;(const T* buffer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(buffer, *this)&gt;0;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;=(const T* buffer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(buffer, *this)&gt;=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		T operator[](vint index)const</div>
<div class="disabled">		{</div>
<div class="disabled">			CHECK_ERROR(index&gt;=0 &amp;&amp; index&lt;length, L&quot;ObjectString:&lt;T&gt;:operator[](vint)#Argument index not in range.&quot;);</div>
<div class="disabled">			return buffer[start+index];</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Get the size of the string in characters.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The size.&lt;/returns&gt;</div>
<div class="disabled">		vint Length()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return length;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Find a character.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The position of the character. Returns -1 if it doesn not exist.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;c&quot;&gt;The character to find.&lt;/param&gt;</div>
<div class="disabled">		vint IndexOf(T c)const</div>
<div class="disabled">		{</div>
<div class="disabled">			const T* reading=buffer+start;</div>
<div class="disabled">			for(vint i=0;i&lt;length;i++)</div>
<div class="disabled">			{</div>
<div class="disabled">				if(reading[i]==c)</div>
<div class="disabled">					return i;</div>
<div class="disabled">			}</div>
<div class="disabled">			return -1;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy the beginning of the string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The copied string.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;count&quot;&gt;Size of characters to copy.&lt;/param&gt;</div>
<div class="disabled">		ObjectString&lt;T&gt; Left(vint count)const</div>
<div class="disabled">		{</div>
<div class="disabled">			CHECK_ERROR(count&gt;=0 &amp;&amp; count&lt;=length, L&quot;ObjectString&lt;T&gt;::Left(vint)#Argument count not in range.&quot;);</div>
<div class="disabled">			return ObjectString&lt;T&gt;(*this, 0, count);</div>
<div class="disabled">		}</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Copy the ending of the string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The copied string.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;count&quot;&gt;Size of characters to copy.&lt;/param&gt;</div>
<div class="disabled">		ObjectString&lt;T&gt; Right(vint count)const</div>
<div class="disabled">		{</div>
<div class="disabled">			CHECK_ERROR(count&gt;=0 &amp;&amp; count&lt;=length, L&quot;ObjectString&lt;T&gt;::Right(vint)#Argument count not in range.&quot;);</div>
<div class="disabled">			return ObjectString&lt;T&gt;(*this, length-count, count);</div>
<div class="disabled">		}</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Copy the middle of the string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The copied string.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;index&quot;&gt;Position of characters to copy.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;count&quot;&gt;Size of characters to copy.&lt;/param&gt;</div>
<div class="disabled">		ObjectString&lt;T&gt; Sub(vint index, vint count)const</div>
<div class="disabled">		{</div>
<div class="disabled">			CHECK_ERROR(index&gt;=0 &amp;&amp; index&lt;=length, L&quot;ObjectString&lt;T&gt;::Sub(vint, vint)#Argument index not in range.&quot;);</div>
<div class="disabled">			CHECK_ERROR(index+count&gt;=0 &amp;&amp; index+count&lt;=length, L&quot;ObjectString&lt;T&gt;::Sub(vint, vint)#Argument count not in range.&quot;);</div>
<div class="disabled">			return ObjectString&lt;T&gt;(*this, index, count);</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy the beginning and the end of the string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The copied string.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;index&quot;&gt;Position of characters NOT to copy.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;count&quot;&gt;Size of characters NOT to copy.&lt;/param&gt;</div>
<div class="disabled">		ObjectString&lt;T&gt; Remove(vint index, vint count)const</div>
<div class="disabled">		{</div>
<div class="disabled">			CHECK_ERROR(index&gt;=0 &amp;&amp; index&lt;length, L&quot;ObjectString&lt;T&gt;::Remove(vint, vint)#Argument index not in range.&quot;);</div>
<div class="disabled">			CHECK_ERROR(index+count&gt;=0 &amp;&amp; index+count&lt;=length, L&quot;ObjectString&lt;T&gt;::Remove(vint, vint)#Argument count not in range.&quot;);</div>
<div class="disabled">			return ObjectString&lt;T&gt;(*this, ObjectString&lt;T&gt;(), index, count);</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Make a new string by inserting a string in this string.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The copied string.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;index&quot;&gt;Position of characters to insert.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;string&quot;&gt;The string to be inserted in this string.&lt;/param&gt;</div>
<div class="disabled">		ObjectString&lt;T&gt; Insert(vint index, const ObjectString&lt;T&gt;&amp; string)const</div>
<div class="disabled">		{</div>
<div class="disabled">			CHECK_ERROR(index&gt;=0 &amp;&amp; index&lt;=length, L&quot;ObjectString&lt;T&gt;::Insert(vint)#Argument count not in range.&quot;);</div>
<div class="disabled">			return ObjectString&lt;T&gt;(*this, string, index, 0);</div>
<div class="disabled">		}</div>

<div class="disabled">		friend bool operator&lt;(const T* left, const ObjectString&lt;T&gt;&amp; right)</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(left, right)&lt;0;</div>
<div class="disabled">		}</div>

<div class="disabled">		friend bool operator&lt;=(const T* left, const ObjectString&lt;T&gt;&amp; right)</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(left, right)&lt;=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		friend bool operator&gt;(const T* left, const ObjectString&lt;T&gt;&amp; right)</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(left, right)&gt;0;</div>
<div class="disabled">		}</div>

<div class="disabled">		friend bool operator&gt;=(const T* left, const ObjectString&lt;T&gt;&amp; right)</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(left, right)&gt;=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		friend bool operator==(const T* left, const ObjectString&lt;T&gt;&amp; right)</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(left, right)==0;</div>
<div class="disabled">		}</div>

<div class="disabled">		friend bool operator!=(const T* left, const ObjectString&lt;T&gt;&amp; right)</div>
<div class="disabled">		{</div>
<div class="disabled">			return Compare(left, right)!=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		friend ObjectString&lt;T&gt; operator+(const T* left, const ObjectString&lt;T&gt;&amp; right)</div>
<div class="disabled">		{</div>
<div class="disabled">			return ObjectString&lt;T&gt;(left, false)+right;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	ObjectString&lt;T&gt; ObjectString&lt;T&gt;::Empty=ObjectString&lt;T&gt;();</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	const T ObjectString&lt;T&gt;::zero=0;</div>

<div class="disabled">	/// &lt;summary&gt;Ansi string.&lt;/summary&gt;</div>
<div class="disabled">	typedef ObjectString&lt;char&gt;		AString;</div>
<div class="disabled">	/// &lt;summary&gt;Unicode string.&lt;/summary&gt;</div>
<div class="disabled">	typedef ObjectString&lt;wchar_t&gt;	WString;</div>

<div class="disabled">	/// &lt;summary&gt;Convert a string to an signed integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern vint					atoi_test(const AString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an signed integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern vint					wtoi_test(const WString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an signed 64-bits integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern vint64_t				atoi64_test(const AString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an signed 64-bits integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern vint64_t				wtoi64_test(const WString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern vuint				atou_test(const AString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern vuint				wtou_test(const WString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to a 64-bits unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern vuint64_t			atou64_test(const AString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to a 64-bits unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern vuint64_t			wtou64_test(const WString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to 64-bits floating point number.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern double				atof_test(const AString&amp; string, bool&amp; success);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to 64-bits floating point number.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;success&quot;&gt;Returns true if this operation succeeded.&lt;/param&gt;</div>
<div class="disabled">	extern double				wtof_test(const WString&amp; string, bool&amp; success);</div>

<div class="disabled">	/// &lt;summary&gt;Convert a string to an signed integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern vint					atoi(const AString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an signed integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern vint					wtoi(const WString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an signed 64-bits integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern vint64_t				atoi64(const AString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an signed 64-bits integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern vint64_t				wtoi64(const WString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern vuint				atou(const AString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to an unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern vuint				wtou(const WString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to a 64-bits unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern vuint64_t			atou64(const AString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to a 64-bits unsigned integer.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern vuint64_t			wtou64(const WString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to a 64-bits floating point number.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern double				atof(const AString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a string to a 64-bits floating point number.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted number. If the convert failed, the result is undefined.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern double				wtof(const WString&amp; string);</div>

<div class="disabled">	/// &lt;summary&gt;Convert a signed interger to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern AString				itoa(vint number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a signed interger to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern WString				itow(vint number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a 64-bits signed interger to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern AString				i64toa(vint64_t number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a 64-bits signed interger to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern WString				i64tow(vint64_t number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert an unsigned interger to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern AString				utoa(vuint number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert an unsigned interger to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern WString				utow(vuint number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a 64-bits unsigned interger to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern AString				u64toa(vuint64_t number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a 64-bits unsigned interger to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern WString				u64tow(vuint64_t number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a 64-bits floating pointer number to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern AString				ftoa(double number);</div>
<div class="disabled">	/// &lt;summary&gt;Convert a 64-bits floating pointer number to a string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;number&quot;&gt;The number to convert.&lt;/param&gt;</div>
<div class="disabled">	extern WString				ftow(double number);</div>

<div class="disabled">	extern vint					_wtoa(const wchar_t* w, char* a, vint chars);</div>
<div class="disabled">	/// &lt;summary&gt;Convert an Unicode string to an Ansi string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern AString				wtoa(const WString&amp; string);</div>
<div class="disabled">	extern vint					_atow(const char* a, wchar_t* w, vint chars);</div>
<div class="disabled">	/// &lt;summary&gt;Convert an Ansi string to an Unicode string.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern WString				atow(const AString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert all letters to lower case letters.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern AString				alower(const AString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert all letters to lower case letters.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern WString				wlower(const WString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert all letters to upper case letters.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern AString				aupper(const AString&amp; string);</div>
<div class="disabled">	/// &lt;summary&gt;Convert all letters to upper case letters.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The converted string.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;string&quot;&gt;The string to convert.&lt;/param&gt;</div>
<div class="disabled">	extern WString				wupper(const WString&amp; string);</div>

<div class="disabled">#if defined VCZH_GCC</div>
<div class="disabled">	extern void					_itoa_s(vint32_t value, char* buffer, size_t size, vint radix);</div>
<div class="disabled">	extern void					_itow_s(vint32_t value, wchar_t* buffer, size_t size, vint radix);</div>
<div class="disabled">	extern void					_i64toa_s(vint64_t value, char* buffer, size_t size, vint radix);</div>
<div class="disabled">	extern void					_i64tow_s(vint64_t value, wchar_t* buffer, size_t size, vint radix);</div>
<div class="disabled">	extern void					_uitoa_s(vuint32_t value, char* buffer, size_t size, vint radix);</div>
<div class="disabled">	extern void					_uitow_s(vuint32_t value, wchar_t* buffer, size_t size, vint radix);</div>
<div class="disabled">	extern void					_ui64toa_s(vuint64_t value, char* buffer, size_t size, vint radix);</div>
<div class="disabled">	extern void					_ui64tow_s(vuint64_t value, wchar_t* buffer, size_t size, vint radix);</div>
<div class="disabled">	extern void					_gcvt_s(char* buffer, size_t size, double value, vint numberOfDigits);</div>
<div class="disabled">	extern void					_strlwr_s(char* buffer, size_t size);</div>
<div class="disabled">	extern void					_strupr_s(char* buffer, size_t size);</div>
<div class="disabled">	extern void					_wcslwr_s(wchar_t* buffer, size_t size);</div>
<div class="disabled">	extern void					_wcsupr_s(wchar_t* buffer, size_t size);</div>
<div class="disabled">	extern void					wcscpy_s(wchar_t* buffer, size_t size, const wchar_t* text);</div>
<div class="disabled">#endif</div>

<div class="disabled">	enum class LoremIpsumCasing</div>
<div class="disabled">	{</div>
<div class="disabled">		AllWordsLowerCase,</div>
<div class="disabled">		FirstWordUpperCase,</div>
<div class="disabled">		AllWordsUpperCase,</div>
<div class="disabled">	};</div>

<div class="disabled">	extern WString				LoremIpsum(vint bestLength, LoremIpsumCasing casing);</div>
<div class="disabled">	extern WString				LoremIpsumTitle(vint bestLength);</div>
<div class="disabled">	extern WString				LoremIpsumSentence(vint bestLength);</div>
<div class="disabled">	extern WString				LoremIpsumParagraph(vint bestLength);</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\POINTER.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Smart Pointer

Classes:
	Ptr&lt;T&gt;							: Shared Pointer
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_POINTER</div>
<div class="disabled">#define VCZH_POINTER</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">ReferenceCounterOperator</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">	/// &lt;summary&gt;The strategy to get the pointer to the reference counter from an object. If you get the same pointer multiple times from the same object by calling [M:vl.ReferenceCounterOperator`2.CreateCounter], than it is safe to convert a object pointer to a [T:vl.Ptr`1]. Currently for reflectable C++ types which inherit from [T:vl.reflection.DescriptableObject] it is yet. For others it is no.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;The type of the object.&lt;/typeparam&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;Enabled&quot;&gt;[T:vl.Ptr`1] will always use [T:vl.YesType] as the second type parameter. This parameter is useful when you want to do partial specialization in the SFINAE way.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename T, typename Enabled=YesType&gt;</div>
<div class="disabled">	struct ReferenceCounterOperator</div>
<div class="disabled">	{</div>
<div class="disabled">		/// &lt;summary&gt;Create a pointer to the reference counter from an object.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The pointer to the reference counter.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;reference&quot;&gt;The object.&lt;/param&gt;</div>
<div class="disabled">		static __forceinline volatile vint* CreateCounter(T* reference)</div>
<div class="disabled">		{</div>
<div class="disabled">			return new vint(0);</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Destroy a pointer to the reference counter from an object.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;counter&quot;&gt;The pointer to the reference counter.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;reference&quot;&gt;The object.&lt;/param&gt;</div>
<div class="disabled">		static __forceinline void DeleteReference(volatile vint* counter, void* reference)</div>
<div class="disabled">		{</div>
<div class="disabled">			delete counter;</div>
<div class="disabled">			delete (T*)reference;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Ptr</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">	/// &lt;summary&gt;A smart pointer. It is always safe to convert a pointer to an object to a smart pointer once. If you do it multiple times, it may be wrong due to different implementation of [T:vl.ReferenceCounterOperator`2]. In case of wrong, disposing the smart pointer will cause an access violation.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;The type of the object.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	class Ptr</div>
<div class="disabled">	{</div>
<div class="disabled">		template&lt;typename X&gt;</div>
<div class="disabled">		friend class Ptr;</div>
<div class="disabled">	protected:</div>
<div class="disabled">		typedef void(*Destructor)(volatile vint*, void*);</div>

<div class="disabled">		volatile vint*		counter = nullptr;</div>
<div class="disabled">		T*					reference = nullptr;</div>
<div class="disabled">		void*				originalReference = nullptr;</div>
<div class="disabled">		Destructor			originalDestructor = nullptr;</div>

<div class="disabled">		void SetEmptyNoIncDec()</div>
<div class="disabled">		{</div>
<div class="disabled">			counter = nullptr;</div>
<div class="disabled">			reference = nullptr;</div>
<div class="disabled">			originalReference = nullptr;</div>
<div class="disabled">			originalDestructor = nullptr;</div>
<div class="disabled">		}</div>

<div class="disabled">		void Inc()</div>
<div class="disabled">		{</div>
<div class="disabled">			if (counter)</div>
<div class="disabled">			{</div>
<div class="disabled">				INCRC(counter);</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		void Dec(bool deleteIfZero = true)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (counter)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (DECRC(counter) == 0)</div>
<div class="disabled">				{</div>
<div class="disabled">					if (deleteIfZero)</div>
<div class="disabled">					{</div>
<div class="disabled">						originalDestructor(counter, originalReference);</div>
<div class="disabled">					}</div>
<div class="disabled">					SetEmptyNoIncDec();</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		volatile vint* Counter()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return counter;</div>
<div class="disabled">		}</div>

<div class="disabled">		Ptr(volatile vint* _counter, T* _reference, void* _originalReference, Destructor _originalDestructor)</div>
<div class="disabled">			:counter(_counter)</div>
<div class="disabled">			, reference(_reference)</div>
<div class="disabled">			, originalReference(_originalReference)</div>
<div class="disabled">			, originalDestructor(_originalDestructor)</div>
<div class="disabled">		{</div>
<div class="disabled">			Inc();</div>
<div class="disabled">		}</div>
<div class="disabled">	public:</div>

<div class="disabled">		/// &lt;summary&gt;Create a null pointer.&lt;/summary&gt;</div>
<div class="disabled">		Ptr()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Convert a pointer to an object to a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;pointer&quot;&gt;The pointer to the object.&lt;/param&gt;</div>
<div class="disabled">		Ptr(T* pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (pointer)</div>
<div class="disabled">			{</div>
<div class="disabled">				counter = ReferenceCounterOperator&lt;T&gt;::CreateCounter(pointer);</div>
<div class="disabled">				reference = pointer;</div>
<div class="disabled">				originalReference = pointer;</div>
<div class="disabled">				originalDestructor = &amp;ReferenceCounterOperator&lt;T&gt;::DeleteReference;</div>
<div class="disabled">				Inc();</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;pointer&quot;&gt;The smart pointer to copy.&lt;/param&gt;</div>
<div class="disabled">		Ptr(const Ptr&lt;T&gt;&amp; pointer)</div>
<div class="disabled">			:counter(pointer.counter)</div>
<div class="disabled">			, reference(pointer.reference)</div>
<div class="disabled">			, originalReference(pointer.originalReference)</div>
<div class="disabled">			, originalDestructor(pointer.originalDestructor)</div>
<div class="disabled">		{</div>
<div class="disabled">			Inc();</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Move a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;pointer&quot;&gt;The smart pointer to Move.&lt;/param&gt;</div>
<div class="disabled">		Ptr(Ptr&lt;T&gt;&amp;&amp; pointer)</div>
<div class="disabled">			:counter(pointer.counter)</div>
<div class="disabled">			, reference(pointer.reference)</div>
<div class="disabled">			, originalReference(pointer.originalReference)</div>
<div class="disabled">			, originalDestructor(pointer.originalDestructor)</div>
<div class="disabled">		{</div>
<div class="disabled">			pointer.SetEmptyNoIncDec();</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Cast a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;C&quot;&gt;The type of the object before casting.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;pointer&quot;&gt;The smart pointer to cast.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename C, typename = typename AcceptType&lt;void, typename PointerConvertable&lt;C, T&gt;::YesNoType&gt;::Type&gt;</div>
<div class="disabled">		Ptr(const Ptr&lt;C&gt;&amp; pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (auto converted = pointer.Obj())</div>
<div class="disabled">			{</div>
<div class="disabled">				counter = pointer.Counter();</div>
<div class="disabled">				reference = converted;</div>
<div class="disabled">				originalReference = pointer.originalReference;</div>
<div class="disabled">				originalDestructor = pointer.originalDestructor;</div>
<div class="disabled">				Inc();</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Cast a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;C&quot;&gt;The type of the object before casting.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;pointer&quot;&gt;The smart pointer to cast.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename C, typename = typename AcceptType&lt;void, typename PointerConvertable&lt;C, T&gt;::YesNoType&gt;::Type&gt;</div>
<div class="disabled">		Ptr(Ptr&lt;C&gt;&amp;&amp; pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (auto converted = pointer.Obj())</div>
<div class="disabled">			{</div>
<div class="disabled">				counter = pointer.Counter();</div>
<div class="disabled">				reference = converted;</div>
<div class="disabled">				originalReference = pointer.originalReference;</div>
<div class="disabled">				originalDestructor = pointer.originalDestructor;</div>
<div class="disabled">				pointer.SetEmptyNoIncDec();</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		~Ptr()</div>
<div class="disabled">		{</div>
<div class="disabled">			Dec();</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Detach the contained object from this smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The detached object. Returns null if this smart pointer is empty.&lt;/returns&gt;</div>
<div class="disabled">		T* Detach()</div>
<div class="disabled">		{</div>
<div class="disabled">			auto detached = reference;</div>
<div class="disabled">			Dec(false);</div>
<div class="disabled">			return detached;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Cast a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;C&quot;&gt;The type of the object after casting.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The casted smart pointer. Returns null if failed.&lt;/returns&gt;</div>
<div class="disabled">		template&lt;typename C&gt;</div>
<div class="disabled">		Ptr&lt;C&gt; Cast()const</div>
<div class="disabled">		{</div>
<div class="disabled">			C* converted = dynamic_cast&lt;C*&gt;(reference);</div>
<div class="disabled">			return Ptr&lt;C&gt;((converted ? counter : 0), converted, originalReference, originalDestructor);</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Convert a pointer to an object to a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The converted smart pointer.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;pointer&quot;&gt;The pointer to the object.&lt;/param&gt;</div>
<div class="disabled">		Ptr&lt;T&gt;&amp; operator=(T* pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			Dec();</div>
<div class="disabled">			if (pointer)</div>
<div class="disabled">			{</div>
<div class="disabled">				counter = ReferenceCounterOperator&lt;T&gt;::CreateCounter(pointer);</div>
<div class="disabled">				reference = pointer;</div>
<div class="disabled">				originalReference = pointer;</div>
<div class="disabled">				originalDestructor = &amp;ReferenceCounterOperator&lt;T&gt;::DeleteReference;</div>
<div class="disabled">				Inc();</div>
<div class="disabled">			}</div>
<div class="disabled">			else</div>
<div class="disabled">			{</div>
<div class="disabled">				SetEmptyNoIncDec();</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The copied smart pointer.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;pointer&quot;&gt;The smart pointer to copy.&lt;/param&gt;</div>
<div class="disabled">		Ptr&lt;T&gt;&amp; operator=(const Ptr&lt;T&gt;&amp; pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (this != &amp;pointer)</div>
<div class="disabled">			{</div>
<div class="disabled">				Dec();</div>
<div class="disabled">				counter = pointer.counter;</div>
<div class="disabled">				reference = pointer.reference;</div>
<div class="disabled">				originalReference = pointer.originalReference;</div>
<div class="disabled">				originalDestructor = pointer.originalDestructor;</div>
<div class="disabled">				Inc();</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Move a smart pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The moved smart pointer.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;pointer&quot;&gt;The smart pointer to Move.&lt;/param&gt;</div>
<div class="disabled">		Ptr&lt;T&gt;&amp; operator=(Ptr&lt;T&gt;&amp;&amp; pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (this != &amp;pointer)</div>
<div class="disabled">			{</div>
<div class="disabled">				Dec();</div>
<div class="disabled">				counter = pointer.counter;</div>
<div class="disabled">				reference = pointer.reference;</div>
<div class="disabled">				originalReference = pointer.originalReference;</div>
<div class="disabled">				originalDestructor = pointer.originalDestructor;</div>
<div class="disabled">				pointer.SetEmptyNoIncDec();</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator==(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference == pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator!=(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference != pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference &gt; pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;=(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference &gt;= pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference &lt; pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;=(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference &lt;= pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator==(const Ptr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference == pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator!=(const Ptr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference != pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;(const Ptr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference &gt; pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;=(const Ptr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference &gt;= pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;(const Ptr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference &lt; pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;=(const Ptr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference &lt;= pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Test if it is a null pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;Returns true if it is not null.&lt;/returns&gt;</div>
<div class="disabled">		operator bool()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference != 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Get the pointer to the object.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The pointer to the object.&lt;/returns&gt;</div>
<div class="disabled">		T* Obj()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Get the pointer to the object.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The pointer to the object.&lt;/returns&gt;</div>
<div class="disabled">		T* operator-&gt;()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">ComPtr</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	class ComPtr</div>
<div class="disabled">	{</div>
<div class="disabled">	protected:</div>
<div class="disabled">		volatile vint*		counter;</div>
<div class="disabled">		T*					reference;</div>

<div class="disabled">		void Inc()</div>
<div class="disabled">		{</div>
<div class="disabled">			if(counter)</div>
<div class="disabled">			{</div>
<div class="disabled">				INCRC(counter);</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		void Dec()</div>
<div class="disabled">		{</div>
<div class="disabled">			if(counter)</div>
<div class="disabled">			{</div>
<div class="disabled">				if(DECRC(counter)==0)</div>
<div class="disabled">				{</div>
<div class="disabled">					delete counter;</div>
<div class="disabled">					reference-&gt;Release();</div>
<div class="disabled">					counter=0;</div>
<div class="disabled">					reference=0;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		volatile vint* Counter()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return counter;</div>
<div class="disabled">		}</div>

<div class="disabled">		ComPtr(volatile vint* _counter, T* _reference)</div>
<div class="disabled">			:counter(_counter)</div>
<div class="disabled">			,reference(_reference)</div>
<div class="disabled">		{</div>
<div class="disabled">			Inc();</div>
<div class="disabled">		}</div>
<div class="disabled">	public:</div>

<div class="disabled">		ComPtr()</div>
<div class="disabled">		{</div>
<div class="disabled">			counter=0;</div>
<div class="disabled">			reference=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		ComPtr(T* pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(pointer)</div>
<div class="disabled">			{</div>
<div class="disabled">				counter=new volatile vint(1);</div>
<div class="disabled">				reference=pointer;</div>
<div class="disabled">			}</div>
<div class="disabled">			else</div>
<div class="disabled">			{</div>
<div class="disabled">				counter=0;</div>
<div class="disabled">				reference=0;</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		ComPtr(const ComPtr&lt;T&gt;&amp; pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			counter=pointer.counter;</div>
<div class="disabled">			reference=pointer.reference;</div>
<div class="disabled">			Inc();</div>
<div class="disabled">		}</div>

<div class="disabled">		ComPtr(ComPtr&lt;T&gt;&amp;&amp; pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			counter=pointer.counter;</div>
<div class="disabled">			reference=pointer.reference;</div>
<div class="disabled">			</div>
<div class="disabled">			pointer.counter=0;</div>
<div class="disabled">			pointer.reference=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		~ComPtr()</div>
<div class="disabled">		{</div>
<div class="disabled">			Dec();</div>
<div class="disabled">		}</div>

<div class="disabled">		ComPtr&lt;T&gt;&amp; operator=(T* pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			Dec();</div>
<div class="disabled">			if(pointer)</div>
<div class="disabled">			{</div>
<div class="disabled">				counter=new vint(1);</div>
<div class="disabled">				reference=pointer;</div>
<div class="disabled">			}</div>
<div class="disabled">			else</div>
<div class="disabled">			{</div>
<div class="disabled">				counter=0;</div>
<div class="disabled">				reference=0;</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		ComPtr&lt;T&gt;&amp; operator=(const ComPtr&lt;T&gt;&amp; pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(this!=&amp;pointer)</div>
<div class="disabled">			{</div>
<div class="disabled">				Dec();</div>
<div class="disabled">				counter=pointer.counter;</div>
<div class="disabled">				reference=pointer.reference;</div>
<div class="disabled">				Inc();</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		ComPtr&lt;T&gt;&amp; operator=(ComPtr&lt;T&gt;&amp;&amp; pointer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(this!=&amp;pointer)</div>
<div class="disabled">			{</div>
<div class="disabled">				Dec();</div>
<div class="disabled">				counter=pointer.counter;</div>
<div class="disabled">				reference=pointer.reference;</div>
<div class="disabled">				</div>
<div class="disabled">				pointer.counter=0;</div>
<div class="disabled">				pointer.reference=0;</div>
<div class="disabled">			}</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator==(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference==pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator!=(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference!=pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference&gt;pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;=(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference&gt;=pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference&lt;pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;=(const T* pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference&lt;=pointer;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator==(const ComPtr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference==pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator!=(const ComPtr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference!=pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;(const ComPtr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference&gt;pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&gt;=(const ComPtr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference&gt;=pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;(const ComPtr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference&lt;pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator&lt;=(const ComPtr&lt;T&gt;&amp; pointer)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference&lt;=pointer.reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		operator bool()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference!=0;</div>
<div class="disabled">		}</div>

<div class="disabled">		T* Obj()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference;</div>
<div class="disabled">		}</div>

<div class="disabled">		T* operator-&gt;()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return reference;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T, typename ...TArgs&gt;</div>
<div class="disabled">	Ptr&lt;T&gt; MakePtr(TArgs ...args)</div>
<div class="disabled">	{</div>
<div class="disabled">		return new T(args...);</div>
<div class="disabled">	}</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Traits</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct KeyType&lt;Ptr&lt;T&gt;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T* Type;</div>

<div class="disabled">		static T* GetKeyValue(const Ptr&lt;T&gt;&amp; key)</div>
<div class="disabled">		{</div>
<div class="disabled">			return key.Obj();</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct POD&lt;Ptr&lt;T&gt;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		static const bool Result=false;</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct KeyType&lt;ComPtr&lt;T&gt;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef T* Type;</div>

<div class="disabled">		static T* GetKeyValue(const ComPtr&lt;T&gt;&amp; key)</div>
<div class="disabled">		{</div>
<div class="disabled">			return key.Obj();</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	struct POD&lt;ComPtr&lt;T&gt;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		static const bool Result=false;</div>
<div class="disabled">	};</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\FUNCTION.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Framework::Function

Classes:
	Func&lt;function-type&gt;									: Functor

Functions:
	Curry :: (A-&gt;B) -&gt; A -&gt; B							: Currying
	Combine :: (A-&gt;B) -&gt; (A-&gt;C) -&gt; (B-&gt;C-&gt;D) -&gt; (A-&gt;D)	: Combine multiple functors using an operator
***********************************************************************/</div>
<div class="disabled">#ifndef VCZH_FUNCTION</div>
<div class="disabled">#define VCZH_FUNCTION</div>
<div class="disabled">namespace vl</div>
<div class="disabled">{</div>

<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	class Func</div>
<div class="disabled">	{</div>
<div class="disabled">	};</div>
<div class="disabled"> </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::function_lambda::LambdaRetriveType&lt;R(TArgs...)&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled"> </div>
<div class="disabled">	namespace function_lambda</div>
<div class="disabled">	{</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct LambdaRetriveType</div>
<div class="disabled">		{</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct FunctionObjectRetriveType</div>
<div class="disabled">		{</div>
<div class="disabled">			typedef typename LambdaRetriveType&lt;decltype(&amp;T::operator())&gt;::Type Type;</div>
<div class="disabled">			typedef typename LambdaRetriveType&lt;decltype(&amp;T::operator())&gt;::FunctionType FunctionType;</div>
<div class="disabled">			typedef typename LambdaRetriveType&lt;decltype(&amp;T::operator())&gt;::ResultType ResultType;</div>
<div class="disabled">			typedef typename LambdaRetriveType&lt;decltype(&amp;T::operator())&gt;::ParameterTypes ParameterTypes;</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename TObject, typename R, typename ...TArgs&gt;</div>
<div class="disabled">		struct LambdaRetriveType&lt;R(__thiscall TObject::*)(TArgs...)const&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">			typedef Func&lt;R(TArgs...)&gt; Type;</div>
<div class="disabled">			typedef R(FunctionType)(TArgs...);</div>
<div class="disabled">			typedef R ResultType;</div>
<div class="disabled">			typedef TypeTuple&lt;TArgs...&gt; ParameterTypes;</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename TObject, typename R, typename ...TArgs&gt;</div>
<div class="disabled">		struct LambdaRetriveType&lt;R(__thiscall TObject::*)(TArgs...)&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">			typedef Func&lt;R(TArgs...)&gt; Type;</div>
<div class="disabled">			typedef R(FunctionType)(TArgs...);</div>
<div class="disabled">			typedef R ResultType;</div>
<div class="disabled">			typedef TypeTuple&lt;TArgs...&gt; ParameterTypes;</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename R, typename ...TArgs&gt;</div>
<div class="disabled">		struct FunctionObjectRetriveType&lt;R(*)(TArgs...)&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">			typedef Func&lt;R(TArgs...)&gt; Type;</div>
<div class="disabled">			typedef R(FunctionType)(TArgs...);</div>
<div class="disabled">			typedef R ResultType;</div>
<div class="disabled">			typedef TypeTuple&lt;TArgs...&gt; ParameterTypes;</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled"> </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Func&lt;R(TArgs...)&gt;</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">	namespace internal_invokers</div>
<div class="disabled">	{</div>
<div class="disabled">		template&lt;typename R, typename ...TArgs&gt;</div>
<div class="disabled">		class Invoker : public Object</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			virtual R Invoke(TArgs&amp;&amp; ...args) = 0;</div>
<div class="disabled">		};</div>

<div class="disabled">		//------------------------------------------------------</div>
<div class="disabled">		</div>
<div class="disabled">		template&lt;typename R, typename ...TArgs&gt;</div>
<div class="disabled">		class StaticInvoker : public Invoker&lt;R, TArgs...&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			R(*function)(TArgs ...args);</div>

<div class="disabled">		public:</div>
<div class="disabled">			StaticInvoker(R(*_function)(TArgs...))</div>
<div class="disabled">				:function(_function)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			R Invoke(TArgs&amp;&amp; ...args)override</div>
<div class="disabled">			{</div>
<div class="disabled">				return function(ForwardValue&lt;TArgs&gt;(args)...);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		//------------------------------------------------------</div>
<div class="disabled">		</div>
<div class="disabled">		template&lt;typename C, typename R, typename ...TArgs&gt;</div>
<div class="disabled">		class MemberInvoker : public Invoker&lt;R, TArgs...&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			C*							sender;</div>
<div class="disabled">			R(C::*function)(TArgs ...args);</div>

<div class="disabled">		public:</div>
<div class="disabled">			MemberInvoker(C* _sender, R(C::*_function)(TArgs ...args))</div>
<div class="disabled">				:sender(_sender)</div>
<div class="disabled">				,function(_function)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			R Invoke(TArgs&amp;&amp; ...args)override</div>
<div class="disabled">			{</div>
<div class="disabled">				return (sender-&gt;*function)(ForwardValue&lt;TArgs&gt;(args)...);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		//------------------------------------------------------</div>

<div class="disabled">		template&lt;typename C, typename R, typename ...TArgs&gt;</div>
<div class="disabled">		class ObjectInvoker : public Invoker&lt;R, TArgs...&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			C							function;</div>

<div class="disabled">		public:</div>
<div class="disabled">			ObjectInvoker(const C&amp; _function)</div>
<div class="disabled">				:function(_function)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			ObjectInvoker(C&amp;&amp; _function)</div>
<div class="disabled">				:function(MoveValue(_function))</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			R Invoke(TArgs&amp;&amp; ...args)override</div>
<div class="disabled">			{</div>
<div class="disabled">				return function(ForwardValue&lt;TArgs&gt;(args)...);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		//------------------------------------------------------</div>

<div class="disabled">		template&lt;typename C, typename ...TArgs&gt;</div>
<div class="disabled">		class ObjectInvoker&lt;C, void, TArgs...&gt; : public Invoker&lt;void, TArgs...&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			C							function;</div>

<div class="disabled">		public:</div>
<div class="disabled">			ObjectInvoker(const C&amp; _function)</div>
<div class="disabled">				:function(_function)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			ObjectInvoker(C&amp;&amp; _function)</div>
<div class="disabled">				:function(MoveValue(_function))</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			void Invoke(TArgs&amp;&amp; ...args)override</div>
<div class="disabled">			{</div>
<div class="disabled">				function(ForwardValue&lt;TArgs&gt;(args)...);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>

<div class="disabled">	/// &lt;summary&gt;A type representing a function reference.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;R&quot;&gt;The return type.&lt;/typeparam&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;TArgs&quot;&gt;Types of parameters.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename R, typename ...TArgs&gt;</div>
<div class="disabled">	class Func&lt;R(TArgs...)&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	protected:</div>
<div class="disabled">		Ptr&lt;internal_invokers::Invoker&lt;R, TArgs...&gt;&gt;		invoker;</div>

<div class="disabled">		template&lt;typename R2, typename ...TArgs2&gt;</div>
<div class="disabled">		static bool IsEmptyFunc(const Func&lt;R2(TArgs2...)&gt;&amp; function)</div>
<div class="disabled">		{</div>
<div class="disabled">			return !function;</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename R2, typename ...TArgs2&gt;</div>
<div class="disabled">		static bool IsEmptyFunc(Func&lt;R2(TArgs2...)&gt;&amp; function)</div>
<div class="disabled">		{</div>
<div class="disabled">			return !function;</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename C&gt;</div>
<div class="disabled">		static bool IsEmptyFunc(C&amp;&amp;)</div>
<div class="disabled">		{</div>
<div class="disabled">			return false;</div>
<div class="disabled">		}</div>
<div class="disabled">	public:</div>
<div class="disabled">		typedef R FunctionType(TArgs...);</div>
<div class="disabled">		typedef R ResultType;</div>

<div class="disabled">		/// &lt;summary&gt;Create a null function reference.&lt;/summary&gt;</div>
<div class="disabled">		Func()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy a function reference.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;function&quot;&gt;The function reference to copy.&lt;/param&gt;</div>
<div class="disabled">		Func(const Func&lt;R(TArgs...)&gt;&amp; function)</div>
<div class="disabled">			:invoker(function.invoker)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Move a function reference.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;function&quot;&gt;The function reference to move.&lt;/param&gt;</div>
<div class="disabled">		Func(Func&lt;R(TArgs...)&gt;&amp;&amp; function)</div>
<div class="disabled">			:invoker(MoveValue(function.invoker))</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create a reference using a function pointer.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;function&quot;&gt;The function pointer.&lt;/param&gt;</div>
<div class="disabled">		Func(R(*function)(TArgs...))</div>
<div class="disabled">		{</div>
<div class="disabled">			invoker = new internal_invokers::StaticInvoker&lt;R, TArgs...&gt;(function);</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create a reference using a method.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;C&quot;&gt;Type of the class that has the method.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;sender&quot;&gt;The object that has the method.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;function&quot;&gt;The function pointer.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename C&gt;</div>
<div class="disabled">		Func(C* sender, R(C::*function)(TArgs...))</div>
<div class="disabled">		{</div>
<div class="disabled">			invoker = new internal_invokers::MemberInvoker&lt;C, R, TArgs...&gt;(sender, function);</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create a reference using a function object.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;C&quot;&gt;Type of the function object.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;function&quot;&gt;The function object. It could be a lambda expression.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename C, typename = typename AcceptType&lt;void, typename ReturnConvertable&lt;decltype(ValueOf&lt;C&gt;()(ValueOf&lt;TArgs&gt;()...)), R&gt;::YesNoType&gt;::Type&gt;</div>
<div class="disabled">		Func(C&amp;&amp; function)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (!IsEmptyFunc(function))</div>
<div class="disabled">			{</div>
<div class="disabled">				invoker = new internal_invokers::ObjectInvoker&lt;typename RemoveCVR&lt;C&gt;::Type, R, TArgs...&gt;(ForwardValue&lt;C&amp;&amp;&gt;(function));</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Invoke the function.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;Returns the function result.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;args&quot;&gt;Arguments to invoke the function.&lt;/param&gt;</div>
<div class="disabled">		R operator()(TArgs ...args)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return invoker-&gt;Invoke(ForwardValue&lt;TArgs&gt;(args)...);</div>
<div class="disabled">		}</div>

<div class="disabled">		Func&lt;R(TArgs...)&gt;&amp; operator=(const Func&lt;R(TArgs...)&gt;&amp; function)</div>
<div class="disabled">		{</div>
<div class="disabled">			invoker = function.invoker;</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		Func&lt;R(TArgs...)&gt;&amp; operator=(const Func&lt;R(TArgs...)&gt;&amp;&amp; function)</div>
<div class="disabled">		{</div>
<div class="disabled">			invoker = MoveValue(function.invoker);</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator==(const Func&lt;R(TArgs...)&gt;&amp; function)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return invoker == function.invoker;</div>
<div class="disabled">		}</div>

<div class="disabled">		bool operator!=(const Func&lt;R(TArgs...)&gt;&amp; function)const</div>
<div class="disabled">		{</div>
<div class="disabled">			return invoker != function.invoker;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Test is the reference a null reference.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;Returns true if it is not a null reference.&lt;/returns&gt;</div>
<div class="disabled">		operator bool()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return invoker;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>
<div class="disabled"> </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">LAMBDA</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled"> </div>
<div class="disabled">	namespace function_lambda</div>
<div class="disabled">	{</div>
<div class="disabled">		/// &lt;summary&gt;Create a function reference to a function object or a lambda expression, with all type information autotimatically inferred. You can use the macro called &quot;LAMBDA&quot; to refer to this function.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of the function object or the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The function reference.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;functionObject&quot;&gt;The function object or the lambda expression.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		typename LambdaRetriveType&lt;decltype(&amp;T::operator())&gt;::Type Lambda(T functionObject)</div>
<div class="disabled">		{</div>
<div class="disabled">			return functionObject;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create a function reference to a function pointer, with all type information autotimatically inferred. You can use the macro called &quot;FUNCTION&quot; to refer to this function.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of the function pointer.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The function reference.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;functionObject&quot;&gt;The function pointer.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		typename FunctionObjectRetriveType&lt;T&gt;::Type ConvertToFunction(T functionObject)</div>
<div class="disabled">		{</div>
<div class="disabled">			return functionObject;</div>
<div class="disabled">		}</div>

<div class="disabled">#define LAMBDA vl::function_lambda::Lambda</div>
<div class="disabled">#define FUNCTION vl::function_lambda::ConvertToFunction</div>
<div class="disabled">#define FUNCTION_TYPE(T) typename vl::function_lambda::FunctionObjectRetriveType&lt;T&gt;::Type</div>
<div class="disabled">#define FUNCTION_RESULT_TYPE(T) typename vl::function_lambda::FunctionObjectRetriveType&lt;T&gt;::ResultType</div>
<div class="disabled">	}</div>
<div class="disabled"> </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::function_binding::Binding&lt;R(TArgs...)&gt;</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">	namespace function_binding</div>
<div class="disabled">	{</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct Binding</div>
<div class="disabled">		{</div>
<div class="disabled">		};</div>
<div class="disabled">		 </div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct CR{typedef const T&amp; Type;};</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct CR&lt;T&amp;&gt;{typedef T&amp; Type;};</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct CR&lt;const T&gt;{typedef const T&amp; Type;};</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct CR&lt;const T&amp;&gt;{typedef const T&amp; Type;};</div>
<div class="disabled"> </div>
<div class="disabled">		template&lt;typename R, typename T0, typename ...TArgs&gt;</div>
<div class="disabled">		struct Binding&lt;R(T0, TArgs...)&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">			typedef R FunctionType(T0, TArgs...);</div>
<div class="disabled">			typedef R CurriedType(TArgs...);</div>
<div class="disabled">			typedef T0 FirstParameterType;</div>

<div class="disabled">			class Binder : public Object</div>
<div class="disabled">			{</div>
<div class="disabled">			protected:</div>
<div class="disabled">				Func&lt;FunctionType&gt;				target;</div>
<div class="disabled">				T0								firstArgument;</div>
<div class="disabled">			public:</div>
<div class="disabled">				Binder(const Func&lt;FunctionType&gt;&amp; _target, T0 _firstArgument)</div>
<div class="disabled">					:target(_target)</div>
<div class="disabled">					,firstArgument(ForwardValue&lt;T0&gt;(_firstArgument))</div>
<div class="disabled">				{</div>
<div class="disabled">				}</div>

<div class="disabled">				R operator()(TArgs ...args)const</div>
<div class="disabled">				{</div>
<div class="disabled">					return target(firstArgument, args...);</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			class Currier : public Object</div>
<div class="disabled">			{</div>
<div class="disabled">			protected:</div>
<div class="disabled">				Func&lt;FunctionType&gt;		target;</div>
<div class="disabled">			public:</div>
<div class="disabled">				Currier(const Func&lt;FunctionType&gt;&amp; _target)</div>
<div class="disabled">					:target(_target)</div>
<div class="disabled">				{</div>
<div class="disabled">				}</div>

<div class="disabled">				Func&lt;CurriedType&gt; operator()(T0 firstArgument)const</div>
<div class="disabled">				{</div>
<div class="disabled">					return Binder(target, firstArgument);</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">		}; </div>
<div class="disabled">	}</div>
<div class="disabled"> </div>
<div class="disabled">	/// &lt;summary&gt;Currize a function. Currizing means to create a new function whose argument is the first argument of the original function. Calling this function will return another function reference whose arguments is all remain arguments of the original function. Calling the returned function will call the original function.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;Type of the function.&lt;/typeparam&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The currized function.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;function&quot;&gt;The function pointer to currize.&lt;/param&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	Func&lt;Func&lt;typename function_binding::Binding&lt;T&gt;::CurriedType&gt;(typename function_binding::Binding&lt;T&gt;::FirstParameterType)&gt;</div>
<div class="disabled">	Curry(T* function)</div>
<div class="disabled">	{</div>
<div class="disabled">		return typename function_binding::Binding&lt;T&gt;::Currier(function);</div>
<div class="disabled">	}</div>
<div class="disabled"> </div>
<div class="disabled">	/// &lt;summary&gt;Currize a function. Currizing means to create a new function whose argument is the first argument of the original function. Calling this function will return another function reference whose arguments is all remain arguments of the original function. Calling the returned function will call the original function.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;Type of the function.&lt;/typeparam&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The currized function.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;function&quot;&gt;The function reference to currize.&lt;/param&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	Func&lt;Func&lt;typename function_binding::Binding&lt;T&gt;::CurriedType&gt;(typename function_binding::Binding&lt;T&gt;::FirstParameterType)&gt;</div>
<div class="disabled">	Curry(const Func&lt;T&gt;&amp; function)</div>
<div class="disabled">	{</div>
<div class="disabled">		return typename function_binding::Binding&lt;T&gt;::Currier(function);</div>
<div class="disabled">	}</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::function_combining::Combining&lt;R1(TArgs...), R2(TArgs...), R(R1,R2)&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled"> </div>
<div class="disabled">	namespace function_combining</div>
<div class="disabled">	{</div>
<div class="disabled">		template&lt;typename A, typename B, typename C&gt;</div>
<div class="disabled">		class Combining</div>
<div class="disabled">		{</div>
<div class="disabled">		};</div>
<div class="disabled"> </div>
<div class="disabled">		template&lt;typename R1, typename R2, typename R, typename ...TArgs&gt;</div>
<div class="disabled">		class Combining&lt;R1(TArgs...), R2(TArgs...), R(R1,R2)&gt; : public Object</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			Func&lt;R1(TArgs...)&gt;			function1;</div>
<div class="disabled">			Func&lt;R2(TArgs...)&gt;			function2;</div>
<div class="disabled">			Func&lt;R(R1, R2)&gt;				converter;</div>
<div class="disabled">		public:</div>
<div class="disabled">			typedef R1 FirstFunctionType(TArgs...);</div>
<div class="disabled">			typedef R2 SecondFunctionType(TArgs...);</div>
<div class="disabled">			typedef R ConverterFunctionType(R1, R2);</div>
<div class="disabled">			typedef R FinalFunctionType(TArgs...);</div>

<div class="disabled">			Combining(const Func&lt;R1(TArgs...)&gt;&amp; _function1, const Func&lt;R2(TArgs...)&gt;&amp; _function2, const Func&lt;R(R1,R2)&gt;&amp; _converter)</div>
<div class="disabled">				:function1(_function1)</div>
<div class="disabled">				,function2(_function2)</div>
<div class="disabled">				,converter(_converter)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			R operator()(TArgs&amp;&amp; ...args)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return converter(function1(ForwardValue&lt;TArgs&gt;(args)...), function2(ForwardValue&lt;TArgs&gt;(args)...));</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>

<div class="disabled">	/// &lt;summary&gt;Combine two functions with a converter function. The two functions to combine should have the same argument types. The converter function will use the return values of the two function to calculate the final value.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;F1&quot;&gt;Type of the first function.&lt;/typeparam&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;F2&quot;&gt;Type of the second function.&lt;/typeparam&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;C&quot;&gt;Type of the converter function.&lt;/typeparam&gt;</div>
<div class="disabled">	/// &lt;returns&gt;A new function whose argument list are the same of the two functions to provide. Calling this function will call function1, function2 and converter in order to calculate the final value.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;converter&quot;&gt;The converter function.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;function1&quot;&gt;The first function.&lt;/param&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;function2&quot;&gt;The second function.&lt;/param&gt;</div>
<div class="disabled">	template&lt;typename F1, typename F2, typename C&gt;</div>
<div class="disabled">	Func&lt;typename function_combining::Combining&lt;F1, F2, C&gt;::FinalFunctionType&gt;</div>
<div class="disabled">	Combine(Func&lt;C&gt; converter, Func&lt;F1&gt; function1, Func&lt;F2&gt; function2)</div>
<div class="disabled">	{</div>
<div class="disabled">		return function_combining::Combining&lt;F1, F2, C&gt;(function1, function2, converter);</div>
<div class="disabled">	}</div>

<div class="disabled">	/// &lt;summary&gt;Use the converter function to create a combiner, who will receive two function and use &lt;see cref=&quot;Combine&quot;/&gt; to create a combined function. This function assumes the result types of the two provided function in the future are the same, and the converter function will not change the result type.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;Type of the two functions to combine.&lt;/typeparam&gt;</div>
<div class="disabled">	/// &lt;returns&gt;The combiner.&lt;/returns&gt;</div>
<div class="disabled">	/// &lt;param name=&quot;converter&quot;&gt;The converter function.&lt;/param&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	Func&lt;Func&lt;T&gt;(Func&lt;T&gt;,Func&lt;T&gt;)&gt; Combiner(const Func&lt;typename Func&lt;T&gt;::ResultType(typename Func&lt;T&gt;::ResultType,typename Func&lt;T&gt;::ResultType)&gt;&amp; converter)</div>
<div class="disabled">	{</div>
<div class="disabled">		typedef typename Func&lt;T&gt;::ResultType R;</div>
<div class="disabled">		return Curry&lt;Func&lt;T&gt;(Func&lt;R(R,R)&gt;,Func&lt;T&gt;,Func&lt;T&gt;)&gt;(Combine)(converter);</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>
<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\PAIR.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Pair

Classes:
	Pair&lt;K, V&gt;							: Pair
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_PAIR</div>
<div class="disabled">#define VCZH_COLLECTIONS_PAIR</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>
<div class="disabled">		/// &lt;summary&gt;A type representing a pair of key and value.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;K&quot;&gt;Type of the key.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;V&quot;&gt;Type of the value.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename K, typename V&gt;</div>
<div class="disabled">		class Pair</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			/// &lt;summary&gt;The key.&lt;/summary&gt;</div>
<div class="disabled">			K				key;</div>
<div class="disabled">			/// &lt;summary&gt;The value.&lt;/summary&gt;</div>
<div class="disabled">			V				value;</div>

<div class="disabled">			Pair()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			Pair(const K&amp; _key, const V&amp; _value)</div>
<div class="disabled">			{</div>
<div class="disabled">				key=_key;</div>
<div class="disabled">				value=_value;</div>
<div class="disabled">			}</div>

<div class="disabled">			Pair(const Pair&lt;K, V&gt;&amp; pair)</div>
<div class="disabled">			{</div>
<div class="disabled">				key=pair.key;</div>
<div class="disabled">				value=pair.value;</div>
<div class="disabled">			}</div>

<div class="disabled">			vint CompareTo(const Pair&lt;K, V&gt;&amp; pair)const</div>
<div class="disabled">			{</div>
<div class="disabled">				if(key&lt;pair.key)</div>
<div class="disabled">				{</div>
<div class="disabled">					return -1;</div>
<div class="disabled">				}</div>
<div class="disabled">				else if(key&gt;pair.key)</div>
<div class="disabled">				{</div>
<div class="disabled">					return 1;</div>
<div class="disabled">				}</div>
<div class="disabled">				else if(value&lt;pair.value)</div>
<div class="disabled">				{</div>
<div class="disabled">					return -1;</div>
<div class="disabled">				}</div>
<div class="disabled">				else if(value&gt;pair.value)</div>
<div class="disabled">				{</div>
<div class="disabled">					return 1;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return 0;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			bool operator==(const Pair&lt;K, V&gt;&amp; pair)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return CompareTo(pair)==0;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool operator!=(const Pair&lt;K, V&gt;&amp; pair)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return CompareTo(pair)!=0;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool operator&lt;(const Pair&lt;K, V&gt;&amp; pair)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return CompareTo(pair)&lt;0;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool operator&lt;=(const Pair&lt;K, V&gt;&amp; pair)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return CompareTo(pair)&lt;=0;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool operator&gt;(const Pair&lt;K, V&gt;&amp; pair)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return CompareTo(pair)&gt;0;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool operator&gt;=(const Pair&lt;K, V&gt;&amp; pair)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return CompareTo(pair)&gt;=0;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>

<div class="disabled">	template&lt;typename K, typename V&gt;</div>
<div class="disabled">	struct POD&lt;collections::Pair&lt;K, V&gt;&gt;</div>
<div class="disabled">	{</div>
<div class="disabled">		static const bool Result=POD&lt;K&gt;::Result &amp;&amp; POD&lt;V&gt;::Result;</div>
<div class="disabled">	};</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\INTERFACES.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Interfaces

Interfaces:
	IEnumerator&lt;T&gt;									: Enumerator interface
	IEnumerable&lt;T&gt;									: Enumerable object interface
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_INTERFACES</div>
<div class="disabled">#define VCZH_COLLECTIONS_INTERFACES</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Interfaces</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		/// &lt;summary&gt;Enumerator.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of the elements in the enumerator.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class IEnumerator : public virtual Interface</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			typedef T									ElementType;</div>

<div class="disabled">			/// &lt;summary&gt;Copy the enumerator with the current state.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The copied enumerator.&lt;/returns&gt;</div>
<div class="disabled">			virtual IEnumerator&lt;T&gt;*						Clone()const=0;</div>
<div class="disabled">			/// &lt;summary&gt;Get the reference to the current element in the enumerator.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The reference to the current element.&lt;/returns&gt;</div>
<div class="disabled">			virtual const T&amp;							Current()const=0;</div>
<div class="disabled">			/// &lt;summary&gt;Get the position of the current element in the enumerator.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The position of the current element.&lt;/returns&gt;</div>
<div class="disabled">			virtual vint								Index()const=0;</div>
<div class="disabled">			/// &lt;summary&gt;Step forward.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns false if the enumerator reaches the end.&lt;/returns&gt;</div>
<div class="disabled">			virtual bool								Next()=0;</div>
<div class="disabled">			/// &lt;summary&gt;Reset the enumerator.&lt;/summary&gt;</div>
<div class="disabled">			virtual void								Reset()=0;</div>

<div class="disabled">			virtual bool								Evaluated()const{return false;}</div>
<div class="disabled">		};</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Enumerable.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of the elements in the enumerator.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class IEnumerable : public virtual Interface</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			typedef T									ElementType;</div>

<div class="disabled">			/// &lt;summary&gt;Create an enumerator. [M:vl.collections.IEnumerator`1.Next] should be called to get the first element.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The enumerator.&lt;/returns&gt;</div>
<div class="disabled">			virtual IEnumerator&lt;T&gt;*						CreateEnumerator()const=0;</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Random Access</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		namespace randomaccess_internal</div>
<div class="disabled">		{</div>
<div class="disabled">			template&lt;typename T&gt;</div>
<div class="disabled">			struct RandomAccessable</div>
<div class="disabled">			{</div>
<div class="disabled">				static const bool							CanRead = false;</div>
<div class="disabled">				static const bool							CanResize = false;</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;typename T&gt;</div>
<div class="disabled">			struct RandomAccess</div>
<div class="disabled">			{</div>
<div class="disabled">				static vint GetCount(const T&amp; t)</div>
<div class="disabled">				{</div>
<div class="disabled">					return t.Count();</div>
<div class="disabled">				}</div>

<div class="disabled">				static const typename T::ElementType&amp; GetValue(const T&amp; t, vint index)</div>
<div class="disabled">				{</div>
<div class="disabled">					return t.Get(index);</div>
<div class="disabled">				}</div>

<div class="disabled">				static void SetCount(T&amp; t, vint count)</div>
<div class="disabled">				{</div>
<div class="disabled">					t.Resize(count);</div>
<div class="disabled">				}</div>

<div class="disabled">				static void SetValue(T&amp; t, vint index, const typename T::ElementType&amp; value)</div>
<div class="disabled">				{</div>
<div class="disabled">					t.Set(index, value);</div>
<div class="disabled">				}</div>

<div class="disabled">				static void AppendValue(T&amp; t, const typename T::ElementType&amp; value)</div>
<div class="disabled">				{</div>
<div class="disabled">					t.Add(value);</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\LIST.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::List

Classes:
	ListStore&lt;T,PODType&gt;				: Array copy helper functions
	ListBase&lt;T,K&gt;						: Base class for array
	Array&lt;T,K&gt;							: Array
	List&lt;T,K&gt;							: List
	SortedList&lt;T,K&gt;						: List with item order maintained
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_LIST</div>
<div class="disabled">#define VCZH_COLLECTIONS_LIST</div>

<div class="disabled">#include &lt;string.h&gt;</div>

<div class="disabled">#ifdef VCZH_CHECK_MEMORY_LEAKS_NEW</div>
<div class="disabled">#undef new</div>
<div class="disabled">#endif</div>

<div class="disabled">#include &lt;new&gt;</div>

<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Memory Management</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T, bool PODType&gt;</div>
<div class="disabled">		class ListStore abstract : public Object</div>
<div class="disabled">		{</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class ListStore&lt;T, false&gt; abstract : public Object</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			static void InitializeItemsByDefault(void* dst, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">				T* ds = (T*)dst;</div>

<div class="disabled">				for (vint i = 0; i &lt; count; i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					new(&amp;ds[i])T();</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			static void InitializeItemsByMove(void* dst, void* src, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">				T* ds = (T*)dst;</div>
<div class="disabled">				T* ss = (T*)src;</div>

<div class="disabled">				for (vint i = 0; i &lt; count; i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					new(&amp;ds[i])T(MoveValue(ss[i]));</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			static void InitializeItemsByCopy(void* dst, void* src, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">				T* ds = (T*)dst;</div>
<div class="disabled">				T* ss = (T*)src;</div>

<div class="disabled">				for (vint i = 0; i &lt; count; i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					new(&amp;ds[i])T(ss[i]);</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			static void MoveItemsInTheSameBuffer(void* dst, void* src, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">				T* ds = (T*)dst;</div>
<div class="disabled">				T* ss = (T*)src;</div>

<div class="disabled">				if (ds &lt; ss)</div>
<div class="disabled">				{</div>
<div class="disabled">					for (vint i = 0; i &lt; count; i++)</div>
<div class="disabled">					{</div>
<div class="disabled">						ds[i] = MoveValue(ss[i]);</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				else if (ds &gt; ss)</div>
<div class="disabled">				{</div>
<div class="disabled">					for (vint i = count - 1; i &gt;= 0; i--)</div>
<div class="disabled">					{</div>
<div class="disabled">						ds[i] = MoveValue(ss[i]);</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			static void ReleaseItems(void* dst, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">				T* ds = (T*)dst;</div>

<div class="disabled">				for (vint i = 0; i &lt; count; i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					ds[i].~T();</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			static void* AllocateBuffer(vint size)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (size &lt;= 0) return nullptr;</div>
<div class="disabled">				return (void*)malloc(sizeof(T) * size);</div>
<div class="disabled">			}</div>

<div class="disabled">			static void DeallocateBuffer(void* buffer)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (buffer == nullptr)return;</div>
<div class="disabled">				free(buffer);</div>
<div class="disabled">			}</div>
<div class="disabled">		public:</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class ListStore&lt;T, true&gt; abstract : public Object</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			static void InitializeItemsByDefault(void* dst, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			static void InitializeItemsByMove(void* dst, void* src, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (count &gt; 0)</div>
<div class="disabled">				{</div>
<div class="disabled">					memcpy(dst, src, sizeof(T) * count);</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			static void InitializeItemsByCopy(void* dst, void* src, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (count &gt; 0)</div>
<div class="disabled">				{</div>
<div class="disabled">					memcpy(dst, src, sizeof(T) * count);</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			static void MoveItemsInTheSameBuffer(void* dst, void* src, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (count &gt; 0)</div>
<div class="disabled">				{</div>
<div class="disabled">					memmove(dst, src, sizeof(T) * count);</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			static void ReleaseItems(void* dst, vint count)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			static void* AllocateBuffer(vint size)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (size &lt;= 0) return nullptr;</div>
<div class="disabled">				return (void*)malloc(sizeof(T) * size);</div>
<div class="disabled">			}</div>

<div class="disabled">			static void DeallocateBuffer(void* buffer)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (buffer == nullptr) return;</div>
<div class="disabled">				free(buffer);</div>
<div class="disabled">			}</div>
<div class="disabled">		public:</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">ArrayBase</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		/// &lt;summary&gt;Base type of all linear container.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class ArrayBase abstract : public ListStore&lt;T, POD&lt;T&gt;::Result&gt;, public virtual IEnumerable&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			class Enumerator : public Object, public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">			private:</div>
<div class="disabled">				const ArrayBase&lt;T&gt;*				container;</div>
<div class="disabled">				vint							index;</div>

<div class="disabled">			public:</div>
<div class="disabled">				Enumerator(const ArrayBase&lt;T&gt;* _container, vint _index = -1)</div>
<div class="disabled">				{</div>
<div class="disabled">					container = _container;</div>
<div class="disabled">					index = _index;</div>
<div class="disabled">				}</div>

<div class="disabled">				IEnumerator&lt;T&gt;* Clone()const</div>
<div class="disabled">				{</div>
<div class="disabled">					return new Enumerator(container, index);</div>
<div class="disabled">				}</div>

<div class="disabled">				const T&amp; Current()const</div>
<div class="disabled">				{</div>
<div class="disabled">					return container-&gt;Get(index);</div>
<div class="disabled">				}</div>

<div class="disabled">				vint Index()const</div>
<div class="disabled">				{</div>
<div class="disabled">					return index;</div>
<div class="disabled">				}</div>

<div class="disabled">				bool Next()</div>
<div class="disabled">				{</div>
<div class="disabled">					index++;</div>
<div class="disabled">					return index &gt;= 0 &amp;&amp; index &lt; container-&gt;Count();</div>
<div class="disabled">				}</div>

<div class="disabled">				void Reset()</div>
<div class="disabled">				{</div>
<div class="disabled">					index = -1;</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			void*					buffer = nullptr;</div>
<div class="disabled">			vint					count = 0;</div>

<div class="disabled">			static void* AddressOf(void* bufferOfTs, vint index)</div>
<div class="disabled">			{</div>
<div class="disabled">				return (void*)((char*)bufferOfTs + sizeof(T) * index);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; ItemOf(vint index)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return *(const T*)AddressOf(buffer, index);</div>
<div class="disabled">			}</div>

<div class="disabled">			T&amp; ItemOf(vint index)</div>
<div class="disabled">			{</div>
<div class="disabled">				return *(T*)AddressOf(buffer, index);</div>
<div class="disabled">			}</div>
<div class="disabled">		public:</div>
<div class="disabled">			ArrayBase()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* CreateEnumerator()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new Enumerator(this);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the number of elements in the container.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The number of elements.&lt;/returns&gt;</div>
<div class="disabled">			vint Count()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return count;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the reference to the specified element.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The reference to the specified element.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The index of the element.&lt;/param&gt;</div>
<div class="disabled">			const T&amp; Get(vint index)const</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt; this-&gt;count, L&quot;ArrayBase&lt;T, K&gt;::Get(vint)#Argument index not in range.&quot;);</div>
<div class="disabled">				return ItemOf(index);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the reference to the specified element.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The reference to the specified element.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The index of the element.&lt;/param&gt;</div>
<div class="disabled">			const T&amp; operator[](vint index)const</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt; this-&gt;count, L&quot;ArrayBase&lt;T, K&gt;::operator[](vint)#Argument index not in range.&quot;);</div>
<div class="disabled">				return ItemOf(index);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Array</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		/// &lt;summary&gt;Array.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;K&quot;&gt;Type of the key type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename T, typename K = typename KeyType&lt;T&gt;::Type&gt;</div>
<div class="disabled">		class Array : public ArrayBase&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			/// &lt;summary&gt;Create an array.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;size&quot;&gt;The size of the array.&lt;/param&gt;</div>
<div class="disabled">			Array(vint size = 0)</div>
<div class="disabled">			{</div>
<div class="disabled">				this-&gt;buffer = this-&gt;AllocateBuffer(size);</div>
<div class="disabled">				this-&gt;InitializeItemsByDefault(this-&gt;buffer, size);</div>
<div class="disabled">				this-&gt;count = size;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create an array.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;_buffer&quot;&gt;Pointer to an array to copy.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;size&quot;&gt;The size of the array.&lt;/param&gt;</div>
<div class="disabled">			Array(const T* _buffer, vint size)</div>
<div class="disabled">			{</div>
<div class="disabled">				this-&gt;buffer = this-&gt;AllocateBuffer(size);</div>
<div class="disabled">				this-&gt;InitializeItemsByCopy(this-&gt;buffer, (void*)_buffer, size);</div>
<div class="disabled">				this-&gt;count = size;</div>
<div class="disabled">			}</div>

<div class="disabled">			~Array()</div>
<div class="disabled">			{</div>
<div class="disabled">				this-&gt;ReleaseItems(this-&gt;buffer, this-&gt;count);</div>
<div class="disabled">				this-&gt;DeallocateBuffer(this-&gt;buffer);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Test does the array contain an item or not.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the array contains the specified item.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to test.&lt;/param&gt;</div>
<div class="disabled">			bool Contains(const K&amp; item)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return IndexOf(item) != -1;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the position of an item in this array.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns the position. Returns -1 if not exists&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to find.&lt;/param&gt;</div>
<div class="disabled">			vint IndexOf(const K&amp; item)const</div>
<div class="disabled">			{</div>
<div class="disabled">				for (vint i = 0; i &lt; this-&gt;count; i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					if (this-&gt;ItemOf(i) == item)</div>
<div class="disabled">					{</div>
<div class="disabled">						return i;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				return -1;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Replace an item.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The position of the item.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The new item to put into the array.&lt;/param&gt;</div>
<div class="disabled">			void Set(vint index, const T&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt; this-&gt;count, L&quot;Array&lt;T, K&gt;::Set(vint)#Argument index not in range.&quot;);</div>
<div class="disabled">				this-&gt;ItemOf(index) = item;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the reference to the specified element.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The reference to the specified element.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The index of the element.&lt;/param&gt;</div>
<div class="disabled">			using ArrayBase&lt;T&gt;::operator[];</div>
<div class="disabled">			T&amp; operator[](vint index)</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt; this-&gt;count, L&quot;Array&lt;T, K&gt;::operator[](vint)#Argument index not in range.&quot;);</div>
<div class="disabled">				return this-&gt;ItemOf(index);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Change the size of the array.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;size&quot;&gt;The new size of the array.&lt;/param&gt;</div>
<div class="disabled">			void Resize(vint size)</div>
<div class="disabled">			{</div>
<div class="disabled">				void* newBuffer = this-&gt;AllocateBuffer(size);</div>
<div class="disabled">				if (size &lt; this-&gt;count)</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;InitializeItemsByMove(this-&gt;AddressOf(newBuffer, 0), this-&gt;AddressOf(this-&gt;buffer, 0), size);</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;InitializeItemsByMove(this-&gt;AddressOf(newBuffer, 0), this-&gt;AddressOf(this-&gt;buffer, 0), this-&gt;count);</div>
<div class="disabled">					this-&gt;InitializeItemsByDefault(this-&gt;AddressOf(newBuffer, this-&gt;count), size - this-&gt;count);</div>
<div class="disabled">				}</div>

<div class="disabled">				this-&gt;ReleaseItems(this-&gt;buffer, this-&gt;count);</div>
<div class="disabled">				this-&gt;DeallocateBuffer(this-&gt;buffer);</div>
<div class="disabled">				this-&gt;buffer = newBuffer;</div>
<div class="disabled">				this-&gt;count = size;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">ListBase</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		/// &lt;summary&gt;Base type for a list container.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;K&quot;&gt;Type of the key type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename T, typename K = typename KeyType&lt;T&gt;::Type&gt;</div>
<div class="disabled">		class ListBase abstract : public ArrayBase&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			vint					capacity = 0;</div>
<div class="disabled">			bool					lessMemoryMode = false;</div>

<div class="disabled">			vint CalculateCapacity(vint expected)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint result = capacity;</div>
<div class="disabled">				while (result &lt; expected)</div>
<div class="disabled">				{</div>
<div class="disabled">					result = result * 5 / 4 + 1;</div>
<div class="disabled">				}</div>
<div class="disabled">				return result;</div>
<div class="disabled">			}</div>

<div class="disabled">			void MakeRoom(vint index, vint _count, bool&amp; uninitialized)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint newCount = this-&gt;count + _count;</div>
<div class="disabled">				if (newCount &gt; capacity)</div>
<div class="disabled">				{</div>
<div class="disabled">					vint newCapacity = CalculateCapacity(newCount);</div>
<div class="disabled">					void* newBuffer = this-&gt;AllocateBuffer(newCapacity);</div>
<div class="disabled">					this-&gt;InitializeItemsByMove(this-&gt;AddressOf(newBuffer, 0), this-&gt;AddressOf(this-&gt;buffer, 0), index);</div>
<div class="disabled">					this-&gt;InitializeItemsByMove(this-&gt;AddressOf(newBuffer, index + _count), this-&gt;AddressOf(this-&gt;buffer, index), this-&gt;count - index);</div>
<div class="disabled">					this-&gt;ReleaseItems(this-&gt;buffer, this-&gt;count);</div>
<div class="disabled">					this-&gt;DeallocateBuffer(this-&gt;buffer);</div>
<div class="disabled">					this-&gt;capacity = newCapacity;</div>
<div class="disabled">					this-&gt;buffer = newBuffer;</div>
<div class="disabled">					uninitialized = true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else if (index &gt;= this-&gt;count)</div>
<div class="disabled">				{</div>
<div class="disabled">					uninitialized = true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else if (this-&gt;count - index &lt; _count)</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;InitializeItemsByMove(this-&gt;AddressOf(this-&gt;buffer, index + _count), this-&gt;AddressOf(this-&gt;buffer, index), this-&gt;count - index);</div>
<div class="disabled">					this-&gt;ReleaseItems(this-&gt;AddressOf(this-&gt;buffer, index), _count - (this-&gt;count - index));</div>
<div class="disabled">					uninitialized = true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;InitializeItemsByMove(this-&gt;AddressOf(this-&gt;buffer, this-&gt;count), this-&gt;AddressOf(this-&gt;buffer, this-&gt;count - _count), _count);</div>
<div class="disabled">					this-&gt;MoveItemsInTheSameBuffer(this-&gt;AddressOf(this-&gt;buffer, index + _count), this-&gt;AddressOf(this-&gt;buffer, index), this-&gt;count - index - _count);</div>
<div class="disabled">					uninitialized = false;</div>
<div class="disabled">				}</div>
<div class="disabled">				this-&gt;count = newCount;</div>
<div class="disabled">			}</div>

<div class="disabled">			void ReleaseUnnecessaryBuffer(vint previousCount)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (this-&gt;buffer &amp;&amp; this-&gt;count &lt; previousCount)</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;ReleaseItems(this-&gt;AddressOf(this-&gt;buffer, this-&gt;count), previousCount - this-&gt;count);</div>
<div class="disabled">				}</div>
<div class="disabled">				if (this-&gt;lessMemoryMode &amp;&amp; this-&gt;count &lt;= this-&gt;capacity / 2)</div>
<div class="disabled">				{</div>
<div class="disabled">					vint newCapacity = capacity * 5 / 8;</div>
<div class="disabled">					if (this-&gt;count &lt; newCapacity)</div>
<div class="disabled">					{</div>
<div class="disabled">						void* newBuffer = this-&gt;AllocateBuffer(newCapacity);</div>
<div class="disabled">						this-&gt;InitializeItemsByMove(this-&gt;AddressOf(newBuffer, 0), this-&gt;AddressOf(this-&gt;buffer, 0), this-&gt;count);</div>
<div class="disabled">						this-&gt;ReleaseItems(this-&gt;buffer, this-&gt;count);</div>
<div class="disabled">						this-&gt;DeallocateBuffer(this-&gt;buffer);</div>
<div class="disabled">						this-&gt;capacity = newCapacity;</div>
<div class="disabled">						this-&gt;buffer = newBuffer;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		public:</div>
<div class="disabled">			ListBase()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~ListBase()</div>
<div class="disabled">			{</div>
<div class="disabled">				this-&gt;ReleaseItems(this-&gt;buffer, this-&gt;count);</div>
<div class="disabled">				this-&gt;DeallocateBuffer(this-&gt;buffer);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Set a preference of using memory.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;mode&quot;&gt;Set to true (by default) to let the container efficiently reduce memory usage when necessary.&lt;/param&gt;</div>
<div class="disabled">			void SetLessMemoryMode(bool mode)</div>
<div class="disabled">			{</div>
<div class="disabled">				this-&gt;lessMemoryMode = mode;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Remove an element.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the element is removed.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The index of the element to remove.&lt;/param&gt;</div>
<div class="disabled">			bool RemoveAt(vint index)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint previousCount = this-&gt;count;</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt; this-&gt;count, L&quot;ListBase&lt;T, K&gt;::RemoveAt(vint)#Argument index not in range.&quot;);</div>
<div class="disabled">				this-&gt;MoveItemsInTheSameBuffer(this-&gt;AddressOf(this-&gt;buffer, index), this-&gt;AddressOf(this-&gt;buffer, index + 1), this-&gt;count - index - 1);</div>
<div class="disabled">				this-&gt;count--;</div>
<div class="disabled">				ReleaseUnnecessaryBuffer(previousCount);</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Remove elements.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the element is removed.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The index of the first element to remove.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;_count&quot;&gt;The number of elements to remove.&lt;/param&gt;</div>
<div class="disabled">			bool RemoveRange(vint index, vint _count)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint previousCount = this-&gt;count;</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt;= this-&gt;count, L&quot;ListBase&lt;T, K&gt;::RemoveRange(vint, vint)#Argument index not in range.&quot;);</div>
<div class="disabled">				CHECK_ERROR(index + _count &gt;= 0 &amp;&amp; index + _count &lt;= this-&gt;count, L&quot;ListBase&lt;T,K&gt;::RemoveRange(vint, vint)#Argument _count not in range.&quot;);</div>
<div class="disabled">				this-&gt;MoveItemsInTheSameBuffer(this-&gt;AddressOf(this-&gt;buffer, index), this-&gt;AddressOf(this-&gt;buffer, index + _count), this-&gt;count - index - _count);</div>
<div class="disabled">				this-&gt;count -= _count;</div>
<div class="disabled">				ReleaseUnnecessaryBuffer(previousCount);</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Remove all elements.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if all elements are removed.&lt;/returns&gt;</div>
<div class="disabled">			bool Clear()</div>
<div class="disabled">			{</div>
<div class="disabled">				vint previousCount = this-&gt;count;</div>
<div class="disabled">				this-&gt;count = 0;</div>
<div class="disabled">				if (lessMemoryMode)</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;capacity = 0;</div>
<div class="disabled">					this-&gt;ReleaseItems(this-&gt;buffer, this-&gt;count);</div>
<div class="disabled">					this-&gt;DeallocateBuffer(this-&gt;buffer);</div>
<div class="disabled">					this-&gt;buffer = nullptr;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					ReleaseUnnecessaryBuffer(previousCount);</div>
<div class="disabled">				}</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">List</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		/// &lt;summary&gt;List.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;K&quot;&gt;Type of the key type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename T, typename K = typename KeyType&lt;T&gt;::Type&gt;</div>
<div class="disabled">		class List : public ListBase&lt;T, K&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			/// &lt;summary&gt;Create a list.&lt;/summary&gt;</div>
<div class="disabled">			List()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Test does the list contain an item or not.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the list contains the specified item.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to test.&lt;/param&gt;</div>
<div class="disabled">			bool Contains(const K&amp; item)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return IndexOf(item) != -1;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the position of an item in this list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns the position. Returns -1 if not exists&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to find.&lt;/param&gt;</div>
<div class="disabled">			vint IndexOf(const K&amp; item)const</div>
<div class="disabled">			{</div>
<div class="disabled">				for (vint i = 0; i &lt; this-&gt;count; i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					if (this-&gt;ItemOf(i) == item)</div>
<div class="disabled">					{</div>
<div class="disabled">						return i;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				return -1;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Add an item at the end of the list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The index of the added item.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to add.&lt;/param&gt;</div>
<div class="disabled">			vint Add(const T&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				return Insert(this-&gt;count, item);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Add an item at the specified position.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The index of the added item.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The position of the item to add.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to add.&lt;/param&gt;</div>
<div class="disabled">			vint Insert(vint index, const T&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt;= this-&gt;count, L&quot;List&lt;T, K&gt;::Insert(vint, const T&amp;)#Argument index not in range.&quot;);</div>
<div class="disabled">				bool uninitialized = false;</div>
<div class="disabled">				this-&gt;MakeRoom(index, 1, uninitialized);</div>
<div class="disabled">				if (uninitialized)</div>
<div class="disabled">				{</div>
<div class="disabled">					new(&amp;this-&gt;ItemOf(index))T(item);</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;ItemOf(index) = item;</div>
<div class="disabled">				}</div>
<div class="disabled">				return index;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Remove an item.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the item is removed.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to remove.&lt;/param&gt;</div>
<div class="disabled">			bool Remove(const K&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint index = IndexOf(item);</div>
<div class="disabled">				if (index &gt;= 0 &amp;&amp; index &lt; this-&gt;count)</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;RemoveAt(index);</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Replace an item.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The position of the item.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The new item to put into the array.&lt;/param&gt;</div>
<div class="disabled">			bool Set(vint index, const T&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt; this-&gt;count, L&quot;List&lt;T, K&gt;::Set(vint)#Argument index not in range.&quot;);</div>
<div class="disabled">				this-&gt;ItemOf(index) = item;</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the reference to the specified element.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The reference to the specified element.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The index of the element.&lt;/param&gt;</div>
<div class="disabled">			using ListBase&lt;T, K&gt;::operator[];</div>
<div class="disabled">			T&amp; operator[](vint index)</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(index &gt;= 0 &amp;&amp; index &lt; this-&gt;count, L&quot;List&lt;T, K&gt;::operator[](vint)#Argument index not in range.&quot;);</div>
<div class="disabled">				return this-&gt;ItemOf(index);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">SortedList</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		/// &lt;summary&gt;List that keeps everything in order.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;Type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;K&quot;&gt;Type of the key type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename T, typename K = typename KeyType&lt;T&gt;::Type&gt;</div>
<div class="disabled">		class SortedList : public ListBase&lt;T, K&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>

<div class="disabled">			/// &lt;summary&gt;Get the position of an item in this list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;Key&quot;&gt;Type of the item to find.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns the position. Returns -1 if not exists&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to find.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;Returns the last index.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename Key&gt;</div>
<div class="disabled">			vint IndexOfInternal(const Key&amp; item, vint&amp; index)const</div>
<div class="disabled">			{</div>
<div class="disabled">				vint start = 0;</div>
<div class="disabled">				vint end = this-&gt;count - 1;</div>
<div class="disabled">				index = -1;</div>
<div class="disabled">				while (start &lt;= end)</div>
<div class="disabled">				{</div>
<div class="disabled">					index = start + (end - start) / 2;</div>
<div class="disabled">					if (this-&gt;ItemOf(index) == item)</div>
<div class="disabled">					{</div>
<div class="disabled">						return index;</div>
<div class="disabled">					}</div>
<div class="disabled">					else if (this-&gt;ItemOf(index) &gt; item)</div>
<div class="disabled">					{</div>
<div class="disabled">						end = index - 1;</div>
<div class="disabled">					}</div>
<div class="disabled">					else</div>
<div class="disabled">					{</div>
<div class="disabled">						start = index + 1;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				return -1;</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Insert(vint index, const T&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				bool uninitialized = false;</div>
<div class="disabled">				this-&gt;MakeRoom(index, 1, uninitialized);</div>
<div class="disabled">				if (uninitialized)</div>
<div class="disabled">				{</div>
<div class="disabled">					new(&amp;this-&gt;ItemOf(index))T(item);</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;ItemOf(index) = item;</div>
<div class="disabled">				}</div>
<div class="disabled">				return index;</div>
<div class="disabled">			}</div>
<div class="disabled">		public:</div>
<div class="disabled">			/// &lt;summary&gt;Create a list.&lt;/summary&gt;</div>
<div class="disabled">			SortedList()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Test does the list contain an item or not.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the list contains the specified item.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to test.&lt;/param&gt;</div>
<div class="disabled">			bool Contains(const K&amp; item)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return IndexOf(item) != -1;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the position of an item in this list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns the position. Returns -1 if not exists&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to find.&lt;/param&gt;</div>
<div class="disabled">			vint IndexOf(const K&amp; item)const</div>
<div class="disabled">			{</div>
<div class="disabled">				vint outputIndex = -1;</div>
<div class="disabled">				return IndexOfInternal&lt;K&gt;(item, outputIndex);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Add an item at a correct position to keep everying in order.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The index of the added item.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to add.&lt;/param&gt;</div>
<div class="disabled">			vint Add(const T&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (ArrayBase&lt;T&gt;::count == 0)</div>
<div class="disabled">				{</div>
<div class="disabled">					return Insert(0, item);</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					vint outputIndex = -1;</div>
<div class="disabled">					IndexOfInternal&lt;T&gt;(item, outputIndex);</div>
<div class="disabled">					CHECK_ERROR(outputIndex &gt;= 0 &amp;&amp; outputIndex &lt; this-&gt;count, L&quot;SortedList&lt;T, K&gt;::Add(const T&amp;)#Internal error, index not in range.&quot;);</div>
<div class="disabled">					if (this-&gt;ItemOf(outputIndex) &lt; item)</div>
<div class="disabled">					{</div>
<div class="disabled">						outputIndex++;</div>
<div class="disabled">					}</div>
<div class="disabled">					return Insert(outputIndex, item);</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Remove an item.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the item is removed.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;item&quot;&gt;The item to remove.&lt;/param&gt;</div>
<div class="disabled">			bool Remove(const K&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint index = IndexOf(item);</div>
<div class="disabled">				if (index &gt;= 0 &amp;&amp; index &lt; ArrayBase&lt;T&gt;::count)</div>
<div class="disabled">				{</div>
<div class="disabled">					this-&gt;RemoveAt(index);</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Special Containers</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class PushOnlyAllocator : public Object, private NotCopyable</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			vint							blockSize;</div>
<div class="disabled">			vint							allocatedSize;</div>
<div class="disabled">			List&lt;T*&gt;						blocks;</div>

<div class="disabled">		public:</div>
<div class="disabled">			PushOnlyAllocator(vint _blockSize = 65536)</div>
<div class="disabled">				:blockSize(_blockSize)</div>
<div class="disabled">				, allocatedSize(0)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~PushOnlyAllocator()</div>
<div class="disabled">			{</div>
<div class="disabled">				for (vint i = 0; i &lt; blocks.Count(); i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					delete[] blocks[i];</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			T* Get(vint index)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (index &gt;= allocatedSize)</div>
<div class="disabled">				{</div>
<div class="disabled">					return 0;</div>
<div class="disabled">				}</div>
<div class="disabled">				vint row = index / blockSize;</div>
<div class="disabled">				vint column = index % blockSize;</div>
<div class="disabled">				return &amp;blocks[row][column];</div>
<div class="disabled">			}</div>

<div class="disabled">			T* Create()</div>
<div class="disabled">			{</div>
<div class="disabled">				if (allocatedSize == blocks.Count()*blockSize)</div>
<div class="disabled">				{</div>
<div class="disabled">					blocks.Add(new T[blockSize]);</div>
<div class="disabled">				}</div>
<div class="disabled">				vint index = allocatedSize++;</div>
<div class="disabled">				return Get(index);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		namespace bom_helper</div>
<div class="disabled">		{</div>
<div class="disabled">			struct TreeNode</div>
<div class="disabled">			{</div>
<div class="disabled">				TreeNode*					nodes[4];</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;vint Index = 4&gt;</div>
<div class="disabled">			struct Accessor</div>
<div class="disabled">			{</div>
<div class="disabled">				static __forceinline void* Get(TreeNode* root, vuint8_t index)</div>
<div class="disabled">				{</div>
<div class="disabled">					if (!root)</div>
<div class="disabled">					{</div>
<div class="disabled">						return 0;</div>
<div class="disabled">					}</div>
<div class="disabled">					vint fragmentIndex = (index &gt;&gt; (2 * (Index - 1))) % 4;</div>
<div class="disabled">					TreeNode* fragmentRoot = root-&gt;nodes[fragmentIndex];</div>
<div class="disabled">					return fragmentRoot ? Accessor&lt;Index - 1&gt;::Get(fragmentRoot, index) : 0;</div>
<div class="disabled">				}</div>

<div class="disabled">				static __forceinline void Set(TreeNode*&amp; root, vuint8_t index, void* value, PushOnlyAllocator&lt;TreeNode&gt;&amp; allocator)</div>
<div class="disabled">				{</div>
<div class="disabled">					if (!root)</div>
<div class="disabled">					{</div>
<div class="disabled">						root = allocator.Create();</div>
<div class="disabled">						memset(root-&gt;nodes, 0, sizeof(root-&gt;nodes));</div>
<div class="disabled">					}</div>
<div class="disabled">					vint fragmentIndex = (index &gt;&gt; (2 * (Index - 1))) % 4;</div>
<div class="disabled">					TreeNode*&amp; fragmentRoot = root-&gt;nodes[fragmentIndex];</div>
<div class="disabled">					Accessor&lt;Index - 1&gt;::Set(fragmentRoot, index, value, allocator);</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;&gt;</div>
<div class="disabled">			struct Accessor&lt;0&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static __forceinline void* Get(TreeNode* root, vuint8_t index)</div>
<div class="disabled">				{</div>
<div class="disabled">					return (void*)root;</div>
<div class="disabled">				}</div>

<div class="disabled">				static __forceinline void Set(TreeNode*&amp; root, vuint8_t index, void* value, PushOnlyAllocator&lt;TreeNode&gt;&amp; allocator)</div>
<div class="disabled">				{</div>
<div class="disabled">					((void*&amp;)root) = value;</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class ByteObjectMap : public Object, private NotCopyable</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			typedef PushOnlyAllocator&lt;bom_helper::TreeNode&gt;			Allocator;</div>
<div class="disabled">		protected:</div>
<div class="disabled">			bom_helper::TreeNode*			root;</div>

<div class="disabled">		public:</div>
<div class="disabled">			ByteObjectMap()</div>
<div class="disabled">				:root(0)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~ByteObjectMap()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			T* Get(vuint8_t index)</div>
<div class="disabled">			{</div>
<div class="disabled">				return (T*)bom_helper::Accessor&lt;&gt;::Get(root, index);</div>
<div class="disabled">			}</div>

<div class="disabled">			void Set(vuint8_t index, T* value, Allocator&amp; allocator)</div>
<div class="disabled">			{</div>
<div class="disabled">				bom_helper::Accessor&lt;&gt;::Set(root, index, value, allocator);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Random Access</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		namespace randomaccess_internal</div>
<div class="disabled">		{</div>
<div class="disabled">			template&lt;typename T, typename K&gt;</div>
<div class="disabled">			struct RandomAccessable&lt;Array&lt;T, K&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static const bool							CanRead = true;</div>
<div class="disabled">				static const bool							CanResize = true;</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;typename T, typename K&gt;</div>
<div class="disabled">			struct RandomAccessable&lt;List&lt;T, K&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static const bool							CanRead = true;</div>
<div class="disabled">				static const bool							CanResize = false;</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;typename T, typename K&gt;</div>
<div class="disabled">			struct RandomAccessable&lt;SortedList&lt;T, K&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static const bool							CanRead = true;</div>
<div class="disabled">				static const bool							CanResize = false;</div>
<div class="disabled">			};</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#ifdef VCZH_CHECK_MEMORY_LEAKS_NEW</div>
<div class="disabled">#define new VCZH_CHECK_MEMORY_LEAKS_NEW</div>
<div class="disabled">#endif</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONCOPYFROM.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONCOPYFROM</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONCOPYFROM</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Copy Functions for Containers</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		namespace copyfrom_internal</div>
<div class="disabled">		{</div>
<div class="disabled">			using namespace randomaccess_internal;</div>

<div class="disabled">			template&lt;typename Ds, typename Ss, bool DsRA, bool SsRA&gt;</div>
<div class="disabled">			struct CopyFromAlgorithm</div>
<div class="disabled">			{</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;typename Ds, typename Ss&gt;</div>
<div class="disabled">			struct CopyFromAlgorithm&lt;Ds, Ss, true, true&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static void Perform(Ds&amp; ds, const Ss&amp; ss, bool append)</div>
<div class="disabled">				{</div>
<div class="disabled">					vint copyCount=RandomAccess&lt;Ss&gt;::GetCount(ss);</div>
<div class="disabled">					vint index=(append?RandomAccess&lt;Ds&gt;::GetCount(ds):0);</div>
<div class="disabled">					vint resizeCount=index+copyCount;</div>
<div class="disabled">					RandomAccess&lt;Ds&gt;::SetCount(ds, resizeCount);</div>
<div class="disabled">					for(vint i=0;i&lt;copyCount;i++)</div>
<div class="disabled">					{</div>
<div class="disabled">						RandomAccess&lt;Ds&gt;::SetValue(ds, index+i, RandomAccess&lt;Ss&gt;::GetValue(ss, i));</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;typename Ds, typename Ss&gt;</div>
<div class="disabled">			struct CopyFromAlgorithm&lt;Ds, Ss, false, true&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static void Perform(Ds&amp; ds, const Ss&amp; ss, bool append)</div>
<div class="disabled">				{</div>
<div class="disabled">					if(!append)</div>
<div class="disabled">					{</div>
<div class="disabled">						ds.Clear();</div>
<div class="disabled">					}</div>
<div class="disabled">					vint copyCount=RandomAccess&lt;Ss&gt;::GetCount(ss);</div>
<div class="disabled">					for(vint i=0;i&lt;copyCount;i++)</div>
<div class="disabled">					{</div>
<div class="disabled">						RandomAccess&lt;Ds&gt;::AppendValue(ds, RandomAccess&lt;Ss&gt;::GetValue(ss, i));</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;typename Ds, typename Ss&gt;</div>
<div class="disabled">			struct CopyFromAlgorithm&lt;Ds, Ss, true, false&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static void Perform(Ds&amp; ds, const Ss&amp; ss, bool append)</div>
<div class="disabled">				{</div>
<div class="disabled">					Ptr&lt;IEnumerator&lt;typename Ss::ElementType&gt;&gt; enumerator;</div>
<div class="disabled">					vint copyCount=0;</div>

<div class="disabled">					enumerator=ss.CreateEnumerator();</div>
<div class="disabled">					while(enumerator-&gt;Next())</div>
<div class="disabled">					{</div>
<div class="disabled">						copyCount++;</div>
<div class="disabled">					}</div>

<div class="disabled">					vint index=(append?RandomAccess&lt;Ds&gt;::GetCount(ds):0);</div>
<div class="disabled">					vint resizeCount=index+copyCount;</div>
<div class="disabled">					RandomAccess&lt;Ds&gt;::SetCount(ds, resizeCount);</div>

<div class="disabled">					enumerator=ss.CreateEnumerator();</div>
<div class="disabled">					while(enumerator-&gt;Next())</div>
<div class="disabled">					{</div>
<div class="disabled">						RandomAccess&lt;Ds&gt;::SetValue(ds, index++, enumerator-&gt;Current());</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;typename Ds, typename Ss&gt;</div>
<div class="disabled">			struct CopyFromAlgorithm&lt;Ds, Ss, false, false&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static void Perform(Ds&amp; ds, const Ss&amp; ss, bool append)</div>
<div class="disabled">				{</div>
<div class="disabled">					if(!append)</div>
<div class="disabled">					{</div>
<div class="disabled">						ds.Clear();</div>
<div class="disabled">					}</div>
<div class="disabled">					Ptr&lt;IEnumerator&lt;typename Ss::ElementType&gt;&gt; enumerator=ss.CreateEnumerator();</div>
<div class="disabled">					while(enumerator-&gt;Next())</div>
<div class="disabled">					{</div>
<div class="disabled">						RandomAccess&lt;Ds&gt;::AppendValue(ds, enumerator-&gt;Current());</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			template&lt;typename T&gt;</div>
<div class="disabled">			struct Slice</div>
<div class="disabled">			{</div>
<div class="disabled">				const T*	items;</div>
<div class="disabled">				vint		count;</div>
<div class="disabled">			};</div>
<div class="disabled">		}</div>

<div class="disabled">		namespace randomaccess_internal</div>
<div class="disabled">		{</div>
<div class="disabled">			template&lt;typename T&gt;</div>
<div class="disabled">			struct RandomAccessable&lt;copyfrom_internal::Slice&lt;T&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static const bool							CanRead = true;</div>
<div class="disabled">				static const bool							CanResize = true;</div>
<div class="disabled">			};</div>
<div class="disabled">		</div>
<div class="disabled">			template&lt;typename T&gt;</div>
<div class="disabled">			struct RandomAccess&lt;copyfrom_internal::Slice&lt;T&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static vint GetCount(const copyfrom_internal::Slice&lt;T&gt;&amp; t)</div>
<div class="disabled">				{</div>
<div class="disabled">					return t.count;</div>
<div class="disabled">				}</div>

<div class="disabled">				static const T&amp; GetValue(const copyfrom_internal::Slice&lt;T&gt;&amp; t, vint index)</div>
<div class="disabled">				{</div>
<div class="disabled">					return t.items[index];</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy containers.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;Ds&quot;&gt;Type of the destination container.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;Ss&quot;&gt;Type of the source container.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;ds&quot;&gt;The destination container.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;ss&quot;&gt;The source container.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;append&quot;&gt;Set to false to delete everything in the destination container before copying.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename Ds, typename Ss&gt;</div>
<div class="disabled">		void CopyFrom(Ds&amp; ds, const Ss&amp; ss, bool append=false)</div>
<div class="disabled">		{</div>
<div class="disabled">			copyfrom_internal::CopyFromAlgorithm&lt;Ds, Ss, randomaccess_internal::RandomAccessable&lt;Ds&gt;::CanResize, randomaccess_internal::RandomAccessable&lt;Ss&gt;::CanRead&gt;::Perform(ds, ss, append);</div>
<div class="disabled">		}</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Copy containers.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;Ds&quot;&gt;Type of the destination container.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;S&quot;&gt;Type of the elements in the source container.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;ds&quot;&gt;The destination container.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;buffer&quot;&gt;Pointer to the source array.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;count&quot;&gt;The number of elements to copy.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;append&quot;&gt;Set to false to delete everything in the destination container before copying.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename Ds, typename S&gt;</div>
<div class="disabled">		void CopyFrom(Ds&amp; ds, const S* buffer, vint count, bool append=false)</div>
<div class="disabled">		{</div>
<div class="disabled">			copyfrom_internal::Slice&lt;S&gt; slice={buffer, count};</div>
<div class="disabled">			CopyFrom(ds, slice, append);</div>
<div class="disabled">		}</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Copy containers.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;Ds&quot;&gt;Type of the destination container.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;S&quot;&gt;Type of the elements in the source container.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;ds&quot;&gt;The destination container.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;begin&quot;&gt;Pointer to the first element in the source array.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;end&quot;&gt;Pointer to the element after the last element in the source array.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;append&quot;&gt;Set to false to delete everything in the destination container before copying.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename Ds, typename S&gt;</div>
<div class="disabled">		void CopyFrom(Ds&amp; ds, const S* begin, const S* end, bool append=false)</div>
<div class="disabled">		{</div>
<div class="disabled">			copyfrom_internal::Slice&lt;S&gt; slice={begin, end-begin};</div>
<div class="disabled">			CopyFrom(ds, slice, append);</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONENUMERABLE.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONENUMERABLE</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONENUMERABLE</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">EmptyEnumerable</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class EmptyEnumerable : public Object, public IEnumerable&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		private:</div>
<div class="disabled">			class Enumerator : public Object, public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">				{</div>
<div class="disabled">					return new Enumerator;</div>
<div class="disabled">				}</div>

<div class="disabled">				const T&amp; Current()const override</div>
<div class="disabled">				{</div>
<div class="disabled">					CHECK_FAIL(L&quot;EmptyEnumerable&lt;T&gt;::Enumerator::Current()#This collection is empty.&quot;);</div>
<div class="disabled">				}</div>

<div class="disabled">				vint Index()const override</div>
<div class="disabled">				{</div>
<div class="disabled">					return -1;</div>
<div class="disabled">				}</div>

<div class="disabled">				bool Next()override</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>

<div class="disabled">				void Reset()override</div>
<div class="disabled">				{</div>
<div class="disabled">				}</div>

<div class="disabled">				bool Evaluated()const override</div>
<div class="disabled">				{</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">		public:</div>
<div class="disabled">			IEnumerator&lt;T&gt;* CreateEnumerator()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new Enumerator;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">RangeEnumerator</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class RangeEnumerator : public Object, public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			T			start;</div>
<div class="disabled">			T			count;</div>
<div class="disabled">			T			current;</div>
<div class="disabled">		public:</div>
<div class="disabled">			RangeEnumerator(T _start, T _count, T _current)</div>
<div class="disabled">				:start(_start)</div>
<div class="disabled">				,count(_count)</div>
<div class="disabled">				,current(_current)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			RangeEnumerator(T _start, T _count)</div>
<div class="disabled">				:start(_start)</div>
<div class="disabled">				,count(_count)</div>
<div class="disabled">				,current(_start-1)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new RangeEnumerator(start, count, current);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return current;</div>
<div class="disabled">			}</div>

<div class="disabled">			T Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return current-start;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				if(start-1&lt;=current &amp;&amp; current&lt;start+count-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					current++;</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				current=start-1;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Evaluated()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">ContainerEnumerator</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T, typename TContainer&gt;</div>
<div class="disabled">		class ContainerEnumerator : public Object, public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		private:</div>
<div class="disabled">			Ptr&lt;TContainer&gt;					container;</div>
<div class="disabled">			vint							index;</div>

<div class="disabled">		public:</div>
<div class="disabled">			ContainerEnumerator(Ptr&lt;TContainer&gt; _container, vint _index=-1)</div>
<div class="disabled">			{</div>
<div class="disabled">				container=_container;</div>
<div class="disabled">				index=_index;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new ContainerEnumerator(container, index);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return container-&gt;Get(index);</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return index;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				index++;</div>
<div class="disabled">				return index&gt;=0 &amp;&amp; index&lt;container-&gt;Count();</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				index=-1;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Evaluated()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">CompareEnumerable</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T, typename U&gt;</div>
<div class="disabled">		vint CompareEnumerable(const IEnumerable&lt;T&gt;&amp; a, const IEnumerable&lt;U&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			Ptr&lt;IEnumerator&lt;T&gt;&gt; ator=a.CreateEnumerator();</div>
<div class="disabled">			Ptr&lt;IEnumerator&lt;U&gt;&gt; btor=b.CreateEnumerator();</div>
<div class="disabled">			while(true)</div>
<div class="disabled">			{</div>
<div class="disabled">				bool a=ator-&gt;Next();</div>
<div class="disabled">				bool b=btor-&gt;Next();</div>
<div class="disabled">				if(a&amp;&amp;!b) return 1;</div>
<div class="disabled">				if(!a&amp;&amp;b) return -1;</div>
<div class="disabled">				if(!a&amp;&amp;!b) break;</div>

<div class="disabled">				const T&amp; ac=ator-&gt;Current();</div>
<div class="disabled">				const U&amp; bc=btor-&gt;Current();</div>
<div class="disabled">				if(ac&lt;bc)</div>
<div class="disabled">				{</div>
<div class="disabled">					return -1;</div>
<div class="disabled">				}</div>
<div class="disabled">				else if(ac&gt;bc)</div>
<div class="disabled">				{</div>
<div class="disabled">					return 1;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct SortedListOperations</div>
<div class="disabled">		{</div>
<div class="disabled">			static bool Contains(const SortedList&lt;T&gt;&amp; items, const T&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				return items.Contains(item);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		struct SortedListOperations&lt;Ptr&lt;T&gt;&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">			static bool Contains(const SortedList&lt;Ptr&lt;T&gt;&gt;&amp; items, const Ptr&lt;T&gt;&amp; item)</div>
<div class="disabled">			{</div>
<div class="disabled">				return items.Contains(item.Obj());</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONSELECT.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONSELECT</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONSELECT</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Select</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T, typename K&gt;</div>
<div class="disabled">		class SelectEnumerator : public virtual IEnumerator&lt;K&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;T&gt;*		enumerator;</div>
<div class="disabled">			Func&lt;K(T)&gt;			selector;</div>
<div class="disabled">			K					current;</div>
<div class="disabled">		public:</div>
<div class="disabled">			SelectEnumerator(IEnumerator&lt;T&gt;* _enumerator, const Func&lt;K(T)&gt;&amp; _selector, K _current=K())</div>
<div class="disabled">				:enumerator(_enumerator)</div>
<div class="disabled">				,selector(_selector)</div>
<div class="disabled">				,current(_current)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~SelectEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;K&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new SelectEnumerator(enumerator-&gt;Clone(), selector, current);</div>
<div class="disabled">			}</div>

<div class="disabled">			const K&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return current;</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Index();</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				if(enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					current=selector(enumerator-&gt;Current());</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator-&gt;Reset();</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONWHERE.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONWHERE</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONWHERE</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">Where</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class WhereEnumerator : public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;T&gt;*			enumerator;</div>
<div class="disabled">			Func&lt;bool(T)&gt;			selector;</div>
<div class="disabled">			vint					index;</div>

<div class="disabled">		public:</div>
<div class="disabled">			WhereEnumerator(IEnumerator&lt;T&gt;* _enumerator, const Func&lt;bool(T)&gt;&amp; _selector, vint _index=-1)</div>
<div class="disabled">				:enumerator(_enumerator)</div>
<div class="disabled">				,selector(_selector)</div>
<div class="disabled">				,index(_index)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~WhereEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new WhereEnumerator(enumerator-&gt;Clone(), selector, index);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Current();</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return index;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				while(enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					if(selector(enumerator-&gt;Current()))</div>
<div class="disabled">					{</div>
<div class="disabled">						index++;</div>
<div class="disabled">						return true;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				return false;</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator-&gt;Reset();</div>
<div class="disabled">				index=-1;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONCONCAT.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONCONCAT</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONCONCAT</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Concat</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class ConcatEnumerator : public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;T&gt;*					enumerator1;</div>
<div class="disabled">			IEnumerator&lt;T&gt;*					enumerator2;</div>
<div class="disabled">			vint							index;</div>
<div class="disabled">			bool							turned;</div>
<div class="disabled">		public:</div>
<div class="disabled">			ConcatEnumerator(IEnumerator&lt;T&gt;* _enumerator1, IEnumerator&lt;T&gt;* _enumerator2, vint _index=-1, bool _turned=false)</div>
<div class="disabled">				:enumerator1(_enumerator1)</div>
<div class="disabled">				,enumerator2(_enumerator2)</div>
<div class="disabled">				,index(_index)</div>
<div class="disabled">				,turned(_turned)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~ConcatEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator1;</div>
<div class="disabled">				delete enumerator2;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new ConcatEnumerator(enumerator1-&gt;Clone(), enumerator2-&gt;Clone(), index, turned);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				if(turned)</div>
<div class="disabled">				{</div>
<div class="disabled">					return enumerator2-&gt;Current();</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return enumerator1-&gt;Current();</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return index;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				index++;</div>
<div class="disabled">				if(turned)</div>
<div class="disabled">				{</div>
<div class="disabled">					return enumerator2-&gt;Next();</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					if(enumerator1-&gt;Next())</div>
<div class="disabled">					{</div>
<div class="disabled">						return true;</div>
<div class="disabled">					}</div>
<div class="disabled">					else</div>
<div class="disabled">					{</div>
<div class="disabled">						turned=true;</div>
<div class="disabled">						return enumerator2-&gt;Next();</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator1-&gt;Reset();</div>
<div class="disabled">				enumerator2-&gt;Reset();</div>
<div class="disabled">				index=-1;</div>
<div class="disabled">				turned=false;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Evaluated()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator1-&gt;Evaluated() &amp;&amp; enumerator2-&gt;Evaluated();</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONSEQUENCE.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONSEQUENCE</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONSEQUENCE</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Take</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class TakeEnumerator : public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;T&gt;*			enumerator;</div>
<div class="disabled">			vint					count;</div>
<div class="disabled">		public:</div>
<div class="disabled">			TakeEnumerator(IEnumerator&lt;T&gt;* _enumerator, vint _count)</div>
<div class="disabled">				:enumerator(_enumerator)</div>
<div class="disabled">				,count(_count)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~TakeEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new TakeEnumerator(enumerator-&gt;Clone(), count);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Current();</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Index();</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				if(enumerator-&gt;Index()&gt;=count-1) return false;</div>
<div class="disabled">				return enumerator-&gt;Next();</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator-&gt;Reset();</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Evaluated()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Evaluated();</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Skip</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class SkipEnumerator : public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;T&gt;*			enumerator;</div>
<div class="disabled">			vint					count;</div>
<div class="disabled">			bool					skipped;</div>
<div class="disabled">		public:</div>
<div class="disabled">			SkipEnumerator(IEnumerator&lt;T&gt;* _enumerator, vint _count, bool _skipped=false)</div>
<div class="disabled">				:enumerator(_enumerator)</div>
<div class="disabled">				,count(_count)</div>
<div class="disabled">				,skipped(_skipped)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~SkipEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new SkipEnumerator(enumerator-&gt;Clone(), count, skipped);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Current();</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Index()-count;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				if(!skipped)</div>
<div class="disabled">				{</div>
<div class="disabled">					skipped=true;</div>
<div class="disabled">					for(vint i=0;i&lt;count;i++)</div>
<div class="disabled">					{</div>
<div class="disabled">						if(!enumerator-&gt;Next())</div>
<div class="disabled">						{</div>
<div class="disabled">							return false;</div>
<div class="disabled">						}</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				return enumerator-&gt;Next();</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator-&gt;Reset();</div>
<div class="disabled">				skipped=false;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Evaluated()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Evaluated();</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Repeat</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class RepeatEnumerator : public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;T&gt;*			enumerator;</div>
<div class="disabled">			vint					count;</div>
<div class="disabled">			vint					index;</div>
<div class="disabled">			vint					repeatedCount;</div>
<div class="disabled">		public:</div>
<div class="disabled">			RepeatEnumerator(IEnumerator&lt;T&gt;* _enumerator, vint _count, vint _index=-1, vint _repeatedCount=0)</div>
<div class="disabled">				:enumerator(_enumerator)</div>
<div class="disabled">				,count(_count)</div>
<div class="disabled">				,index(_index)</div>
<div class="disabled">				,repeatedCount(_repeatedCount)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~RepeatEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new RepeatEnumerator(enumerator-&gt;Clone(), count, index, repeatedCount);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Current();</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return index;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				while(repeatedCount&lt;count)</div>
<div class="disabled">				{</div>
<div class="disabled">					if(enumerator-&gt;Next())</div>
<div class="disabled">					{</div>
<div class="disabled">						index++;</div>
<div class="disabled">						return true;</div>
<div class="disabled">					}</div>
<div class="disabled">					repeatedCount++;</div>
<div class="disabled">					enumerator-&gt;Reset();</div>
<div class="disabled">				}</div>
<div class="disabled">				return false;</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator-&gt;Reset();</div>
<div class="disabled">				index=-1;</div>
<div class="disabled">				repeatedCount=0;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Evaluated()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Evaluated();</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Distinct</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class DistinctEnumerator : public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;T&gt;*		enumerator;</div>
<div class="disabled">			SortedList&lt;T&gt;		distinct;</div>
<div class="disabled">			T					lastValue;</div>

<div class="disabled">		public:</div>
<div class="disabled">			DistinctEnumerator(IEnumerator&lt;T&gt;* _enumerator)</div>
<div class="disabled">				:enumerator(_enumerator)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			DistinctEnumerator(const DistinctEnumerator&amp; _enumerator)</div>
<div class="disabled">				:lastValue(_enumerator.lastValue)</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator=_enumerator.enumerator-&gt;Clone();</div>
<div class="disabled">				CopyFrom(distinct, _enumerator.distinct);</div>
<div class="disabled">			}</div>

<div class="disabled">			~DistinctEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new DistinctEnumerator(*this);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return lastValue;</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return distinct.Count()-1;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				while(enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					const T&amp; current=enumerator-&gt;Current();</div>
<div class="disabled">					if(!SortedListOperations&lt;T&gt;::Contains(distinct, current))</div>
<div class="disabled">					{</div>
<div class="disabled">						lastValue=current;</div>
<div class="disabled">						distinct.Add(current);</div>
<div class="disabled">						return true;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				return false;</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator-&gt;Reset();</div>
<div class="disabled">				distinct.Clear();</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Reverse</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class ReverseEnumerator : public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			List&lt;T&gt;						cache;</div>
<div class="disabled">			vint						index;</div>
<div class="disabled">		public:</div>
<div class="disabled">			ReverseEnumerator(const IEnumerable&lt;T&gt;&amp; enumerable)</div>
<div class="disabled">				:index(-1)</div>
<div class="disabled">			{</div>
<div class="disabled">				CopyFrom(cache, enumerable);</div>
<div class="disabled">			}</div>

<div class="disabled">			ReverseEnumerator(const ReverseEnumerator&amp; _enumerator)</div>
<div class="disabled">				:index(_enumerator.index)</div>
<div class="disabled">			{</div>
<div class="disabled">				CopyFrom(cache, _enumerator.cache);</div>
<div class="disabled">			}</div>

<div class="disabled">			~ReverseEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new ReverseEnumerator(*this);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return cache.Get(cache.Count()-1-index);</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return index;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				index++;</div>
<div class="disabled">				return index&lt;cache.Count();</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				index=-1;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Evaluated()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">FromIterator</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T, typename I&gt;</div>
<div class="disabled">		class FromIteratorEnumerable : public Object, public IEnumerable&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		private:</div>
<div class="disabled">			class Enumerator : public Object, public IEnumerator&lt;T&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">			private:</div>
<div class="disabled">				I				begin;</div>
<div class="disabled">				I				end;</div>
<div class="disabled">				I				current;</div>

<div class="disabled">			public:</div>
<div class="disabled">				Enumerator(I _begin, I _end, I _current)</div>
<div class="disabled">					:begin(_begin)</div>
<div class="disabled">					,end(_end)</div>
<div class="disabled">					,current(_current)</div>
<div class="disabled">				{</div>
<div class="disabled">				}</div>

<div class="disabled">				IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">				{</div>
<div class="disabled">					return new Enumerator(begin, end, current);</div>
<div class="disabled">				}</div>

<div class="disabled">				const T&amp; Current()const override</div>
<div class="disabled">				{</div>
<div class="disabled">					return *current;</div>
<div class="disabled">				}</div>

<div class="disabled">				vint Index()const override</div>
<div class="disabled">				{</div>
<div class="disabled">					return current-begin;</div>
<div class="disabled">				}</div>

<div class="disabled">				bool Next()override</div>
<div class="disabled">				{</div>
<div class="disabled">					current++;</div>
<div class="disabled">					return begin&lt;=current &amp;&amp; current&lt;end;</div>
<div class="disabled">				}</div>

<div class="disabled">				void Reset()override</div>
<div class="disabled">				{</div>
<div class="disabled">					current=begin-1;</div>
<div class="disabled">				}</div>

<div class="disabled">				bool Evaluated()const override</div>
<div class="disabled">				{</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">		private:</div>
<div class="disabled">			I					begin;</div>
<div class="disabled">			I					end;</div>
<div class="disabled">		public:</div>
<div class="disabled">			IEnumerator&lt;T&gt;* CreateEnumerator()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new Enumerator(begin, end, begin-1);</div>
<div class="disabled">			}</div>

<div class="disabled">			FromIteratorEnumerable(I _begin, I _end)</div>
<div class="disabled">				:begin(_begin)</div>
<div class="disabled">				,end(_end)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			FromIteratorEnumerable(const FromIteratorEnumerable&lt;T, I&gt;&amp; enumerable)</div>
<div class="disabled">				:begin(enumerable.begin)</div>
<div class="disabled">				,end(enumerable.end)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class FromIterator</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			template&lt;typename I&gt;</div>
<div class="disabled">			static FromIteratorEnumerable&lt;T, I&gt; Wrap(I begin, I end)</div>
<div class="disabled">			{</div>
<div class="disabled">				return FromIteratorEnumerable&lt;T, I&gt;(begin, end);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		FromIteratorEnumerable&lt;T, const T*&gt; FromPointer(const T* begin, const T* end)</div>
<div class="disabled">		{</div>
<div class="disabled">			return FromIteratorEnumerable&lt;T, const T*&gt;(begin, end);</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T, int size&gt;</div>
<div class="disabled">		FromIteratorEnumerable&lt;T, T*&gt; FromArray(T (&amp;items)[size])</div>
<div class="disabled">		{</div>
<div class="disabled">			return FromIteratorEnumerable&lt;T, T*&gt;(&amp;items[0], &amp;items[size]);</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONSET.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONSET</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONSET</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Intersect/Except</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T, bool Intersect&gt;</div>
<div class="disabled">		class IntersectExceptEnumerator : public virtual IEnumerator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;T&gt;*				enumerator;</div>
<div class="disabled">			SortedList&lt;T&gt;				reference;</div>
<div class="disabled">			vint						index;</div>

<div class="disabled">		public:</div>
<div class="disabled">			IntersectExceptEnumerator(IEnumerator&lt;T&gt;* _enumerator, const IEnumerable&lt;T&gt;&amp; _reference)</div>
<div class="disabled">				:enumerator(_enumerator)</div>
<div class="disabled">				,index(-1)</div>
<div class="disabled">			{</div>
<div class="disabled">				CopyFrom(reference, _reference);</div>
<div class="disabled">			}</div>

<div class="disabled">			IntersectExceptEnumerator(const IntersectExceptEnumerator&amp; _enumerator)</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator=_enumerator.enumerator-&gt;Clone();</div>
<div class="disabled">				CopyFrom(reference, _enumerator.reference);</div>
<div class="disabled">				index=_enumerator.index;</div>
<div class="disabled">			}</div>

<div class="disabled">			~IntersectExceptEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new IntersectExceptEnumerator(*this);</div>
<div class="disabled">			}</div>

<div class="disabled">			const T&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator-&gt;Current();</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return index;</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				while(enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					if(SortedListOperations&lt;T&gt;::Contains(reference, enumerator-&gt;Current())==Intersect)</div>
<div class="disabled">					{</div>
<div class="disabled">						index++;</div>
<div class="disabled">						return true;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				return false;</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator-&gt;Reset();</div>
<div class="disabled">				index=-1;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONPAIR.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONPAIR</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONPAIR</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Pairwise</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename S, typename T&gt;</div>
<div class="disabled">		class PairwiseEnumerator : public virtual IEnumerator&lt;Pair&lt;S, T&gt;&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			IEnumerator&lt;S&gt;*					enumerator1;</div>
<div class="disabled">			IEnumerator&lt;T&gt;*					enumerator2;</div>
<div class="disabled">			Pair&lt;S, T&gt;						current;</div>
<div class="disabled">		public:</div>
<div class="disabled">			PairwiseEnumerator(IEnumerator&lt;S&gt;* _enumerator1, IEnumerator&lt;T&gt;* _enumerator2, Pair&lt;S, T&gt; _current=Pair&lt;S, T&gt;())</div>
<div class="disabled">				:enumerator1(_enumerator1)</div>
<div class="disabled">				,enumerator2(_enumerator2)</div>
<div class="disabled">				,current(_current)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~PairwiseEnumerator()</div>
<div class="disabled">			{</div>
<div class="disabled">				delete enumerator1;</div>
<div class="disabled">				delete enumerator2;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;Pair&lt;S, T&gt;&gt;* Clone()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return new PairwiseEnumerator(enumerator1-&gt;Clone(), enumerator2-&gt;Clone(), current);</div>
<div class="disabled">			}</div>

<div class="disabled">			const Pair&lt;S, T&gt;&amp; Current()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return current;</div>
<div class="disabled">			}</div>

<div class="disabled">			vint Index()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator1-&gt;Index();</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next()override</div>
<div class="disabled">			{</div>
<div class="disabled">				if(enumerator1-&gt;Next() &amp;&amp; enumerator2-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					current=Pair&lt;S, T&gt;(enumerator1-&gt;Current(), enumerator2-&gt;Current());</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			void Reset()override</div>
<div class="disabled">			{</div>
<div class="disabled">				enumerator1-&gt;Reset();</div>
<div class="disabled">				enumerator2-&gt;Reset();</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Evaluated()const override</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumerator1-&gt;Evaluated() &amp;&amp; enumerator2-&gt;Evaluated();</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONSTRING.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATIONSTRING</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATIONSTRING</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>
<div class="disabled">		template&lt;typename Ds, typename S&gt;</div>
<div class="disabled">		void CopyFrom(Ds&amp; ds, const ObjectString&lt;S&gt;&amp; ss, bool append=false)</div>
<div class="disabled">		{</div>
<div class="disabled">			const S* buffer=ss.Buffer();</div>
<div class="disabled">			vint count=ss.Length();</div>
<div class="disabled">			CopyFrom(ds, buffer, count, append);</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename D, typename Ss&gt;</div>
<div class="disabled">		void CopyFrom(ObjectString&lt;D&gt;&amp; ds, const Ss&amp; ss, bool append=false)</div>
<div class="disabled">		{</div>
<div class="disabled">			Array&lt;D&gt; da(ds.Buffer(), ds.Length());</div>
<div class="disabled">			CopyFrom(da, ss, append);</div>
<div class="disabled">			if(da.Count()==0)</div>
<div class="disabled">			{</div>
<div class="disabled">				ds=ObjectString&lt;D&gt;();</div>
<div class="disabled">			}</div>
<div class="disabled">			else</div>
<div class="disabled">			{</div>
<div class="disabled">				ds=ObjectString&lt;D&gt;(&amp;da[0], da.Count());</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATIONFOREACH.H
***********************************************************************/</div>
<div class="expandable"><div class="disabled">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

In order to let a container support FOREACH and FOREACH_INDEXER
	Implement a global function overloading: IteratorType vl::collections::CreateForEachIterator(const CollectionType&amp; collection);
	CollectionType is the container type
	IteratorType should inherit from ForEachIterator&lt;T&gt;
***********************************************************************/</div>
<div class="expanded"><div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

In order to let a container support FOREACH and FOREACH_INDEXER
	Implement a global function overloading: IteratorType vl::collections::CreateForEachIterator(const CollectionType&amp; collection);
	CollectionType is the container type
	IteratorType should inherit from ForEachIterator&lt;T&gt;
***********************************************************************/</div></div></div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_FOREACH</div>
<div class="disabled">#define VCZH_COLLECTIONS_FOREACH</div>

<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">ForEachIterator</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class ForEachIterator : public Object</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			virtual bool				Next(T&amp; variable)const=0;</div>

<div class="disabled">			operator bool()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">ForEachIterator for IEnumerable</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class EnumerableForEachIterator : public ForEachIterator&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			Ptr&lt;IEnumerator&lt;T&gt;&gt;			enumerator;</div>
<div class="disabled">		public:</div>
<div class="disabled">			EnumerableForEachIterator(const IEnumerable&lt;T&gt;&amp; enumerable)</div>
<div class="disabled">				:enumerator(enumerable.CreateEnumerator())</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			EnumerableForEachIterator(const EnumerableForEachIterator&lt;T&gt;&amp; enumerableIterator)</div>
<div class="disabled">				:enumerator(enumerableIterator.enumerator)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			bool Next(T&amp; variable)const</div>
<div class="disabled">			{</div>
<div class="disabled">				if(enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					variable=enumerator-&gt;Current();</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		EnumerableForEachIterator&lt;T&gt; CreateForEachIterator(const IEnumerable&lt;T&gt;&amp; enumerable)</div>
<div class="disabled">		{</div>
<div class="disabled">			return enumerable;</div>
<div class="disabled">		}</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">FOREACH and FOREACH_INDEXER</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">#define FOREACH(TYPE, VARIABLE, COLLECTION)\</div>
<div class="disabled">		SCOPE_VARIABLE(const ::vl::collections::ForEachIterator&lt;TYPE&gt;&amp;, __foreach_iterator__, ::vl::collections::CreateForEachIterator(COLLECTION))\</div>
<div class="disabled">		for(TYPE VARIABLE;__foreach_iterator__.Next(VARIABLE);)</div>

<div class="disabled">#define FOREACH_INDEXER(TYPE, VARIABLE, INDEXER, COLLECTION)\</div>
<div class="disabled">		SCOPE_VARIABLE(const ::vl::collections::ForEachIterator&lt;TYPE&gt;&amp;, __foreach_iterator__, ::vl::collections::CreateForEachIterator(COLLECTION))\</div>
<div class="disabled">		SCOPE_VARIABLE(vint, INDEXER, 0)\</div>
<div class="disabled">		for(TYPE VARIABLE;__foreach_iterator__.Next(VARIABLE);INDEXER++)</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\DICTIONARY.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Dictionary

Classes:
	Dictionary&lt;KT, VT, KK, VK&gt;					: One to one mapping
	Group&lt;KT, VT, KK, VK&gt;						: One to many mapping
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_DICTIONARY</div>
<div class="disabled">#define VCZH_COLLECTIONS_DICTIONARY</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>
<div class="disabled">		/// &lt;summary&gt;Dictionary.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;KT&quot;&gt;Type of keys.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;VT&quot;&gt;Type of values.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;KK&quot;&gt;Type of the key type of keys.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;VK&quot;&gt;Type of the key type of values.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;</div>
<div class="disabled">			typename KT,</div>
<div class="disabled">			typename VT,</div>
<div class="disabled">			typename KK=typename KeyType&lt;KT&gt;::Type, </div>
<div class="disabled">			typename VK=typename KeyType&lt;VT&gt;::Type</div>
<div class="disabled">		&gt;</div>
<div class="disabled">		class Dictionary : public Object, public virtual IEnumerable&lt;Pair&lt;KT, VT&gt;&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			typedef SortedList&lt;KT, KK&gt;			KeyContainer;</div>
<div class="disabled">			typedef List&lt;VT, VK&gt;				ValueContainer;</div>
<div class="disabled">		protected:</div>
<div class="disabled">			class Enumerator : public Object, public virtual IEnumerator&lt;Pair&lt;KT, VT&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">			private:</div>
<div class="disabled">				const Dictionary&lt;KT, VT, KK, VK&gt;*	container;</div>
<div class="disabled">				vint								index;</div>
<div class="disabled">				Pair&lt;KT, VT&gt;						current;</div>

<div class="disabled">				void UpdateCurrent()</div>
<div class="disabled">				{</div>
<div class="disabled">					if(index&lt;container-&gt;Count())</div>
<div class="disabled">					{</div>
<div class="disabled">						current.key=container-&gt;Keys().Get(index);</div>
<div class="disabled">						current.value=container-&gt;Values().Get(index);</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			public:</div>
<div class="disabled">				Enumerator(const Dictionary&lt;KT, VT, KK, VK&gt;* _container, vint _index=-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					container=_container;</div>
<div class="disabled">					index=_index;</div>
<div class="disabled">				}</div>
<div class="disabled">				</div>
<div class="disabled">				IEnumerator&lt;Pair&lt;KT, VT&gt;&gt;* Clone()const</div>
<div class="disabled">				{</div>
<div class="disabled">					return new Enumerator(container, index);</div>
<div class="disabled">				}</div>

<div class="disabled">				const Pair&lt;KT, VT&gt;&amp; Current()const</div>
<div class="disabled">				{</div>
<div class="disabled">					return current;</div>
<div class="disabled">				}</div>

<div class="disabled">				vint Index()const</div>
<div class="disabled">				{</div>
<div class="disabled">					return index;</div>
<div class="disabled">				}</div>

<div class="disabled">				bool Next()</div>
<div class="disabled">				{</div>
<div class="disabled">					index++;</div>
<div class="disabled">					UpdateCurrent();</div>
<div class="disabled">					return index&gt;=0 &amp;&amp; index&lt;container-&gt;Count();</div>
<div class="disabled">				}</div>

<div class="disabled">				void Reset()</div>
<div class="disabled">				{</div>
<div class="disabled">					index=-1;</div>
<div class="disabled">					UpdateCurrent();</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			KeyContainer						keys;</div>
<div class="disabled">			ValueContainer						values;</div>
<div class="disabled">		public:</div>
<div class="disabled">			/// &lt;summary&gt;Create a dictionary.&lt;/summary&gt;</div>
<div class="disabled">			Dictionary()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;Pair&lt;KT, VT&gt;&gt;* CreateEnumerator()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new Enumerator(this);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Set a preference of using memory.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;mode&quot;&gt;Set to true (by default) to let the container efficiently reduce memory usage when necessary.&lt;/param&gt;</div>
<div class="disabled">			void SetLessMemoryMode(bool mode)</div>
<div class="disabled">			{</div>
<div class="disabled">				keys.SetLessMemoryMode(mode);</div>
<div class="disabled">				values.SetLessMemoryMode(mode);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get all keys.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;All keys.&lt;/returns&gt;</div>
<div class="disabled">			const KeyContainer&amp; Keys()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return keys;</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get all values.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;All values.&lt;/returns&gt;</div>
<div class="disabled">			const ValueContainer&amp; Values()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return values;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the number of keys.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The number of keys.&lt;/returns&gt;</div>
<div class="disabled">			vint Count()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return keys.Count();</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the reference to the value associated with a key.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The reference to the value.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key to find.&lt;/param&gt;</div>
<div class="disabled">			const VT&amp; Get(const KK&amp; key)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return values.Get(keys.IndexOf(key));</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get the reference to the value associated with a key.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The reference to the value.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key to find.&lt;/param&gt;</div>
<div class="disabled">			const VT&amp; operator[](const KK&amp; key)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return values.Get(keys.IndexOf(key));</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Replace the value associated with a key.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the value is replaced.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key to find.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;value&quot;&gt;The key to replace.&lt;/param&gt;</div>
<div class="disabled">			bool Set(const KT&amp; key, const VT&amp; value)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint index=keys.IndexOf(KeyType&lt;KT&gt;::GetKeyValue(key));</div>
<div class="disabled">				if(index==-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					index=keys.Add(key);</div>
<div class="disabled">					values.Insert(index, value);</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					values[index]=value;</div>
<div class="disabled">				}</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Add a key with an associated value. Exception will raise if the key already exists.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the pair is added.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;value&quot;&gt;The pair of key and value.&lt;/param&gt;</div>
<div class="disabled">			bool Add(const Pair&lt;KT, VT&gt;&amp; value)</div>
<div class="disabled">			{</div>
<div class="disabled">				return Add(value.key, value.value);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Add a key with an associated value. Exception will raise if the key already exists.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the pair is added.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;</div>
<div class="disabled">			bool Add(const KT&amp; key, const VT&amp; value)</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(!keys.Contains(KeyType&lt;KT&gt;::GetKeyValue(key)), L&quot;Dictionary&lt;KT, KK, ValueContainer, VT, VK&gt;::Add(const KT&amp;, const VT&amp;)#Key already exists.&quot;);</div>
<div class="disabled">				vint index=keys.Add(key);</div>
<div class="disabled">				values.Insert(index, value);</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Remove a key with the associated value.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the key and the value is removed.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;</div>
<div class="disabled">			bool Remove(const KK&amp; key)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint index=keys.IndexOf(key);</div>
<div class="disabled">				if(index!=-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					keys.RemoveAt(index);</div>
<div class="disabled">					values.RemoveAt(index);</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Remove everything.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if all keys and values are removed.&lt;/returns&gt;</div>
<div class="disabled">			bool Clear()</div>
<div class="disabled">			{</div>
<div class="disabled">				keys.Clear();</div>
<div class="disabled">				values.Clear();</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">		</div>
<div class="disabled">		/// &lt;summary&gt;Group, which is similar to an dictionary, but a group can associate multiple values with a key.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;KT&quot;&gt;Type of keys.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;VT&quot;&gt;Type of values.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;KK&quot;&gt;Type of the key type of keys.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;VK&quot;&gt;Type of the key type of values.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;</div>
<div class="disabled">			typename KT,</div>
<div class="disabled">			typename VT,</div>
<div class="disabled">			typename KK=typename KeyType&lt;KT&gt;::Type,</div>
<div class="disabled">			typename VK=typename KeyType&lt;VT&gt;::Type</div>
<div class="disabled">		&gt;</div>
<div class="disabled">		class Group : public Object, public virtual IEnumerable&lt;Pair&lt;KT, VT&gt;&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			typedef SortedList&lt;KT, KK&gt;		KeyContainer;</div>
<div class="disabled">			typedef List&lt;VT, VK&gt;			ValueContainer;</div>
<div class="disabled">		protected:</div>
<div class="disabled">			class Enumerator : public Object, public virtual IEnumerator&lt;Pair&lt;KT, VT&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">			private:</div>
<div class="disabled">				const Group&lt;KT, VT, KK, VK&gt;*		container;</div>
<div class="disabled">				vint								keyIndex;</div>
<div class="disabled">				vint								valueIndex;</div>
<div class="disabled">				Pair&lt;KT, VT&gt;						current;</div>

<div class="disabled">				void UpdateCurrent()</div>
<div class="disabled">				{</div>
<div class="disabled">					if(keyIndex&lt;container-&gt;Count())</div>
<div class="disabled">					{</div>
<div class="disabled">						const ValueContainer&amp; values=container-&gt;GetByIndex(keyIndex);</div>
<div class="disabled">						if(valueIndex&lt;values.Count())</div>
<div class="disabled">						{</div>
<div class="disabled">							current.key=container-&gt;Keys().Get(keyIndex);</div>
<div class="disabled">							current.value=values.Get(valueIndex);</div>
<div class="disabled">						}</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			public:</div>
<div class="disabled">				Enumerator(const Group&lt;KT, VT, KK, VK&gt;* _container, vint _keyIndex=-1, vint _valueIndex=-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					container=_container;</div>
<div class="disabled">					keyIndex=_keyIndex;</div>
<div class="disabled">					valueIndex=_valueIndex;</div>
<div class="disabled">				}</div>
<div class="disabled">				</div>
<div class="disabled">				IEnumerator&lt;Pair&lt;KT, VT&gt;&gt;* Clone()const</div>
<div class="disabled">				{</div>
<div class="disabled">					return new Enumerator(container, keyIndex, valueIndex);</div>
<div class="disabled">				}</div>

<div class="disabled">				const Pair&lt;KT, VT&gt;&amp; Current()const</div>
<div class="disabled">				{</div>
<div class="disabled">					return current;</div>
<div class="disabled">				}</div>

<div class="disabled">				vint Index()const</div>
<div class="disabled">				{</div>
<div class="disabled">					if(0&lt;=keyIndex &amp;&amp; keyIndex&lt;container-&gt;Count())</div>
<div class="disabled">					{</div>
<div class="disabled">						vint index=0;</div>
<div class="disabled">						for(vint i=0;i&lt;keyIndex;i++)</div>
<div class="disabled">						{</div>
<div class="disabled">							index+=container-&gt;GetByIndex(i).Count();</div>
<div class="disabled">						}</div>
<div class="disabled">						return index+valueIndex;</div>
<div class="disabled">					}</div>
<div class="disabled">					else</div>
<div class="disabled">					{</div>
<div class="disabled">						return -1;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>

<div class="disabled">				bool Next()</div>
<div class="disabled">				{</div>
<div class="disabled">					if(keyIndex==-1)</div>
<div class="disabled">					{</div>
<div class="disabled">						keyIndex=0;</div>
<div class="disabled">					}</div>
<div class="disabled">					while(keyIndex&lt;container-&gt;Count())</div>
<div class="disabled">					{</div>
<div class="disabled">						valueIndex++;</div>
<div class="disabled">						const ValueContainer&amp; values=container-&gt;GetByIndex(keyIndex);</div>
<div class="disabled">						if(valueIndex&lt;values.Count())</div>
<div class="disabled">						{</div>
<div class="disabled">							UpdateCurrent();</div>
<div class="disabled">							return true;</div>
<div class="disabled">						}</div>
<div class="disabled">						else</div>
<div class="disabled">						{</div>
<div class="disabled">							keyIndex++;</div>
<div class="disabled">							valueIndex=-1;</div>
<div class="disabled">						}</div>
<div class="disabled">					}</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>

<div class="disabled">				void Reset()</div>
<div class="disabled">				{</div>
<div class="disabled">					keyIndex=-1;</div>
<div class="disabled">					valueIndex=-1;</div>
<div class="disabled">					UpdateCurrent();</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>

<div class="disabled">			KeyContainer					keys;</div>
<div class="disabled">			List&lt;ValueContainer*&gt;			values;</div>
<div class="disabled">		public:</div>
<div class="disabled">			Group()</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			~Group()</div>
<div class="disabled">			{</div>
<div class="disabled">				Clear();</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;Pair&lt;KT, VT&gt;&gt;* CreateEnumerator()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new Enumerator(this);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get all keys.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;All keys.&lt;/returns&gt;</div>
<div class="disabled">			const KeyContainer&amp; Keys()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return keys;</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get the number of keys.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The number of keys.&lt;/returns&gt;</div>
<div class="disabled">			vint Count()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return keys.Count();</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get all values associated with a key.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;All values.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key to find.&lt;/param&gt;</div>
<div class="disabled">			const ValueContainer&amp; Get(const KK&amp; key)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return *values.Get(keys.IndexOf(key));</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get all values associated with a key.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;All values.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;index&quot;&gt;The position of a the key.&lt;/param&gt;</div>
<div class="disabled">			const ValueContainer&amp; GetByIndex(vint index)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return *values.Get(index);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get all values associated with a key.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;All values.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key to find.&lt;/param&gt;</div>
<div class="disabled">			const ValueContainer&amp; operator[](const KK&amp; key)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return *values.Get(keys.IndexOf(key));</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Test if a key exists in the group or not.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the key exists.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key to find.&lt;/param&gt;</div>
<div class="disabled">			bool Contains(const KK&amp; key)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return keys.Contains(key);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Test if a key exists with an associated value in the group or not.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the key exists with an associated value.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key to find.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;value&quot;&gt;The value to find.&lt;/param&gt;</div>
<div class="disabled">			bool Contains(const KK&amp; key, const VK&amp; value)const</div>
<div class="disabled">			{</div>
<div class="disabled">				vint index=keys.IndexOf(key);</div>
<div class="disabled">				if(index!=-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					return values.Get(index)-&gt;Contains(value);</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Add a key with an associated value. If the key already exists, the value will be associated with the key with other values.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the pair is added.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;value&quot;&gt;The pair of key and value.&lt;/param&gt;</div>
<div class="disabled">			bool Add(const Pair&lt;KT, VT&gt;&amp; value)</div>
<div class="disabled">			{</div>
<div class="disabled">				return Add(value.key, value.value);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Add a key with an associated value. If the key already exists, the value will be associated with the key with other values.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the pair is added.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;</div>
<div class="disabled">			bool Add(const KT&amp; key, const VT&amp; value)</div>
<div class="disabled">			{</div>
<div class="disabled">				ValueContainer* target=0;</div>
<div class="disabled">				vint index=keys.IndexOf(KeyType&lt;KT&gt;::GetKeyValue(key));</div>
<div class="disabled">				if(index==-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					target=new ValueContainer;</div>
<div class="disabled">					values.Insert(keys.Add(key), target);</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					target=values[index];</div>
<div class="disabled">				}</div>
<div class="disabled">				target-&gt;Add(value);</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Remove a key with all associated values.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the key and all associated values are removed.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;</div>
<div class="disabled">			bool Remove(const KK&amp; key)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint index=keys.IndexOf(key);</div>
<div class="disabled">				if(index!=-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					keys.RemoveAt(index);</div>
<div class="disabled">					List&lt;VT, VK&gt;* target=values[index];</div>
<div class="disabled">					values.RemoveAt(index);</div>
<div class="disabled">					delete target;</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Remove a key with the associated values.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the key and the associated values are removed. If there are multiple values associated with the key, only the value will be removed.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;</div>
<div class="disabled">			bool Remove(const KK&amp; key, const VK&amp; value)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint index=keys.IndexOf(key);</div>
<div class="disabled">				if(index!=-1)</div>
<div class="disabled">				{</div>
<div class="disabled">					List&lt;VT, VK&gt;* target=values[index];</div>
<div class="disabled">					target-&gt;Remove(value);</div>
<div class="disabled">					if(target-&gt;Count()==0)</div>
<div class="disabled">					{</div>
<div class="disabled">						keys.RemoveAt(index);</div>
<div class="disabled">						values.RemoveAt(index);</div>
<div class="disabled">						delete target;</div>
<div class="disabled">					}</div>
<div class="disabled">					return true;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					return false;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Remove everything.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if all keys and values are removed.&lt;/returns&gt;</div>
<div class="disabled">			bool Clear()</div>
<div class="disabled">			{</div>
<div class="disabled">				for(vint i=0;i&lt;values.Count();i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					delete values[i];</div>
<div class="disabled">				}</div>
<div class="disabled">				keys.Clear();</div>
<div class="disabled">				values.Clear();</div>
<div class="disabled">				return true;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">GroupInnerJoin</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;</div>
<div class="disabled">			typename TKey,</div>
<div class="disabled">			typename TValueFirst,</div>
<div class="disabled">			typename TValueSecond,</div>
<div class="disabled">			typename TDiscardFirst,		// TKey * [TValueFirst] -&gt; void</div>
<div class="disabled">			typename TDiscardSecond,	// TKey * [TValueSecond] -&gt; void</div>
<div class="disabled">			typename TAccept			// TKey * [TValueFirst] * [TValueSecond] -&gt; void</div>
<div class="disabled">		&gt;</div>
<div class="disabled">		void GroupInnerJoin(</div>
<div class="disabled">			const Group&lt;TKey, TValueFirst&gt;&amp; first,</div>
<div class="disabled">			const Group&lt;TKey, TValueSecond&gt;&amp; second,</div>
<div class="disabled">			const TDiscardFirst&amp; discardFirst,</div>
<div class="disabled">			const TDiscardSecond&amp; discardSecond,</div>
<div class="disabled">			const TAccept&amp; accept</div>
<div class="disabled">			)</div>
<div class="disabled">		{</div>
<div class="disabled">			vint firstIndex = 0;</div>
<div class="disabled">			vint secondIndex = 0;</div>
<div class="disabled">			vint firstCount = first.Keys().Count();</div>
<div class="disabled">			vint secondCount = second.Keys().Count();</div>
<div class="disabled">			while (true)</div>
<div class="disabled">			{</div>
<div class="disabled">				if (firstIndex &lt; firstCount)</div>
<div class="disabled">				{</div>
<div class="disabled">					auto firstKey = first.Keys()[firstIndex];</div>
<div class="disabled">					const List&lt;TValueFirst&gt;&amp; firstValues = first.GetByIndex(firstIndex);</div>

<div class="disabled">					if (secondIndex &lt; secondCount)</div>
<div class="disabled">					{</div>
<div class="disabled">						auto secondKey = second.Keys()[secondIndex];</div>
<div class="disabled">						const List&lt;TValueSecond&gt;&amp; secondValues = second.GetByIndex(secondIndex);</div>

<div class="disabled">						if (firstKey &lt; secondKey)</div>
<div class="disabled">						{</div>
<div class="disabled">							discardFirst(firstKey, firstValues);</div>
<div class="disabled">							firstIndex++;</div>
<div class="disabled">						}</div>
<div class="disabled">						else if (firstKey &gt; secondKey)</div>
<div class="disabled">						{</div>
<div class="disabled">							discardSecond(secondKey, secondValues);</div>
<div class="disabled">							secondIndex++;</div>
<div class="disabled">						}</div>
<div class="disabled">						else</div>
<div class="disabled">						{</div>
<div class="disabled">							accept(firstKey, firstValues, secondValues);</div>
<div class="disabled">							firstIndex++;</div>
<div class="disabled">							secondIndex++;</div>
<div class="disabled">						}</div>
<div class="disabled">					}</div>
<div class="disabled">					else</div>
<div class="disabled">					{</div>
<div class="disabled">						discardFirst(firstKey, firstValues);</div>
<div class="disabled">						firstIndex++;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					if (secondIndex &lt; secondCount)</div>
<div class="disabled">					{</div>
<div class="disabled">						auto secondKey = second.Keys()[secondIndex];</div>
<div class="disabled">						const List&lt;TValueSecond&gt;&amp; secondValues = second.GetByIndex(secondIndex);</div>

<div class="disabled">						discardSecond(secondKey, secondValues);</div>
<div class="disabled">						secondIndex++;</div>
<div class="disabled">					}</div>
<div class="disabled">					else</div>
<div class="disabled">					{</div>
<div class="disabled">						break;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">Random Access</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">		namespace randomaccess_internal</div>
<div class="disabled">		{</div>
<div class="disabled">			template&lt;typename KT, typename VT, typename KK, typename VK&gt;</div>
<div class="disabled">			struct RandomAccessable&lt;Dictionary&lt;KT, VT, KK, VK&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static const bool							CanRead = true;</div>
<div class="disabled">				static const bool							CanResize = false;</div>
<div class="disabled">			};</div>
<div class="disabled">		</div>
<div class="disabled">			template&lt;typename KT, typename VT, typename KK, typename VK&gt;</div>
<div class="disabled">			struct RandomAccess&lt;Dictionary&lt;KT, VT, KK, VK&gt;&gt;</div>
<div class="disabled">			{</div>
<div class="disabled">				static vint GetCount(const Dictionary&lt;KT, VT, KK, VK&gt;&amp; t)</div>
<div class="disabled">				{</div>
<div class="disabled">					return t.Count();</div>
<div class="disabled">				}</div>

<div class="disabled">				static Pair&lt;KT, VT&gt; GetValue(const Dictionary&lt;KT, VT, KK, VK&gt;&amp; t, vint index)</div>
<div class="disabled">				{</div>
<div class="disabled">					return Pair&lt;KT, VT&gt;(t.Keys().Get(index), t.Values().Get(index));</div>
<div class="disabled">				}</div>

<div class="disabled">				static void AppendValue(Dictionary&lt;KT, VT, KK, VK&gt;&amp; t, const Pair&lt;KT, VT&gt;&amp; value)</div>
<div class="disabled">				{</div>
<div class="disabled">					t.Set(value.key, value.value);</div>
<div class="disabled">				}</div>
<div class="disabled">			};</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\EXCEPTION.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Framework::Exception

Classes:
	Exception									: Exception
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_EXCEPTION</div>
<div class="disabled">#define VCZH_EXCEPTION</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	/// &lt;summary&gt;Base type of all exceptions.&lt;/summary&gt;</div>
<div class="disabled">	class Exception : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	protected:</div>
<div class="disabled">		WString						message;</div>

<div class="disabled">	public:</div>
<div class="disabled">		Exception(const WString&amp; _message=WString::Empty);</div>

<div class="disabled">		const WString&amp;				Message()const;</div>
<div class="disabled">	};</div>

<div class="disabled">	class ArgumentException : public Exception</div>
<div class="disabled">	{</div>
<div class="disabled">	protected:</div>
<div class="disabled">		WString						function;</div>
<div class="disabled">		WString						name;</div>

<div class="disabled">	public:</div>
<div class="disabled">		ArgumentException(const WString&amp; _message=WString::Empty, const WString&amp; _function=WString::Empty, const WString&amp; _name=WString::Empty);</div>

<div class="disabled">		const WString&amp;				GetFunction()const;</div>
<div class="disabled">		const WString&amp;				GetName()const;</div>
<div class="disabled">	};</div>

<div class="disabled">	class ParsingException : public Exception</div>
<div class="disabled">	{</div>
<div class="disabled">	protected:</div>
<div class="disabled">		vint							position;</div>
<div class="disabled">		WString						expression;</div>

<div class="disabled">	public:</div>
<div class="disabled">		ParsingException(const WString&amp; _message, const WString&amp; _expression, vint _position);</div>

<div class="disabled">		const WString&amp;				GetExpression()const;</div>
<div class="disabled">		vint							GetPosition()const;</div>
<div class="disabled">	};</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\CONSOLE.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
UI::Console

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_CONSOLE</div>
<div class="disabled">#define VCZH_CONSOLE</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace console</div>
<div class="disabled">	{</div>
<div class="disabled">		/// &lt;summary&gt;A Static class for command line window operations.&lt;/summary&gt;</div>
<div class="disabled">		class Console abstract</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			/// &lt;summary&gt;Write to the command line window.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;string&quot;&gt;Content to write.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;length&quot;&gt;Size of the content in wchar_t. The zero terminator is not included.&lt;/param&gt;</div>
<div class="disabled">			static void Write(const wchar_t* string, vint length);</div>

<div class="disabled">			/// &lt;summary&gt;Write to the command line window.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;string&quot;&gt;Content to write.&lt;/param&gt;</div>
<div class="disabled">			static void Write(const wchar_t* string);</div>

<div class="disabled">			/// &lt;summary&gt;Write to the command line window.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;string&quot;&gt;Content to write.&lt;/param&gt;</div>
<div class="disabled">			static void Write(const WString&amp; string);</div>

<div class="disabled">			/// &lt;summary&gt;Write to the command line window with a CRLF.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;string&quot;&gt;Content to write.&lt;/param&gt;</div>
<div class="disabled">			static void WriteLine(const WString&amp; string);</div>

<div class="disabled">			/// &lt;summary&gt;Read from the command line window.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The whole line read from the command line window.&lt;/returns&gt;</div>
<div class="disabled">			static WString Read();</div>

<div class="disabled">			static void SetColor(bool red, bool green, bool blue, bool light);</div>
<div class="disabled">			static void SetTitle(const WString&amp; string);</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\GLOBALSTORAGE.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Framework::Global Storage

Classes:
	GlobalStorage							: Global storage accessable by name, each storage will be initialized on the first access, and all storages will be released by FinalizeGlobalStorage

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_GLOBALSTORAGE</div>
<div class="disabled">#define VCZH_GLOBALSTORAGE</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	/// &lt;summary&gt;&lt;![CDATA[</div>
<div class="disabled">	/// Base type of all global storages. A global storage is a value with a key to store some information. In order to create a global storage, you should do the following in a cpp file:</div>
<div class="disabled">	/// BEGIN_GLOBAL_STOREGE_CLASS(&lt;put the key here, it should be a legal C++ identifier&gt;)</div>
<div class="disabled">	///		&lt;put all variables here&gt;</div>
<div class="disabled">	/// INITIALIZE_GLOBAL_STORAGE_CLASS</div>
<div class="disabled">	///		&lt;initialize all variables&gt;</div>
<div class="disabled">	/// FINALIZE_GLOBAL_STORAGE_CLASS</div>
<div class="disabled">	///		&lt;clear all resources because the program is about to exit&gt;</div>
<div class="disabled">	/// END_GLOBAL_STORAGE_CLASS</div>
<div class="disabled">	/// Then you have a global storage. You can only use this global storage in the current cpp file. [M:vl.InitializeGlobalStorage] should be called before using any global storage. [M:vl.FinalizeGlobalStorage] is encouraged to call if you think you will not use any global storages anymore. It will reduce noices when you want to detect memory leaks.</div>
<div class="disabled">	/// If the key of the global variable is called Key, and the variable you want to access is called Variable, then you can use GetKey()-&gt;Variable to access that variable. The GetKey function is created in the macro calls before.</div>
<div class="disabled">	/// ]]&gt;&lt;/summary&gt;</div>
<div class="disabled">	class GlobalStorage : public Object, private NotCopyable</div>
<div class="disabled">	{</div>
<div class="disabled">	private:</div>
<div class="disabled">		bool					cleared;</div>
<div class="disabled">	public:</div>
<div class="disabled">		GlobalStorage(const wchar_t* key);</div>
<div class="disabled">		~GlobalStorage();</div>

<div class="disabled">		bool					Cleared();</div>
<div class="disabled">		virtual void			ClearResource()=0;</div>
<div class="disabled">	};</div>

<div class="disabled">	extern GlobalStorage* GetGlobalStorage(const wchar_t* key);</div>
<div class="disabled">	extern GlobalStorage* GetGlobalStorage(const WString&amp; key);</div>

<div class="disabled">	/// &lt;summary&gt;Initialize the global storage.&lt;/summary&gt;</div>
<div class="disabled">	extern void InitializeGlobalStorage();</div>
<div class="disabled">	/// &lt;summary&gt;Finalize the global storage.&lt;/summary&gt;</div>
<div class="disabled">	extern void FinalizeGlobalStorage();</div>
<div class="disabled">}</div>

<div class="disabled">#define BEGIN_GLOBAL_STORAGE_CLASS(NAME)\</div>
<div class="disabled">	class NAME : public vl::GlobalStorage\</div>
<div class="disabled">	{\</div>
<div class="disabled">	public:\</div>
<div class="disabled">		NAME()\</div>
<div class="disabled">			:vl::GlobalStorage(L ## #NAME)\</div>
<div class="disabled">		{\</div>
<div class="disabled">			InitializeClearResource();\</div>
<div class="disabled">		}\</div>
<div class="disabled">		~NAME()\</div>
<div class="disabled">		{\</div>
<div class="disabled">			if(!Cleared())ClearResource();\</div>
<div class="disabled">		}\</div>

<div class="disabled">#define INITIALIZE_GLOBAL_STORAGE_CLASS\</div>
<div class="disabled">		void InitializeClearResource()\</div>
<div class="disabled">		{\</div>

<div class="disabled">#define FINALIZE_GLOBAL_STORAGE_CLASS\</div>
<div class="disabled">		}\</div>
<div class="disabled">		void ClearResource()\</div>
<div class="disabled">		{\</div>

<div class="disabled">#define END_GLOBAL_STORAGE_CLASS(NAME)\</div>
<div class="disabled">		}\</div>
<div class="disabled">	};\</div>
<div class="disabled">	NAME&amp; Get##NAME()\</div>
<div class="disabled">	{\</div>
<div class="disabled">		static NAME __global_storage_##NAME;\</div>
<div class="disabled">		return __global_storage_##NAME;\</div>
<div class="disabled">	}\</div>

<div class="disabled">#define EXTERN_GLOBAL_STORAGE_CLASS(NAME)\</div>
<div class="disabled">	class NAME;\</div>
<div class="disabled">	extern NAME&amp; Get##NAME();\</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\PARTIALORDERING.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Partial Ordering

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_PARTIALORDERING</div>
<div class="disabled">#define VCZH_COLLECTIONS_PARTIALORDERING</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">Partial Ordering</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		namespace po</div>
<div class="disabled">		{</div>
<div class="disabled">			struct Node</div>
<div class="disabled">			{</div>
<div class="disabled">				bool					visited = false;</div>
<div class="disabled">				vint					component = -1;</div>
<div class="disabled">				const List&lt;vint&gt;*		ins = nullptr;					// all nodes that this node depends on</div>
<div class="disabled">				const List&lt;vint&gt;*		outs = nullptr;					// all nodes that depend on this node</div>
<div class="disabled">				const vint*				firstSubClassItem = nullptr;	// index of the first item in this sub class node</div>
<div class="disabled">				vint					subClassItemCount = 0;			// the number of items in this sub class node</div>
<div class="disabled">			};</div>

<div class="disabled">			struct Component</div>
<div class="disabled">			{</div>
<div class="disabled">				const vint*				firstNode = nullptr;</div>
<div class="disabled">				vint					nodeCount = 0;</div>
<div class="disabled">			};</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>

<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>
<div class="disabled">		/// &lt;summary&gt;</div>
<div class="disabled">		/// Partial ordering item sorter.</div>
<div class="disabled">		/// This class sorts items in a partial order using the given dependency information.</div>
<div class="disabled">		/// Node stored in this class using the index of items.</div>
<div class="disabled">		/// If a depends on b, then a.ins-&gt;Contains(b) &amp;amp;&amp;amp; b.outs-&gt;Contains(a).</div>
<div class="disabled">		/// The sorting result is a list of strong connected components in order.</div>
<div class="disabled">		/// If a depends on b, then the component containing a appears after the component containing b.</div>
<div class="disabled">		/// Node could represent a sub class if InitWithSubClass is called.</div>
<div class="disabled">		/// &lt;/summary&gt;</div>
<div class="disabled">		class PartialOrderingProcessor : public Object</div>
<div class="disabled">		{</div>
<div class="disabled">			template&lt;typename TList&gt;</div>
<div class="disabled">			using GroupOf = Group&lt;typename TList::ElementType, typename TList::ElementType&gt;;</div>
<div class="disabled">		protected:</div>
<div class="disabled">			List&lt;vint&gt;					emptyList;</div>
<div class="disabled">			Group&lt;vint, vint&gt;			ins;</div>
<div class="disabled">			Group&lt;vint, vint&gt;			outs;</div>
<div class="disabled">			Array&lt;vint&gt;					firstNodesBuffer;</div>
<div class="disabled">			Array&lt;vint&gt;					subClassItemsBuffer;</div>

<div class="disabled">			void						InitNodes(vint itemCount);</div>
<div class="disabled">			void						VisitUnvisitedNode(po::Node&amp; node, Array&lt;vint&gt;&amp; reversedOrder, vint&amp; used);</div>
<div class="disabled">			void						AssignUnassignedNode(po::Node&amp; node, vint componentIndex, vint&amp; used);</div>
<div class="disabled">		public:</div>
<div class="disabled">			/// &lt;summary&gt;Nodes.&lt;/summary&gt;</div>
<div class="disabled">			Array&lt;po::Node&gt;				nodes;</div>

<div class="disabled">			/// &lt;summary&gt;Strong connected components in order.&lt;/summary&gt;</div>
<div class="disabled">			List&lt;po::Component&gt;			components;</div>

<div class="disabled">			/// &lt;summary&gt;Sort. This method can only be called once.&lt;/summary&gt;</div>
<div class="disabled">			void						Sort();</div>

<div class="disabled">			/// &lt;summary&gt;Initialize the processor, specifying dependency relationships as a group.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;TList&quot;&gt;Type of the first parameter.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;items&quot;&gt;Items.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;depGroup&quot;&gt;Dependences. If a depends on b, then depGroups[a].Contains(b) == true.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename TList&gt;</div>
<div class="disabled">			void InitWithGroup(const TList&amp; items, const GroupOf&lt;TList&gt;&amp; depGroup)</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(nodes.Count() == 0, L&quot;PartialOrdering::InitWithGroup(items, depGroup)#Initializing twice is not allowed.&quot;);</div>

<div class="disabled">				for (vint i = 0; i &lt; depGroup.Count(); i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					vint fromNode = items.IndexOf(KeyType&lt;typename TList::ElementType&gt;::GetKeyValue(depGroup.Keys()[i]));</div>
<div class="disabled">					CHECK_ERROR(fromNode != -1, L&quot;PartialOrdering::InitWithGroup(items, depGroup)#The key in outsGroup does not exist in items.&quot;);</div>

<div class="disabled">					auto&amp; edges = depGroup.GetByIndex(i);</div>
<div class="disabled">					for (vint j = 0; j &lt; edges.Count(); j++)</div>
<div class="disabled">					{</div>
<div class="disabled">						vint toNode = items.IndexOf(KeyType&lt;typename TList::ElementType&gt;::GetKeyValue(edges[j]));</div>
<div class="disabled">						CHECK_ERROR(toNode != -1, L&quot;PartialOrdering::InitWithGroup(items, depGroup)#The value in outsGroup does not exist in items.&quot;);</div>

<div class="disabled">						ins.Add(fromNode, toNode);</div>
<div class="disabled">						outs.Add(toNode, fromNode);</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>

<div class="disabled">				InitNodes(items.Count());</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Initialize the processor, specifying dependency relationships as a callback function.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;TList&quot;&gt;Type of the first parameter.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;TFunc&quot;&gt;Type of the second parameter.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;items&quot;&gt;Items.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;depFunc&quot;&gt;Dependences. If a depends on b, then depFunc(a, b) == true.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename TList, typename TFunc&gt;</div>
<div class="disabled">			void InitWithFunc(const TList&amp; items, TFunc&amp;&amp; depFunc)</div>
<div class="disabled">			{</div>
<div class="disabled">				GroupOf&lt;TList&gt; depGroup;</div>
<div class="disabled">				for (vint i = 0; i &lt; items.Count(); i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					for (vint j = 0; j &lt; items.Count(); j++)</div>
<div class="disabled">					{</div>
<div class="disabled">						if (depFunc(items[i], items[j]))</div>
<div class="disabled">						{</div>
<div class="disabled">							depGroup.Add(items[i], items[j]);</div>
<div class="disabled">						}</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">				InitWithGroup(items, depGroup);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Initialize the processor, specifying dependency relationships and sub class classification as two groups.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;TList&quot;&gt;Type of the first parameter.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;TSubClass&quot;&gt;Type of the sub class.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;items&quot;&gt;Items.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;depGroup&quot;&gt;Dependences. If a depends on b, then depGroups[a].Contains(b) == true.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;subClasses&quot;&gt;To put multiple items in a node to represent a sub class, use these items as keys, use a unique value as a value, and put them in subClasses.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename TList, typename TSubClass&gt;</div>
<div class="disabled">			void InitWithSubClass(const TList&amp; items, const GroupOf&lt;TList&gt;&amp; depGroup, const Dictionary&lt;typename TList::ElementType, TSubClass&gt;&amp; subClasses)</div>
<div class="disabled">			{</div>
<div class="disabled">				CHECK_ERROR(nodes.Count() == 0, L&quot;PartialOrdering::InitWithSubClass(items, degGroup, subClasses)#Initializing twice is not allowed.&quot;);</div>
<div class="disabled">				using ElementType = typename TList::ElementType;</div>
<div class="disabled">				using ElementKeyType = KeyType&lt;ElementType&gt;;</div>

<div class="disabled">				Group&lt;TSubClass, ElementType&gt; scItems;</div>
<div class="disabled">				SortedList&lt;ElementType&gt; singleItems;</div>

<div class="disabled">				for (vint i = 0; i &lt; subClasses.Count(); i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					const auto&amp; key = subClasses.Keys()[i];</div>
<div class="disabled">					const auto&amp; value = subClasses.Values()[i];</div>
<div class="disabled">					scItems.Add(value, key);</div>
<div class="disabled">				}</div>

<div class="disabled">				for (vint i = 0; i &lt; items.Count(); i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					const auto&amp; item = items[i];</div>
<div class="disabled">					if (!subClasses.Keys().Contains(ElementKeyType::GetKeyValue(item)))</div>
<div class="disabled">					{</div>
<div class="disabled">						singleItems.Add(item);</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>

<div class="disabled">				auto getSubClass = [&amp;](const ElementType&amp; item)</div>
<div class="disabled">				{</div>
<div class="disabled">					vint index = subClasses.Keys().IndexOf(ElementKeyType::GetKeyValue(item));</div>
<div class="disabled">					if (index != -1)</div>
<div class="disabled">					{</div>
<div class="disabled">						index = scItems.Keys().IndexOf(KeyType&lt;TSubClass&gt;::GetKeyValue(subClasses.Values()[index]));</div>
<div class="disabled">						CHECK_ERROR(index != -1, L&quot;PartialOrdering::InitWithSubClass(items, degGroup, subClasses)#Internal Error.&quot;);</div>
<div class="disabled">						return index;</div>
<div class="disabled">					}</div>
<div class="disabled">					else</div>
<div class="disabled">					{</div>
<div class="disabled">						index = singleItems.IndexOf(ElementKeyType::GetKeyValue(item));</div>
<div class="disabled">						CHECK_ERROR(index != -1, L&quot;PartialOrdering::InitWithSubClass(items, degGroup, subClasses)#Internal Error.&quot;);</div>
<div class="disabled">						return scItems.Count() + index;</div>
<div class="disabled">					}</div>
<div class="disabled">				};</div>

<div class="disabled">				for (vint i = 0; i &lt; depGroup.Count(); i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					const auto&amp; key = depGroup.Keys()[i];</div>
<div class="disabled">					vint keyIndex = getSubClass(key);</div>
<div class="disabled">					const auto&amp; values = depGroup.GetByIndex(i);</div>

<div class="disabled">					for (vint j = 0; j &lt; values.Count(); j++)</div>
<div class="disabled">					{</div>
<div class="disabled">						const auto&amp; value = values[j];</div>
<div class="disabled">						vint valueIndex = getSubClass(value);</div>

<div class="disabled">						if (!ins.Contains(keyIndex, valueIndex))</div>
<div class="disabled">						{</div>
<div class="disabled">							ins.Add(keyIndex, valueIndex);</div>
<div class="disabled">						}</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>

<div class="disabled">				for (vint i = 0; i &lt; ins.Count(); i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					vint key = ins.Keys()[i];</div>
<div class="disabled">					const auto&amp; values = ins.GetByIndex(i);</div>
<div class="disabled">					for (vint j = 0; j &lt; values.Count(); j++)</div>
<div class="disabled">					{</div>
<div class="disabled">						outs.Add(values[j], key);</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>

<div class="disabled">				InitNodes(scItems.Count() + singleItems.Count());</div>
<div class="disabled">				subClassItemsBuffer.Resize(items.Count());</div>
<div class="disabled">				</div>
<div class="disabled">				vint used = 0;</div>
<div class="disabled">				vint scItemCount = scItems.Keys().Count();</div>
<div class="disabled">				for (vint i = 0; i &lt; nodes.Count(); i++)</div>
<div class="disabled">				{</div>
<div class="disabled">					auto&amp; node = nodes[i];</div>
<div class="disabled">					node.firstSubClassItem = &amp;subClassItemsBuffer[used];</div>
<div class="disabled">					if (i &lt; scItemCount)</div>
<div class="disabled">					{</div>
<div class="disabled">						const auto&amp; values = scItems.GetByIndex(i);</div>
<div class="disabled">						for (vint j = 0; j &lt; values.Count(); j++)</div>
<div class="disabled">						{</div>
<div class="disabled">							subClassItemsBuffer[used++] = items.IndexOf(ElementKeyType::GetKeyValue(values[j]));</div>
<div class="disabled">						}</div>
<div class="disabled">						node.subClassItemCount = values.Count();</div>
<div class="disabled">					}</div>
<div class="disabled">					else</div>
<div class="disabled">					{</div>
<div class="disabled">						subClassItemsBuffer[used++] = items.IndexOf(ElementKeyType::GetKeyValue(singleItems[i - scItemCount]));</div>
<div class="disabled">						node.subClassItemCount = 1;</div>
<div class="disabled">					}</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\UNITTEST\UNITTEST.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
UI::Console

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_UNITTEST</div>
<div class="disabled">#define VCZH_UNITTEST</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace unittest</div>
<div class="disabled">	{</div>
<div class="disabled">		using UnitTestFileProc = void(*)();</div>

<div class="disabled">		/// &lt;summary&gt;&lt;![CDATA[</div>
<div class="disabled">		/// A static class containing all unit test operations.</div>
<div class="disabled">		/// 1) Writing test cases:</div>
<div class="disabled">		///   TEST_FILE</div>
<div class="disabled">		///   {</div>
<div class="disabled">		///     TEST_CATEGORY(L&quot;Category Description&quot;){ ... });</div>
<div class="disabled">		///     TEST_CASE(L&quot;Test Case Description&quot;){ ... });</div>
<div class="disabled">		///   }</div>
<div class="disabled">		///   A category could contains other categories and cases, but a case should only contain assertions.</div>
<div class="disabled">		/// 2) Writing asserts:</div>
<div class="disabled">		///   TEST_CASE_ASSERT(condition): An assertion that is also a test case, only legal to call inside a category, with a description equivalents to the condition.</div>
<div class="disabled">		///   TEST_ASSERT(condition); Only legal to call inside a case. It passes when condition evaluates to true.</div>
<div class="disabled">		///   TEST_ERROR(condition); Only legal to call inside a case. It passes when condition throws vl::Error</div>
<div class="disabled">		///   TEST_EXCEPTION(statement, exception, callback); Only legal to call inside a case. It passes when an exception of the expected type is thrown, and callback(exception) passes.</div>
<div class="disabled">		/// 3) Other functions</div>
<div class="disabled">		///   TEST_PRINT(message); Print neutral message.</div>
<div class="disabled">		/// 4)</div>
<div class="disabled">		///   You should call [M:vl.unittest.UnitTest.RunAndDisposeTests] in your main function to run all test cases, and return the value from this function.</div>
<div class="disabled">		///   When &quot;/D&quot; is provided, the test program crashes at any failed assertiong.</div>
<div class="disabled">		///   When &quot;/R&quot; is provided, the test program consumes all failed assertions and run all cases. A test case stopped at the first failed assertion. Exit code will be 1 when any case fails.</div>
<div class="disabled">		///   When no argument is provided</div>
<div class="disabled">		///     In Windows, it becomes &quot;/D&quot; only when a debugger is attached, in other cases it becomes &quot;/R&quot;.</div>
<div class="disabled">		///     In other platforms, it becomes &quot;/R&quot;</div>
<div class="disabled">		/// ]]&gt;&lt;/summary&gt;</div>
<div class="disabled">		class UnitTest</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			UnitTest() = delete;</div>

<div class="disabled">			enum class MessageKind</div>
<div class="disabled">			{</div>
<div class="disabled">				Info,</div>
<div class="disabled">				Error,</div>
<div class="disabled">				File,</div>
<div class="disabled">				Category,</div>
<div class="disabled">				Case,</div>
<div class="disabled">			};</div>

<div class="disabled">			/// &lt;summary&gt;Print a message with specified color.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;string&quot;&gt;The content.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;kind&quot;&gt;The kind of the content.&lt;/param&gt;</div>
<div class="disabled">			static void PrintMessage(const WString&amp; string, MessageKind kind);</div>

<div class="disabled">			/// &lt;summary&gt;Run all test cases.&lt;/summary&gt;</div>
<div class="disabled">#ifdef VCZH_MSVC</div>
<div class="disabled">			static int RunAndDisposeTests(int argc, wchar_t* argv[]);</div>
<div class="disabled">#else</div>
<div class="disabled">			static int RunAndDisposeTests(int argc, char* argv[]);</div>
<div class="disabled">#endif</div>

<div class="disabled">			static void RegisterTestFile(const char* fileName, UnitTestFileProc testProc);</div>
<div class="disabled">			static void RunCategoryOrCase(const WString&amp; description, bool isCategory, Func&lt;void()&gt;&amp;&amp; callback);</div>
<div class="disabled">			static void EnsureLegalToAssert();</div>
<div class="disabled">		};</div>

<div class="disabled">		class UnitTestFile</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			UnitTestFile(const char* fileName, UnitTestFileProc testProc)</div>
<div class="disabled">			{</div>
<div class="disabled">				UnitTest::RegisterTestFile(fileName, testProc);</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		struct UnitTestAssertError</div>
<div class="disabled">		{</div>
<div class="disabled">			const wchar_t*				message;</div>

<div class="disabled">			UnitTestAssertError(const wchar_t* _message) :message(_message) {}</div>
<div class="disabled">		};</div>

<div class="disabled">		struct UnitTestConfigError</div>
<div class="disabled">		{</div>
<div class="disabled">			const wchar_t*				message;</div>

<div class="disabled">			UnitTestConfigError(const wchar_t* _message) :message(_message) {}</div>
<div class="disabled">		};</div>

<div class="disabled">#define TEST_FILE\</div>
<div class="disabled">		static void VLPPTEST_TESTFILE();\</div>
<div class="disabled">		static ::vl::unittest::UnitTestFile VLPPTEST_TESTFILE_INSTANCE(__FILE__, &amp;VLPPTEST_TESTFILE);\</div>
<div class="disabled">		static void VLPPTEST_TESTFILE()\</div>

<div class="disabled">#define TEST_CATEGORY(DESCRIPTION)\</div>
<div class="disabled">		::vl::unittest::UnitTest::RunCategoryOrCase((DESCRIPTION), true, [&amp;]()\</div>

<div class="disabled">#define TEST_CASE(DESCRIPTION)\</div>
<div class="disabled">		::vl::unittest::UnitTest::RunCategoryOrCase((DESCRIPTION), false, [&amp;]()\</div>

<div class="disabled">#define TEST_ASSERT(CONDITION)\</div>
<div class="disabled">		do{\</div>
<div class="disabled">			::vl::unittest::UnitTest::EnsureLegalToAssert();\</div>
<div class="disabled">			if(!(CONDITION))throw ::vl::unittest::UnitTestAssertError(L&quot;Assertion failure: &quot; #CONDITION);\</div>
<div class="disabled">		}while(0)\</div>

<div class="disabled">#define TEST_ERROR(STATEMENT)\</div>
<div class="disabled">		do{\</div>
<div class="disabled">			::vl::unittest::UnitTest::EnsureLegalToAssert();\</div>
<div class="disabled">			try{STATEMENT; throw ::vl::unittest::UnitTestAssertError(L&quot;Expect an error but nothing occurred: &quot; #STATEMENT);}\</div>
<div class="disabled">			catch(const ::vl::Error&amp;){}\</div>
<div class="disabled">			catch(const ::vl::unittest::UnitTestAssertError&amp;) { throw; }\</div>
<div class="disabled">			catch (const ::vl::unittest::UnitTestConfigError&amp;) { throw; }\</div>
<div class="disabled">		}while(0)\</div>

<div class="disabled">#define TEST_EXCEPTION(STATEMENT,EXCEPTION,ASSERT_FUNCTION)\</div>
<div class="disabled">		do{\</div>
<div class="disabled">			auto __ASSERT_FUNCTION__ = ASSERT_FUNCTION;\</div>
<div class="disabled">			try{STATEMENT; throw ::vl::unittest::UnitTestAssertError(L&quot;Expect [&quot; #EXCEPTION &quot;] but nothing occurred: &quot; #STATEMENT);}\</div>
<div class="disabled">			catch(const EXCEPTION&amp; e){ __ASSERT_FUNCTION__(e); }\</div>
<div class="disabled">			catch(...){ throw ::vl::unittest::UnitTestAssertError(L&quot;Expect [&quot; #EXCEPTION &quot;] but get unexpected exception: &quot; #STATEMENT); }\</div>
<div class="disabled">		}while(0)\</div>

<div class="disabled">#define TEST_PRINT(MESSAGE)\</div>
<div class="disabled">		::vl::unittest::UnitTest::PrintMessage((MESSAGE), ::vl::unittest::UnitTest::MessageKind::Info)\</div>

<div class="disabled">#define TEST_CASE_ASSERT(CONDITION)\</div>
<div class="disabled">		TEST_CASE(L ## # CONDITION) { TEST_ASSERT(CONDITION); })\</div>

<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\EVENT.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Framework::Event

Classes:
	Event&lt;function-type&gt;									: Event object, which is a functor with no return value, executing multiple functors stored inside
***********************************************************************/</div>
<div class="disabled">#ifndef VCZH_EVENT</div>
<div class="disabled">#define VCZH_EVENT</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	class Event</div>
<div class="disabled">	{</div>
<div class="disabled">	};</div>
<div class="disabled"> </div>
<div class="disabled">	class EventHandler : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		virtual bool							IsAttached() = 0;</div>
<div class="disabled">	};</div>

<div class="disabled">	/// &lt;summary&gt;Event.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;TArgs&quot;&gt;Types of callback parameters.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename ...TArgs&gt;</div>
<div class="disabled">	class Event&lt;void(TArgs...)&gt; : public Object, private NotCopyable</div>
<div class="disabled">	{</div>
<div class="disabled">	protected:</div>
<div class="disabled">		class EventHandlerImpl : public EventHandler</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			bool								attached;</div>
<div class="disabled">			Func&lt;void(TArgs...)&gt;				function;</div>

<div class="disabled">			EventHandlerImpl(const Func&lt;void(TArgs...)&gt;&amp; _function)</div>
<div class="disabled">				:attached(true)</div>
<div class="disabled">				, function(_function)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>
<div class="disabled"> </div>
<div class="disabled">			bool IsAttached()override</div>
<div class="disabled">			{</div>
<div class="disabled">				return attached;</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>
<div class="disabled"> </div>
<div class="disabled">		collections::SortedList&lt;Ptr&lt;EventHandlerImpl&gt;&gt;	handlers;</div>
<div class="disabled">	public:</div>
<div class="disabled">		/// &lt;summary&gt;Add a callback to the event.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The event handler representing the callback.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;function&quot;&gt;The callback.&lt;/param&gt;</div>
<div class="disabled">		Ptr&lt;EventHandler&gt; Add(const Func&lt;void(TArgs...)&gt;&amp; function)</div>
<div class="disabled">		{</div>
<div class="disabled">			Ptr&lt;EventHandlerImpl&gt; handler = new EventHandlerImpl(function);</div>
<div class="disabled">			handlers.Add(handler);</div>
<div class="disabled">			return handler;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		/// &lt;summary&gt;Add a callback to the event.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The event handler representing the callback.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;function&quot;&gt;The callback.&lt;/param&gt;</div>
<div class="disabled">		Ptr&lt;EventHandler&gt; Add(void(*function)(TArgs...))</div>
<div class="disabled">		{</div>
<div class="disabled">			return Add(Func&lt;void(TArgs...)&gt;(function));</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		/// &lt;summary&gt;Add a method callback to the event.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;C&quot;&gt;Type of the class that has the method callback.&lt;/typeparam&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The event handler representing the callback.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;sender&quot;&gt;The object that has the method callback.&lt;/param&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;function&quot;&gt;The method callback.&lt;/param&gt;</div>
<div class="disabled">		template&lt;typename C&gt;</div>
<div class="disabled">		Ptr&lt;EventHandler&gt; Add(C* sender, void(C::*function)(TArgs...))</div>
<div class="disabled">		{</div>
<div class="disabled">			return Add(Func&lt;void(TArgs...)&gt;(sender, function));</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		/// &lt;summary&gt;Remove a callback.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;handler&quot;&gt;The event handler representing the callback.&lt;/param&gt;</div>
<div class="disabled">		bool Remove(Ptr&lt;EventHandler&gt; handler)</div>
<div class="disabled">		{</div>
<div class="disabled">			Ptr&lt;EventHandlerImpl&gt; impl = handler.Cast&lt;EventHandlerImpl&gt;();</div>
<div class="disabled">			if (!impl) return false;</div>
<div class="disabled">			vint index = handlers.IndexOf(impl.Obj());</div>
<div class="disabled">			if (index == -1) return false;</div>
<div class="disabled">			impl-&gt;attached = false;</div>
<div class="disabled">			handlers.RemoveAt(index);</div>
<div class="disabled">			return true;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		/// &lt;summary&gt;Invoke all callbacks in the event.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;args&quot;&gt;Arguments to invoke all callbacks.&lt;/param&gt;</div>
<div class="disabled">		void operator()(TArgs ...args)const</div>
<div class="disabled">		{</div>
<div class="disabled">			for(vint i = 0; i &lt; handlers.Count(); i++)</div>
<div class="disabled">			{</div>
<div class="disabled">				handlers[i]-&gt;function(args...);</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>
<div class="disabled">}</div>
<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\LAZY.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Framework::Lazy Evaluation

Classes:
	Lazy&lt;T&gt;									: Object with lazy evaluation

***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_LAZY</div>
<div class="disabled">#define VCZH_LAZY</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	/// &lt;summary&gt;A type representing a lazy evaluation.&lt;/summary&gt;</div>
<div class="disabled">	/// &lt;typeparam name=&quot;T&quot;&gt;The type of the evaluation result.&lt;/typeparam&gt;</div>
<div class="disabled">	template&lt;typename T&gt;</div>
<div class="disabled">	class Lazy : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	protected:</div>
<div class="disabled">		class Internal</div>
<div class="disabled">		{</div>
<div class="disabled">		public:</div>
<div class="disabled">			Func&lt;T()&gt;			evaluator;</div>
<div class="disabled">			T					value;</div>
<div class="disabled">			bool				evaluated;</div>
<div class="disabled">		};</div>

<div class="disabled">		Ptr&lt;Internal&gt;			internalValue;</div>
<div class="disabled">	public:</div>
<div class="disabled">		/// &lt;summary&gt;Create an empty evaluation.&lt;/summary&gt;</div>
<div class="disabled">		Lazy()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create an evaluation using a function.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;evaluator&quot;&gt;The function.&lt;/param&gt;</div>
<div class="disabled">		Lazy(const Func&lt;T()&gt;&amp; evaluator)</div>
<div class="disabled">		{</div>
<div class="disabled">			internalValue=new Internal;</div>
<div class="disabled">			internalValue-&gt;evaluated=false;</div>
<div class="disabled">			internalValue-&gt;evaluator=evaluator;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Create an evaluation using the result directly.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;value&quot;&gt;The result that you have already known.&lt;/param&gt;0</div>
<div class="disabled">		Lazy(const T&amp; value)</div>
<div class="disabled">		{</div>
<div class="disabled">			internalValue=new Internal;</div>
<div class="disabled">			internalValue-&gt;evaluated=true;</div>
<div class="disabled">			internalValue-&gt;value=value;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Copy an evaluation.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;param name=&quot;lazy&quot;&gt;The evaluation to copy.&lt;/param&gt;</div>
<div class="disabled">		Lazy(const Lazy&lt;T&gt;&amp; lazy)</div>
<div class="disabled">			:internalValue(lazy.internalValue)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">		Lazy&lt;T&gt;&amp; operator=(const Func&lt;T()&gt;&amp; evaluator)</div>
<div class="disabled">		{</div>
<div class="disabled">			internalValue=new Internal;</div>
<div class="disabled">			internalValue-&gt;evaluated=false;</div>
<div class="disabled">			internalValue-&gt;evaluator=evaluator;</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		Lazy&lt;T&gt;&amp; operator=(const T&amp; value)</div>
<div class="disabled">		{</div>
<div class="disabled">			internalValue=new Internal;</div>
<div class="disabled">			internalValue-&gt;evaluated=true;</div>
<div class="disabled">			internalValue-&gt;value=value;</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		Lazy&lt;T&gt;&amp; operator=(const Lazy&lt;T&gt;&amp; lazy)</div>
<div class="disabled">		{</div>
<div class="disabled">			internalValue=lazy.internalValue;</div>
<div class="disabled">			return *this;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Get the evaluation result. If it has not been calculated yet, it will run the evaluation and cache the result. You will not need to calculate for the second time.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;The evaluation result.&lt;/returns&gt;</div>
<div class="disabled">		const T&amp; Value()const</div>
<div class="disabled">		{</div>
<div class="disabled">			if(!internalValue-&gt;evaluated)</div>
<div class="disabled">			{</div>
<div class="disabled">				internalValue-&gt;evaluated=true;</div>
<div class="disabled">				internalValue-&gt;value=internalValue-&gt;evaluator();</div>
<div class="disabled">				internalValue-&gt;evaluator=Func&lt;T()&gt;();</div>
<div class="disabled">			}</div>
<div class="disabled">			return internalValue-&gt;value;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Test if it has already been evaluated or not.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;Returns true if it has already been evaluated.&lt;/returns&gt;</div>
<div class="disabled">		const bool IsEvaluated()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return internalValue-&gt;evaluated;</div>
<div class="disabled">		}</div>

<div class="disabled">		/// &lt;summary&gt;Test if it is an empty evaluation or not.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;returns&gt;Returns true if it is not empty.&lt;/returns&gt;</div>
<div class="disabled">		const bool IsAvailable()const</div>
<div class="disabled">		{</div>
<div class="disabled">			return internalValue;</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>


<div class="token cpp_comment ">/***********************************************************************
.\TUPLE.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Framework::Tuple
	
This file is generated by: Vczh Functional Macro
***********************************************************************/</div>
<div class="disabled">#ifndef VCZH_TUPLE</div>
<div class="disabled">#define VCZH_TUPLE</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	class TupleNullItem</div>
<div class="disabled">	{</div>
<div class="disabled">	};</div>
<div class="disabled">	template&lt;typename T0 = TupleNullItem,typename T1 = TupleNullItem,typename T2 = TupleNullItem,typename T3 = TupleNullItem,typename T4 = TupleNullItem,typename T5 = TupleNullItem,typename T6 = TupleNullItem,typename T7 = TupleNullItem,typename T8 = TupleNullItem,typename T9 = TupleNullItem,typename T10 = TupleNullItem&gt;</div>
<div class="disabled">	class Tuple</div>
<div class="disabled">	{</div>
<div class="disabled">	};</div>
<div class="disabled"> </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0&gt;</div>
<div class="disabled">	class Tuple&lt;T0&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0)</div>
<div class="disabled">			:f0(p0)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0&gt;&amp; a, const Tuple&lt;T0&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1)</div>
<div class="disabled">			:f0(p0),f1(p1)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1&gt;&amp; a, const Tuple&lt;T0,T1&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1,T2&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1,typename T2&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1,T2&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;T2 f2;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1,T2 p2)</div>
<div class="disabled">			:f0(p0),f1(p1),f2(p2)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1,T2&gt;&amp; a, const Tuple&lt;T0,T1,T2&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;if (a.f2 &lt; b.f2) return -1; else if (a.f2 &gt; b.f2) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1,T2&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1,T2&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1,T2&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1,T2&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1,T2&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1,T2&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1,T2,T3&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1,typename T2,typename T3&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1,T2,T3&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;T2 f2;T3 f3;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1,T2 p2,T3 p3)</div>
<div class="disabled">			:f0(p0),f1(p1),f2(p2),f3(p3)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1,T2,T3&gt;&amp; a, const Tuple&lt;T0,T1,T2,T3&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;if (a.f2 &lt; b.f2) return -1; else if (a.f2 &gt; b.f2) return 1;if (a.f3 &lt; b.f3) return -1; else if (a.f3 &gt; b.f3) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1,T2,T3&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1,T2,T3&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1,T2,T3&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1,T2,T3&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1,T2,T3&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1,T2,T3&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1,T2,T3,T4&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1,typename T2,typename T3,typename T4&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1,T2,T3,T4&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;T2 f2;T3 f3;T4 f4;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)</div>
<div class="disabled">			:f0(p0),f1(p1),f2(p2),f3(p3),f4(p4)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1,T2,T3,T4&gt;&amp; a, const Tuple&lt;T0,T1,T2,T3,T4&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;if (a.f2 &lt; b.f2) return -1; else if (a.f2 &gt; b.f2) return 1;if (a.f3 &lt; b.f3) return -1; else if (a.f3 &gt; b.f3) return 1;if (a.f4 &lt; b.f4) return -1; else if (a.f4 &gt; b.f4) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1,T2,T3,T4&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1,T2,T3,T4&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1,T2,T3,T4&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1,T2,T3,T4&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1,T2,T3,T4&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1,T2,T3,T4&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1,T2,T3,T4,T5&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1,typename T2,typename T3,typename T4,typename T5&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1,T2,T3,T4,T5&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;T2 f2;T3 f3;T4 f4;T5 f5;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)</div>
<div class="disabled">			:f0(p0),f1(p1),f2(p2),f3(p3),f4(p4),f5(p5)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; a, const Tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;if (a.f2 &lt; b.f2) return -1; else if (a.f2 &gt; b.f2) return 1;if (a.f3 &lt; b.f3) return -1; else if (a.f3 &gt; b.f3) return 1;if (a.f4 &lt; b.f4) return -1; else if (a.f4 &gt; b.f4) return 1;if (a.f5 &lt; b.f5) return -1; else if (a.f5 &gt; b.f5) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;T2 f2;T3 f3;T4 f4;T5 f5;T6 f6;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)</div>
<div class="disabled">			:f0(p0),f1(p1),f2(p2),f3(p3),f4(p4),f5(p5),f6(p6)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;&amp; a, const Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;if (a.f2 &lt; b.f2) return -1; else if (a.f2 &gt; b.f2) return 1;if (a.f3 &lt; b.f3) return -1; else if (a.f3 &gt; b.f3) return 1;if (a.f4 &lt; b.f4) return -1; else if (a.f4 &gt; b.f4) return 1;if (a.f5 &lt; b.f5) return -1; else if (a.f5 &gt; b.f5) return 1;if (a.f6 &lt; b.f6) return -1; else if (a.f6 &gt; b.f6) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;T2 f2;T3 f3;T4 f4;T5 f5;T6 f6;T7 f7;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)</div>
<div class="disabled">			:f0(p0),f1(p1),f2(p2),f3(p3),f4(p4),f5(p5),f6(p6),f7(p7)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;&amp; a, const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;if (a.f2 &lt; b.f2) return -1; else if (a.f2 &gt; b.f2) return 1;if (a.f3 &lt; b.f3) return -1; else if (a.f3 &gt; b.f3) return 1;if (a.f4 &lt; b.f4) return -1; else if (a.f4 &gt; b.f4) return 1;if (a.f5 &lt; b.f5) return -1; else if (a.f5 &gt; b.f5) return 1;if (a.f6 &lt; b.f6) return -1; else if (a.f6 &gt; b.f6) return 1;if (a.f7 &lt; b.f7) return -1; else if (a.f7 &gt; b.f7) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;T2 f2;T3 f3;T4 f4;T5 f5;T6 f6;T7 f7;T8 f8;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)</div>
<div class="disabled">			:f0(p0),f1(p1),f2(p2),f3(p3),f4(p4),f5(p5),f6(p6),f7(p7),f8(p8)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;&amp; a, const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;if (a.f2 &lt; b.f2) return -1; else if (a.f2 &gt; b.f2) return 1;if (a.f3 &lt; b.f3) return -1; else if (a.f3 &gt; b.f3) return 1;if (a.f4 &lt; b.f4) return -1; else if (a.f4 &gt; b.f4) return 1;if (a.f5 &lt; b.f5) return -1; else if (a.f5 &gt; b.f5) return 1;if (a.f6 &lt; b.f6) return -1; else if (a.f6 &gt; b.f6) return 1;if (a.f7 &lt; b.f7) return -1; else if (a.f7 &gt; b.f7) return 1;if (a.f8 &lt; b.f8) return -1; else if (a.f8 &gt; b.f8) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled">  </div>
<div class="disabled">/***********************************************************************</div>
<div class="disabled">vl::Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;</div>
<div class="disabled">***********************************************************************/</div>
<div class="disabled">	template&lt;typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9&gt;</div>
<div class="disabled">	class Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt; : public Object</div>
<div class="disabled">	{</div>
<div class="disabled">	public:</div>
<div class="disabled">		T0 f0;T1 f1;T2 f2;T3 f3;T4 f4;T5 f5;T6 f6;T7 f7;T8 f8;T9 f9;</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple()</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		Tuple(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)</div>
<div class="disabled">			:f0(p0),f1(p1),f2(p2),f3(p3),f4(p4),f5(p5),f6(p6),f7(p7),f8(p8),f9(p9)</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		static int Compare(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;&amp; a, const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;&amp; b)</div>
<div class="disabled">		{</div>
<div class="disabled">			if (a.f0 &lt; b.f0) return -1; else if (a.f0 &gt; b.f0) return 1;if (a.f1 &lt; b.f1) return -1; else if (a.f1 &gt; b.f1) return 1;if (a.f2 &lt; b.f2) return -1; else if (a.f2 &gt; b.f2) return 1;if (a.f3 &lt; b.f3) return -1; else if (a.f3 &gt; b.f3) return 1;if (a.f4 &lt; b.f4) return -1; else if (a.f4 &gt; b.f4) return 1;if (a.f5 &lt; b.f5) return -1; else if (a.f5 &gt; b.f5) return 1;if (a.f6 &lt; b.f6) return -1; else if (a.f6 &gt; b.f6) return 1;if (a.f7 &lt; b.f7) return -1; else if (a.f7 &gt; b.f7) return 1;if (a.f8 &lt; b.f8) return -1; else if (a.f8 &gt; b.f8) return 1;if (a.f9 &lt; b.f9) return -1; else if (a.f9 &gt; b.f9) return 1;</div>
<div class="disabled">			return 0;</div>
<div class="disabled">		}</div>
<div class="disabled"> </div>
<div class="disabled">		bool operator==(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;&amp; value)const{ return Compare(*this, value) == 0; }</div>
<div class="disabled">		bool operator!=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;&amp; value)const{ return Compare(*this, value) != 0; }</div>
<div class="disabled">		bool operator&lt; (const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;&amp; value)const{ return Compare(*this, value) &lt; 0; }</div>
<div class="disabled">		bool operator&lt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;&amp; value)const{ return Compare(*this, value) &lt;= 0; }</div>
<div class="disabled">		bool operator&gt; (const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;&amp; value)const{ return Compare(*this, value) &gt; 0; }</div>
<div class="disabled">		bool operator&gt;=(const Tuple&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;&amp; value)const{ return Compare(*this, value) &gt;= 0; }</div>
<div class="disabled">	};</div>
<div class="disabled"> </div>
<div class="disabled">}</div>
<div class="disabled">#endif</div>

<div class="token cpp_comment ">/***********************************************************************
.\COLLECTIONS\OPERATION.H
***********************************************************************/</div>
<div class="token cpp_comment ">/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Data Structure::Operations

Functions:
	CopyFrom(TargetContainer, SourceContainer)
	[T]		.Select(T-&gt;K) =&gt; [K]
	[T]		.SelectMany(T-&gt;[K]) =&gt; [K]
	[T]		.Where(T-&gt;bool) =&gt; [T]
	[Ptr&lt;T&gt;].Cast&lt;K&gt;() =&gt; [Ptr&lt;K&gt;]
	[Ptr&lt;T&gt;].FindType&lt;K&gt;() =&gt; [Ptr&lt;K&gt;]
	[T]		.OrderBy(T-&gt;T-&gt;int) =&gt; [T]

	[T]		.Aggregate(T-&gt;T-&gt;T) =&gt; T
	[T]		.Aggregate(T-&gt;T-&gt;T, T) =&gt; T
	[T]		.All(T-&gt;bool) =&gt; bool
	[T]		.Any(T-&gt;bool) =&gt; bool
	[T]		.Max() =&gt; T
	[T]		.Min() =&gt; T
	[T]		.First() =&gt; T
	[T]		.FirstOrDefault(T) =&gt; T
	[T]		.Last() =&gt; T
	[T]		.LastOrDefault(T) =&gt; T
	[T]		.Count() =&gt; vint
	[T]		.IsEmpty() =&gt; bool

	[T]		.Concat([T]) =&gt; [T]
	[T]		.Repeat(vint) =&gt; [T]
	[T]		.Take(vint) =&gt; [T]
	[T]		.Skip(vint) =&gt; [T]
	[T]		.Distinct() =&gt; [T]
	[T]		.Reverse() =&gt; [T]

	[T]		.Pairwise([K]) =&gt; [(T,K)]
	[T]		.Intersect([T]) =&gt; [T]
	[T]		.Union([T]) =&gt; [T]
	[T]		.Except([T]) =&gt; [T]

	[T]		.Evaluate() =&gt; [T]
	[T]		.GroupBy(T-&gt;K) =&gt; [(K, [T])]

	From(begin, end) =&gt; [T]
	From(array) =&gt; [T]
	Range(start, count) =&gt; [vint]

	FOREACH(X, a, XList)
	FOREACH_INDEXER(X, a, index, XList)
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_COLLECTIONS_OPERATION</div>
<div class="disabled">#define VCZH_COLLECTIONS_OPERATION</div>


<div class="disabled">namespace vl</div>
<div class="disabled">{</div>
<div class="disabled">	namespace collections</div>
<div class="disabled">	{</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">OrderBy Quick Sort</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		template&lt;typename T, typename F&gt;</div>
<div class="disabled">		void SortLambda(T* items, vint length, F orderer)</div>
<div class="disabled">		{</div>
<div class="disabled">			if(length==0) return;</div>
<div class="disabled">			vint pivot=0;</div>
<div class="disabled">			vint left=0;</div>
<div class="disabled">			vint right=0;</div>
<div class="disabled">			bool flag=false;</div>

<div class="disabled">			while(left+right+1!=length)</div>
<div class="disabled">			{</div>
<div class="disabled">				vint&amp; mine=(flag?left:right);</div>
<div class="disabled">				vint&amp; theirs=(flag?right:left);</div>
<div class="disabled">				vint candidate=(flag?left:length-right-1);</div>
<div class="disabled">				vint factor=(flag?-1:1);</div>

<div class="disabled">				if(orderer(items[pivot], items[candidate])*factor&lt;=0)</div>
<div class="disabled">				{</div>
<div class="disabled">					mine++;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					theirs++;</div>
<div class="disabled">					T temp=items[pivot];</div>
<div class="disabled">					items[pivot]=items[candidate];</div>
<div class="disabled">					items[candidate]=temp;</div>
<div class="disabled">					pivot=candidate;</div>
<div class="disabled">					flag=!flag;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			SortLambda(items, left, orderer);</div>
<div class="disabled">			SortLambda(items+left+1, right, orderer);</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		void Sort(T* items, vint length, const Func&lt;vint(T, T)&gt;&amp; orderer)</div>
<div class="disabled">		{</div>
<div class="disabled">			SortLambda&lt;T, Func&lt;vint(T, T)&gt;&gt;(items, length, orderer);</div>
<div class="disabled">		}</div>

<div class="disabled">/***********************************************************************</div>
<div class="disabled">LazyList</div>
<div class="disabled">***********************************************************************/</div>

<div class="disabled">		/// &lt;summary&gt;A lazy evaluated readonly container.&lt;/summary&gt;</div>
<div class="disabled">		/// &lt;typeparam name=&quot;T&quot;&gt;The type of elements.&lt;/typeparam&gt;</div>
<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		class LazyList : public Object, public IEnumerable&lt;T&gt;</div>
<div class="disabled">		{</div>
<div class="disabled">		protected:</div>
<div class="disabled">			Ptr&lt;IEnumerator&lt;T&gt;&gt;			enumeratorPrototype;</div>

<div class="disabled">			template&lt;typename U&gt;</div>
<div class="disabled">			static U Element(const IEnumerable&lt;U&gt;&amp;);</div>

<div class="disabled">			IEnumerator&lt;T&gt;* xs()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumeratorPrototype-&gt;Clone();</div>
<div class="disabled">			}</div>
<div class="disabled">		public:</div>
<div class="disabled">			/// &lt;summary&gt;Create a lazy list with an enumerator.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;enumerator&quot;&gt;The enumerator.&lt;/param&gt;</div>
<div class="disabled">			LazyList(IEnumerator&lt;T&gt;* enumerator)</div>
<div class="disabled">				:enumeratorPrototype(enumerator)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a lazy list with an enumerator.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;enumerator&quot;&gt;The enumerator.&lt;/param&gt;</div>
<div class="disabled">			LazyList(Ptr&lt;IEnumerator&lt;T&gt;&gt; enumerator)</div>
<div class="disabled">				:enumeratorPrototype(enumerator)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a lazy list with an enumerable.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;enumerable&quot;&gt;The enumerator.&lt;/param&gt;</div>
<div class="disabled">			LazyList(const IEnumerable&lt;T&gt;&amp; enumerable)</div>
<div class="disabled">				:enumeratorPrototype(enumerable.CreateEnumerator())</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a lazy list with an lazy list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;lazyList&quot;&gt;The lazy list.&lt;/param&gt;</div>
<div class="disabled">			LazyList(const LazyList&lt;T&gt;&amp; lazyList)</div>
<div class="disabled">				:enumeratorPrototype(lazyList.enumeratorPrototype)</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a lazy list with a container.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;TContainer&quot;&gt;Type of the container.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;container&quot;&gt;The container.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename TContainer&gt;</div>
<div class="disabled">			LazyList(Ptr&lt;TContainer&gt; container)</div>
<div class="disabled">				:enumeratorPrototype(new ContainerEnumerator&lt;T, TContainer&gt;(container))</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create an empty lazy list.&lt;/summary&gt;</div>
<div class="disabled">			LazyList()</div>
<div class="disabled">				:enumeratorPrototype(EmptyEnumerable&lt;T&gt;().CreateEnumerator())</div>
<div class="disabled">			{</div>
<div class="disabled">			}</div>

<div class="disabled">			LazyList&lt;T&gt;&amp; operator=(const LazyList&lt;T&gt;&amp; lazyList)</div>
<div class="disabled">			{</div>
<div class="disabled">				enumeratorPrototype=lazyList.enumeratorPrototype;</div>
<div class="disabled">				return *this;</div>
<div class="disabled">			}</div>

<div class="disabled">			IEnumerator&lt;T&gt;* CreateEnumerator()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return enumeratorPrototype-&gt;Clone();</div>
<div class="disabled">			}</div>

<div class="disabled">			//-------------------------------------------------------</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with all elements transformed.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as a transformation function.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename F&gt;</div>
<div class="disabled">			LazyList&lt;FUNCTION_RESULT_TYPE(F)&gt; Select(F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new SelectEnumerator&lt;T, FUNCTION_RESULT_TYPE(F)&gt;(xs(), f);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with all elements that satisfy with a condition.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as a filter.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename F&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Where(F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new WhereEnumerator&lt;T&gt;(xs(), f);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with all elements casted to a new type.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;U&quot;&gt;The new type.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			template&lt;typename U&gt;</div>
<div class="disabled">			LazyList&lt;Ptr&lt;U&gt;&gt; Cast()const</div>
<div class="disabled">			{</div>
<div class="disabled">				Func&lt;Ptr&lt;U&gt;(T)&gt; f=[](T t)-&gt;Ptr&lt;U&gt;{return t.template Cast&lt;U&gt;();};</div>
<div class="disabled">				return new SelectEnumerator&lt;T, Ptr&lt;U&gt;&gt;(xs(), f);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with only elements that successfully casted to a new type.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;U&quot;&gt;The new type.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			template&lt;typename U&gt;</div>
<div class="disabled">			LazyList&lt;Ptr&lt;U&gt;&gt; FindType()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return Cast&lt;U&gt;().Where([](Ptr&lt;U&gt; t){return t;});</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with all elements sorted.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as a comparing function.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename F&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; OrderBy(F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				Ptr&lt;List&lt;T&gt;&gt; sorted=new List&lt;T&gt;;</div>
<div class="disabled">				CopyFrom(*sorted.Obj(), *this);</div>
<div class="disabled">				if(sorted-&gt;Count()&gt;0)</div>
<div class="disabled">				{</div>
<div class="disabled">					SortLambda&lt;T, F&gt;(&amp;sorted-&gt;operator[](0), sorted-&gt;Count(), f);</div>
<div class="disabled">				}</div>
<div class="disabled">				return new ContainerEnumerator&lt;T, List&lt;T&gt;&gt;(sorted);</div>
<div class="disabled">			}</div>

<div class="disabled">			//-------------------------------------------------------</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Aggregate a lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The aggregated value.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as an aggregator.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename F&gt;</div>
<div class="disabled">			T Aggregate(F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				Ptr&lt;IEnumerator&lt;T&gt;&gt; enumerator=CreateEnumerator();</div>
<div class="disabled">				if(!enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					throw Error(L&quot;LazyList&lt;T&gt;::Aggregate(F)#Aggregate failed to calculate from an empty container.&quot;);</div>
<div class="disabled">				}</div>
<div class="disabled">				T result=enumerator-&gt;Current();</div>
<div class="disabled">				while(enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					result=f(result, enumerator-&gt;Current());</div>
<div class="disabled">				}</div>
<div class="disabled">				return result;</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Aggregate a lazy list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;I&quot;&gt;Type of the initial value.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The aggregated value.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;init&quot;&gt;The initial value that is virtually added before the lazy list.&lt;/param&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as an aggregator.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename I, typename F&gt;</div>
<div class="disabled">			I Aggregate(I init, F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				FOREACH(T, t, *this)</div>
<div class="disabled">				{</div>
<div class="disabled">					init=f(init, t);</div>
<div class="disabled">				}</div>
<div class="disabled">				return init;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Test does all elements in the lazy list satisfy with a condition.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if all elements satisfy with a condition.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as a filter.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename F&gt;</div>
<div class="disabled">			bool All(F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return Select(f).Aggregate(true, [](bool a, bool b){return a&amp;&amp;b;});</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Test does any elements in the lazy list satisfy with a condition.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if at least one element satisfies with a condition.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as a filter.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename F&gt;</div>
<div class="disabled">			bool Any(F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return Select(f).Aggregate(false, [](bool a, bool b){return a||b;});</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the maximum value in the lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The maximum value.&lt;/returns&gt;</div>
<div class="disabled">			T Max()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return Aggregate([](T a, T b){return a&gt;b?a:b;});</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get the minimum value in the lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The minimum value.&lt;/returns&gt;</div>
<div class="disabled">			T Min()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return Aggregate([](T a, T b){return a&lt;b?a:b;});</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get the first value in the lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The first value.&lt;/returns&gt;</div>
<div class="disabled">			T First()const</div>
<div class="disabled">			{</div>
<div class="disabled">				Ptr&lt;IEnumerator&lt;T&gt;&gt; enumerator=CreateEnumerator();</div>
<div class="disabled">				if(!enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					throw Error(L&quot;LazyList&lt;T&gt;::First(F)#First failed to calculate from an empty container.&quot;);</div>
<div class="disabled">				}</div>
<div class="disabled">				return enumerator-&gt;Current();</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get the first value in the lazy list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The first value.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;defaultValue&quot;&gt;Returns this argument if the lazy list is empty.&lt;/param&gt;</div>
<div class="disabled">			T First(T defaultValue)const</div>
<div class="disabled">			{</div>
<div class="disabled">				Ptr&lt;IEnumerator&lt;T&gt;&gt; enumerator=CreateEnumerator();</div>
<div class="disabled">				if(!enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					return defaultValue;</div>
<div class="disabled">				}</div>
<div class="disabled">				return enumerator-&gt;Current();</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get the last value in the lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The last value.&lt;/returns&gt;</div>
<div class="disabled">			T Last()const</div>
<div class="disabled">			{</div>
<div class="disabled">				Ptr&lt;IEnumerator&lt;T&gt;&gt; enumerator=CreateEnumerator();</div>
<div class="disabled">				if(!enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					throw Error(L&quot;LazyList&lt;T&gt;::Last(F)#Last failed to calculate from an empty container.&quot;);</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					T value=enumerator-&gt;Current();</div>
<div class="disabled">					while(enumerator-&gt;Next())</div>
<div class="disabled">					{</div>
<div class="disabled">						value=enumerator-&gt;Current();</div>
<div class="disabled">					}</div>
<div class="disabled">					return value;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Get the last value in the lazy list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The last value.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;defaultValue&quot;&gt;Returns this argument if the lazy list is empty.&lt;/param&gt;</div>
<div class="disabled">			T Last(T defaultValue)const</div>
<div class="disabled">			{</div>
<div class="disabled">				Ptr&lt;IEnumerator&lt;T&gt;&gt; enumerator=CreateEnumerator();</div>
<div class="disabled">				while(enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					defaultValue=enumerator-&gt;Current();</div>
<div class="disabled">				}</div>
<div class="disabled">				return defaultValue;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Get the number of elements in the lazy list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The number of elements.&lt;/returns&gt;</div>
<div class="disabled">			vint Count()const</div>
<div class="disabled">			{</div>
<div class="disabled">				vint result=0;</div>
<div class="disabled">				Ptr&lt;IEnumerator&lt;T&gt;&gt; enumerator=CreateEnumerator();</div>
<div class="disabled">				while(enumerator-&gt;Next())</div>
<div class="disabled">				{</div>
<div class="disabled">					result++;</div>
<div class="disabled">				}</div>
<div class="disabled">				return result;</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Test is the lazy list empty.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;Returns true if the lazy list is empty.&lt;/returns&gt;</div>
<div class="disabled">			bool IsEmpty()const</div>
<div class="disabled">			{</div>
<div class="disabled">				Ptr&lt;IEnumerator&lt;T&gt;&gt; enumerator=CreateEnumerator();</div>
<div class="disabled">				return !enumerator-&gt;Next();</div>
<div class="disabled">			}</div>

<div class="disabled">			//-------------------------------------------------------</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list containing elements of the two container one after another.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;remains&quot;&gt;Elements that put after this lazy list.&lt;/param&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Concat(const IEnumerable&lt;T&gt;&amp; remains)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new ConcatEnumerator&lt;T&gt;(xs(), remains.CreateEnumerator());</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with some prefix elements.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;count&quot;&gt;The size of the prefix.&lt;/param&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Take(vint count)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new TakeEnumerator&lt;T&gt;(xs(), count);</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a new lazy list without some prefix elements.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;count&quot;&gt;The size of the prefix.&lt;/param&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Skip(vint count)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new SkipEnumerator&lt;T&gt;(xs(), count);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with several copies of this lazy list one after another.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;count&quot;&gt;The numbers of copies.&lt;/param&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Repeat(vint count)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new RepeatEnumerator&lt;T&gt;(xs(), count);</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with all elements in this lazy list. If some elements appear several times, only one will be kept.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Distinct()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new DistinctEnumerator&lt;T&gt;(xs());</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with all elements in this lazy list in a reverse order.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Reverse()const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new ReverseEnumerator&lt;T&gt;(*this);</div>
<div class="disabled">			}</div>

<div class="disabled">			//-------------------------------------------------------</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list of pairs from elements from two containers.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;U&quot;&gt;Type of all elements in the second container.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;remains&quot;&gt;The second container.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename U&gt;</div>
<div class="disabled">			LazyList&lt;Pair&lt;T, U&gt;&gt; Pairwise(const IEnumerable&lt;U&gt;&amp; remains)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return new PairwiseEnumerator&lt;T, U&gt;(xs(), remains.CreateEnumerator());</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with only elements that appear in both containers.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;remains&quot;&gt;The second container.&lt;/param&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Intersect(const IEnumerable&lt;T&gt;&amp; remains)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return LazyList&lt;T&gt;(new IntersectExceptEnumerator&lt;T, true&gt;(xs(), remains)).Distinct();</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with only elements that appear in this lazy list but not in another container.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;remains&quot;&gt;The second container.&lt;/param&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Except(const IEnumerable&lt;T&gt;&amp; remains)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return LazyList&lt;T&gt;(new IntersectExceptEnumerator&lt;T, false&gt;(xs(), remains)).Distinct();</div>
<div class="disabled">			}</div>
<div class="disabled">			</div>
<div class="disabled">			/// &lt;summary&gt;Create a new lazy list with elements in two containers. If some elements appear several times, only one will be kept.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;remains&quot;&gt;The second container.&lt;/param&gt;</div>
<div class="disabled">			LazyList&lt;T&gt; Union(const IEnumerable&lt;T&gt;&amp; remains)const</div>
<div class="disabled">			{</div>
<div class="disabled">				return Concat(remains).Distinct();</div>
<div class="disabled">			}</div>

<div class="disabled">			//-------------------------------------------------------</div>

<div class="disabled">			LazyList&lt;T&gt; Evaluate()const</div>
<div class="disabled">			{</div>
<div class="disabled">				if(enumeratorPrototype-&gt;Evaluated())</div>
<div class="disabled">				{</div>
<div class="disabled">					return *this;</div>
<div class="disabled">				}</div>
<div class="disabled">				else</div>
<div class="disabled">				{</div>
<div class="disabled">					Ptr&lt;List&lt;T&gt;&gt; xs=new List&lt;T&gt;;</div>
<div class="disabled">					CopyFrom(*xs.Obj(), *this);</div>
<div class="disabled">					return xs;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list, whose elements are from transformed elements in this lazy list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as a transformation function to transform one element to multiple elements.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename F&gt;</div>
<div class="disabled">			FUNCTION_RESULT_TYPE(F) SelectMany(F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				typedef FUNCTION_RESULT_TYPE(F) LazyListU;</div>
<div class="disabled">				typedef typename LazyListU::ElementType U;</div>
<div class="disabled">				return Select(f).Aggregate(LazyList&lt;U&gt;(), [](const LazyList&lt;U&gt;&amp; a, const IEnumerable&lt;U&gt;&amp; b)-&gt;LazyList&lt;U&gt;{return a.Concat(b);});</div>
<div class="disabled">			}</div>

<div class="disabled">			/// &lt;summary&gt;Create a new lazy list, whose elements are groupd by from elements in this lazy list.&lt;/summary&gt;</div>
<div class="disabled">			/// &lt;typeparam name=&quot;F&quot;&gt;Type of the lambda expression.&lt;/typeparam&gt;</div>
<div class="disabled">			/// &lt;returns&gt;The created lazy list.&lt;/returns&gt;</div>
<div class="disabled">			/// &lt;param name=&quot;f&quot;&gt;The lambda expression as a key retriver to calcuate a key from an element.&lt;/param&gt;</div>
<div class="disabled">			template&lt;typename F&gt;</div>
<div class="disabled">			LazyList&lt;Pair&lt;FUNCTION_RESULT_TYPE(F), LazyList&lt;T&gt;&gt;&gt; GroupBy(F f)const</div>
<div class="disabled">			{</div>
<div class="disabled">				typedef FUNCTION_RESULT_TYPE(F) K;</div>
<div class="disabled">				return Select(f)</div>
<div class="disabled">					.Distinct()</div>
<div class="disabled">					.Select([=](K k)</div>
<div class="disabled">					{</div>
<div class="disabled">						return Pair&lt;K, LazyList&lt;T&gt;&gt;(</div>
<div class="disabled">							k,</div>
<div class="disabled">							Where([=](T t){return k==f(t);})</div>
<div class="disabled">							);</div>
<div class="disabled">					});</div>
<div class="disabled">			}</div>
<div class="disabled">		};</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		LazyList&lt;T&gt; Range(T start, T count)</div>
<div class="disabled">		{</div>
<div class="disabled">			return new RangeEnumerator&lt;T&gt;(start, count);</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		LazyList&lt;T&gt; From(const IEnumerable&lt;T&gt;&amp; enumerable)</div>
<div class="disabled">		{</div>
<div class="disabled">			return enumerable;</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		LazyList&lt;T&gt; From(const LazyList&lt;T&gt;&amp; enumerable)</div>
<div class="disabled">		{</div>
<div class="disabled">			return enumerable;</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T&gt;</div>
<div class="disabled">		LazyList&lt;T&gt; From(const T* begin, const T* end)</div>
<div class="disabled">		{</div>
<div class="disabled">			return FromPointer(begin, end);</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T, int size&gt;</div>
<div class="disabled">		LazyList&lt;T&gt; From(T (&amp;items)[size])</div>
<div class="disabled">		{</div>
<div class="disabled">			return FromArray(items);</div>
<div class="disabled">		}</div>

<div class="disabled">		template&lt;typename T, int size&gt;</div>
<div class="disabled">		LazyList&lt;T&gt; From(const T (&amp;items)[size])</div>
<div class="disabled">		{</div>
<div class="disabled">			return FromArray(items);</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>
<div class="disabled">}</div>

<div class="disabled">#endif</div>

<div class="disabled"></div>
</div></div>
<script type="text/javascript">
referencedSymbols = {
};
symbolToFiles = {

};
turnOnSymbol();
</script>
</body>
</html>
