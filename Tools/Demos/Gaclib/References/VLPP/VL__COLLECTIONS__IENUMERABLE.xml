<Document symbolId="vl::collections::IEnumerable" accessor="" category="Class" name="IEnumerable" declFile="Interfaces.h" declId="NI$vl::collections::IEnumerable"><summary>
 An enumerable interface representing all types that provide multiple values in order.
 range-based for-loop is not supported on enumerable yet, current we have &quot;FOREACH&quot; and &quot;FOREACH_INDEXER&quot; for iterating values.
 <symbols><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [Ss] const &amp;, bool)" declFile="OperationCopyFrom.h" declId="FB$vl::collections::CopyFrom@void([Ds] &amp;, [Ss] const &amp;, bool)[impl0]"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, ::vl::vint, bool)" declFile="OperationCopyFrom.h" declId="FB$vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, ::vl::vint, bool)[impl0]"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, [S] const *, bool)" declFile="OperationCopyFrom.h" declId="FB$vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, [S] const *, bool)[impl0]"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, ::vl::ObjectString&lt;[S]&gt; const &amp;, bool)" declFile="OperationString.h" declId="FB$vl::collections::CopyFrom@void([Ds] &amp;, ::vl::ObjectString&lt;[S]&gt; const &amp;, bool)[impl0]"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void(::vl::ObjectString&lt;[D]&gt; &amp;, [Ss] const &amp;, bool)" declFile="OperationString.h" declId="FB$vl::collections::CopyFrom@void(::vl::ObjectString&lt;[D]&gt; &amp;, [Ss] const &amp;, bool)[impl0]"/></symbols> functions work for all enumerable implementation.
 <symbol name="LazyList" docId="vl::collections::LazyList" declFile="Operation.h" declId="NI$vl::collections::LazyList"/> provides high-level operations for enumerables, you can create a lazy list by calling <symbols><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::LazyList&lt;[T]&gt; const &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::LazyList&lt;[T]&gt; const &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const *, [T] const *)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const *, [T] const *)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] [*] &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] [*] &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const [*] &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const [*] &amp;)[impl0]"/></symbols> on any enumerables.
 </summary><example><![CDATA[
 int main()
 {
     List<vint> xs;
     for (vint i = 0; i < 10; i++)
         xs.Add(i);
     List<vint> ys;

     // replace values in ys using xs, it could also be appending instead of replacing, which is controlled by the third argument
     CopyFrom(ys, xs);

     // print ys
     FOREACH(vint, y, ys)
         Console::Write(itow(y) + L" ");
     Console::WriteLine(L"");

     // print ys, added by the position
     FOREACH_INDEXER(vint, y, i, ys)
         Console::Write(itow(y + i) + L" ");
     Console::WriteLine(L"");

     // print all odd numbers in ys
     FOREACH(vint, y, From(ys).Where([](int a){return a % 2 == 1;}))
         Console::Write(itow(y) + L" ");
     Console::WriteLine(L"");
 }
 ]]></example><typeparam name="T">Type of the values in the enumerable.</typeparam><signature><![CDATA[template <
    typename T
>
class IEnumerable
    : Interface;
]]></signature><basetypes><symbol name="Interface" docId="vl::Interface" declFile="Basic.h" declId="NI$vl::Interface"/></basetypes></Document>