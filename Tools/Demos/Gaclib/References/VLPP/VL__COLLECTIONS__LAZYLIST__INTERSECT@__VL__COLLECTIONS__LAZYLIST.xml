<Document symbolId="vl::collections::LazyList::Intersect@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)" accessor="public" category="Function" name="Intersect" declFile="Operation.h" declId="FB$vl::collections::LazyList::Intersect@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)[impl0]"><summary>Create a new lazy list with elements from the lazy list, which also appear in the second container.</summary><returns>The created lazy list. Elements in the create lazy list is in the same order as in this lazy list.</returns><param name="remains">The second container.</param><example><![CDATA[
 int main()
 {
     vint xs[] = {1, 2, 3, 4, 5};
     vint ys[] = {3, 4, 5, 6, 7};
     auto zs = From(xs).Intersect(From(ys));
     FOREACH(vint, z, zs) Console::Write(itow(z) + L" ");
 }
 ]]></example><signature><![CDATA[LazyList<T> Intersect(
    IEnumerable<T> const & remains
) const;
]]></signature><seealsos><symbol name="IEnumerable" docId="vl::collections::IEnumerable" declFile="Interfaces.h" declId="NI$vl::collections::IEnumerable"/><symbol name="LazyList" docId="vl::collections::LazyList" declFile="Operation.h" declId="NI$vl::collections::LazyList"/></seealsos></Document>