<Document symbolId="vl::ReferenceCounterOperator" accessor="" category="Struct" name="ReferenceCounterOperator"><summary>The strategy to get the pointer to the reference counter from an object. If you get the same pointer multiple times from the same object by calling <symbol docId="vl::ReferenceCounterOperator::CreateCounter@::vl::vint volatile *([T] *)" declFile="Pointer.h" declId="FB$vl::ReferenceCounterOperator::CreateCounter@::vl::vint volatile *([T] *)[impl0]"/>, than it is safe to convert a object pointer to a <symbol docId="vl::Ptr" declFile="Pointer.h" declId="NI$vl::Ptr"/>. Currently for reflectable C++ types which inherit from <symbol docId="vl::reflection::DescriptableObject" declFile="GuiTypeDescriptor.h" declId="NI$vl::reflection::DescriptableObject"/> it is yet. For others it is no.</summary><typeparam name="T">The type of the object.</typeparam><typeparam name="Enabled"><symbol docId="vl::Ptr" declFile="Pointer.h" declId="NI$vl::Ptr"/> will always use <symbol declFile="Basic.h" declId="NI$vl::YesType"/> as the second type parameter. This parameter is useful when you want to do partial specialization in the SFINAE way.</typeparam></Document>