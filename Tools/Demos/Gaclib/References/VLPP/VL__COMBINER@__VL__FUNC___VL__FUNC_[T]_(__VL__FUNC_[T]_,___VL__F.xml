<Document symbolId="vl::Combiner@::vl::Func&lt;::vl::Func&lt;[T]&gt;(::vl::Func&lt;[T]&gt;, ::vl::Func&lt;[T]&gt;)&gt;(::vl::Func&lt;::vl::Func@&lt;[R]([TArgs]...)&gt;::ResultType(::vl::Func@&lt;[R]([TArgs]...)&gt;::ResultType, ::vl::Func@&lt;[R]([TArgs]...)&gt;::ResultType)&gt; const &amp;)" accessor="" category="Function" name="Combiner"><summary>Use the converter function to create a combiner, who will receive two function and use <symbol name="Combine" docId="vl::Combine@::vl::Func&lt;::vl::function_combining::Combining@&lt;[R1]([TArgs]...), [R2]([TArgs]...), [R]([R1], [R2])&gt;::FinalFunctionType&gt;(::vl::Func&lt;[C]&gt;, ::vl::Func&lt;[F1]&gt;, ::vl::Func&lt;[F2]&gt;)" declFile="Function.h" declId="FB$vl::Combine@::vl::Func&lt;::vl::function_combining::Combining@&lt;[R1]([TArgs]...), [R2]([TArgs]...), [R]([R1], [R2])&gt;::FinalFunctionType&gt;(::vl::Func&lt;[C]&gt;, ::vl::Func&lt;[F1]&gt;, ::vl::Func&lt;[F2]&gt;)[impl0]"/> to create a combined function. This function assumes the result types of the two provided function in the future are the same, and the converter function will not change the result type.</summary><typeparam name="T">Type of the two functions to combine.</typeparam><returns>The combiner.</returns><param name="converter">The converter function.</param><signature><![CDATA[template <
    typename T
>
Func<Func<T>(
Func<T>, Func<T>)> Combiner(
    Func<Func<T>::ResultType(
Func<T>::ResultType, Func<T>::ResultType)> const & converter
);
]]></signature><seealsos><symbol name="Func" declFile="Function.h" declId="NI$vl::Func"/><symbol name="ResultType" declFile="Function.h" declId="NI$vl::Func@&lt;[R]([TArgs]...)&gt;::ResultType"/></seealsos></Document>