<Document symbolId="vl::collections::LazyList" accessor="" category="Class" name="LazyList" declFile="Operation.h" declId="NI$vl::collections::LazyList"><summary>A lazy evaluated container with rich operations. <symbols><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::LazyList&lt;[T]&gt; const &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::LazyList&lt;[T]&gt; const &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const *, [T] const *)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const *, [T] const *)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] [*] &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] [*] &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const [*] &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const [*] &amp;)[impl0]"/></symbols> is useful to create lazy list from arrays or containers.</summary><typeparam name="T">The type of elements.</typeparam><remarks>
 A lazy list is usually created directly from a container source, or from a calculation on a source.
 Typically the lazy list cannot be used after the source is deleted.
 If this lazy list needs to be used after the source is deleted,
 you are recommended to use <symbol name="Evaluate" docId="vl::collections::LazyList::Evaluate@::vl::collections::LazyList&lt;[T]&gt;(bool)" declFile="Operation.h" declId="FB$vl::collections::LazyList::Evaluate@::vl::collections::LazyList&lt;[T]&gt;(bool)[impl0]"/>, <b>with forceCopy set to true</b>.
 In this way you get a lazy list with all values copied, they do not rely on other objects.
 </remarks><signature><![CDATA[template <
    typename T
>
class LazyList
    : Object
    , IEnumerable<T>;
]]></signature><basetypes><symbol name="Object" docId="vl::Object" declFile="Basic.h" declId="NI$vl::Object"/><symbol name="IEnumerable" docId="vl::collections::IEnumerable" declFile="Interfaces.h" declId="NI$vl::collections::IEnumerable"/></basetypes></Document>