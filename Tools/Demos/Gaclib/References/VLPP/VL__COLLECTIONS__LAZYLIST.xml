<Document accessor="" category="Class" name="LazyList"><summary>A lazy evaluated container with rich operations. <symbols><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::LazyList&lt;[T]&gt; const &amp;)"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const *, [T] const *)"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] [*] &amp;)"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const [*] &amp;)"/></symbols> is useful to create lazy list from arrays or containers.</summary><typeparam name="T">The type of elements.</typeparam><remarks><p>A lazy list is usually created directly from a container source, or from a calculation on a source.</p><p>Typically the lazy list cannot be used after the source is deleted.</p><p>
 If this lazy list needs to be used after the source is deleted,
 you are recommended to use <symbol name="Evaluate" docId="vl::collections::LazyList::Evaluate@::vl::collections::LazyList&lt;[T]&gt;(bool)"/>, <b>with forceCopy set to true</b>.
 </p><p>In this way you get a lazy list with all values copied, they do not rely on other objects.</p></remarks><signature><![CDATA[template <
    typename T
>
class LazyList
    : Object
    , IEnumerable<T>;
]]></signature><basetypes><symbol name="Object" docId="vl::Object"/><symbol name="IEnumerable" docId="vl::collections::IEnumerable"/></basetypes></Document>