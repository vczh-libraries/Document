<!DOCTYPE html>
<html>
<head>
    <title>xstddef</title>
    <link rel="stylesheet" href="../Cpp.css" />
    <link rel="shortcut icon" href="../favicon.ico" />
    <script type="text/javascript" src="../Cpp.js" ></script>
</head>
<body>
<a class="button" href="./FileIndex.html">File Index</a>
<a class="button" href="./SymbolIndex.html">Symbol Index</a>
<br>
<br>
<div class="codebox"><div class="cpp_default"><div class="token cpp_comment ">// xstddef internal header (core)</div>
#pragma once
<div class="disabled">#ifndef _XSTDDEF_</div>
<div class="disabled">#define _XSTDDEF_</div>
<div class="disabled">#ifndef RC_INVOKED
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;initializer_list&gt;</div>
<div class="disabled">#include &lt;xtr1common&gt;</div>

<div class="expandable"><div class="disabled"> #pragma pack(push,_CRT_PACKING)</div>
<div class="expanded">#pragma pack(push,<div class="token cpp_number ">8</div>)</div></div>
<div class="expandable"><div class="disabled"> #pragma warning(push,_STL_WARNING_LEVEL)</div>
<div class="expanded">#pragma warning(push,<div class="token cpp_number ">3</div>)</div></div>
<div class="expandable"><div class="disabled"> #pragma warning(disable: _STL_DISABLED_WARNINGS)</div>
<div class="expanded">#pragma warning(disable: <div class="token cpp_number ">4455</div> <div class="token cpp_number ">4494</div>  <div class="token cpp_number ">4619</div> <div class="token cpp_number ">4643</div> <div class="token cpp_number ">4702</div> <div class="token cpp_number ">4984</div> <div class="token cpp_number ">4988</div> )</div></div>
<div class="disabled"> _STL_DISABLE_CLANG_WARNINGS</div>
<div class="disabled"> #pragma push_macro(&quot;new&quot;)</div>
<div class="disabled"> #undef new</div>

<div class="expandable"><div class="disabled">_STD_BEGIN</div>
<div class="expanded"><div class="token cpp_keyword ">namespace</div> <div class="def" id="NF[7]$std"><div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div></div> {</div></div>
		<div class="token cpp_comment ">// TYPE DEFINITIONS</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div>&gt;
	<div class="token cpp_comment ">// false value attached to a dependent name (for static_assert)</div>
<div class="expandable"><div class="disabled">	_INLINE_VAR constexpr bool _Always_false = false;</div>
<div class="expanded">	 <div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::_Always_false"><div><div class="token cpp_enum">_Always_false</div></div></div> = <div class="token cpp_keyword ">false</div>;</div></div>

		<div class="token cpp_comment ">// FUNCTIONAL STUFF (from &lt;functional&gt;)</div>
<div class="disabled"> #if _HAS_AUTO_PTR_ETC</div>
		<div class="token cpp_comment ">// STRUCT TEMPLATE unary_function</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::unary_function::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::unary_function::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::unary_function"><div><div class="token cpp_type">unary_function</div></div></div>
	{	<div class="token cpp_comment ">// base class for unary functions</div>
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div> <div class="def" id="NI$std::unary_function::argument_type"><div><div class="token cpp_type">argument_type</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="NI$std::unary_function::result_type"><div><div class="token cpp_type">result_type</div></div></div>;
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE binary_function</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::binary_function::_Arg1"><div><div class="token cpp_type">_Arg1</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::binary_function::_Arg2"><div><div class="token cpp_type">_Arg2</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::binary_function::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::binary_function"><div><div class="token cpp_type">binary_function</div></div></div>
	{	<div class="token cpp_comment ">// base class for binary functions</div>
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_function::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div> <div class="def" id="NI$std::binary_function::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_function::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div> <div class="def" id="NI$std::binary_function::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_function::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="NI$std::binary_function::result_type"><div><div class="token cpp_type">result_type</div></div></div>;
	};
<div class="disabled"> #endif /* _HAS_AUTO_PTR_ETC */</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE plus</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::plus::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::plus"><div class="ref" onclick="jumpToSymbol([], [], ['std::plus@<void>'], [])"><div class="token cpp_type">plus</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator+</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::plus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::plus::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::plus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::plus::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::plus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::plus::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::plus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::plus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::plus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator+ to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> + <div class="ref" onclick="jumpToSymbol([], ['std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE minus</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::minus::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::minus"><div class="ref" onclick="jumpToSymbol([], [], ['std::minus@<void>'], [])"><div class="token cpp_type">minus</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator-</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::minus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::minus::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::minus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::minus::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::minus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::minus::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::minus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::minus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::minus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator- to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> - <div class="ref" onclick="jumpToSymbol([], ['std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE multiplies</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::multiplies::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::multiplies"><div class="ref" onclick="jumpToSymbol([], [], ['std::multiplies@<void>'], [])"><div class="token cpp_type">multiplies</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator*</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::multiplies::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::multiplies::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::multiplies::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::multiplies::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::multiplies::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::multiplies::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::multiplies::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::multiplies::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::multiplies::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator* to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> * <div class="ref" onclick="jumpToSymbol([], ['std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE equal_to</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::equal_to::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::equal_to"><div class="ref" onclick="jumpToSymbol([], [], ['std::equal_to@<void>'], [])"><div class="token cpp_type">equal_to</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator==</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::equal_to::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::equal_to::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::equal_to::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::equal_to::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::equal_to::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::equal_to::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::equal_to::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator== to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> == <div class="ref" onclick="jumpToSymbol([], ['std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE not_equal_to</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::not_equal_to::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::not_equal_to"><div class="ref" onclick="jumpToSymbol([], [], ['std::not_equal_to@<void>'], [])"><div class="token cpp_type">not_equal_to</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator!=</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::not_equal_to::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::not_equal_to::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::not_equal_to::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator!= to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> != <div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE greater</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::greater::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::greater"><div class="ref" onclick="jumpToSymbol([], [], ['std::greater@<void>'], [])"><div class="token cpp_type">greater</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator&gt;</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::greater::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::greater::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::greater::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::greater::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::greater::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::greater::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::greater::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator&gt; to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> &gt; <div class="ref" onclick="jumpToSymbol([], ['std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE less</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::less::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::less"><div class="ref" onclick="jumpToSymbol([], [], ['std::less@<void>'], [])"><div class="token cpp_type">less</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator&lt;</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::less::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::less::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::less::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::less::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::less::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::less::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::less::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator&lt; to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> &lt; <div class="ref" onclick="jumpToSymbol([], ['std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE greater_equal</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::greater_equal::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::greater_equal"><div class="ref" onclick="jumpToSymbol([], [], ['std::greater_equal@<void>'], [])"><div class="token cpp_type">greater_equal</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator&gt;=</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::greater_equal::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::greater_equal::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::greater_equal::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::greater_equal::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::greater_equal::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::greater_equal::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::greater_equal::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator&gt;= to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> &gt;= <div class="ref" onclick="jumpToSymbol([], ['std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE less_equal</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::less_equal::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::less_equal"><div class="ref" onclick="jumpToSymbol([], [], ['std::less_equal@<void>'], [])"><div class="token cpp_type">less_equal</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator&lt;=</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::less_equal::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::less_equal::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::less_equal::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::less_equal::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::less_equal::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::less_equal::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::less_equal::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator&lt;= to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> &lt;= <div class="ref" onclick="jumpToSymbol([], ['std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION plus</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::plus@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::plus'])"><div class="token cpp_type">plus</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator+</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::plus@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			+ <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator+ to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			+ <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION minus</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::minus@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::minus'])"><div class="token cpp_type">minus</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator-</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::minus@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			- <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator- to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			- <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION multiplies</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::multiplies@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::multiplies'])"><div class="token cpp_type">multiplies</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator*</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::multiplies@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			* <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator* to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			* <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION equal_to</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::equal_to@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::equal_to'])"><div class="token cpp_type">equal_to</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator==</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::equal_to@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			== <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator== to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			== <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION not_equal_to</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::not_equal_to@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::not_equal_to'])"><div class="token cpp_type">not_equal_to</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator!=</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::not_equal_to@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			!= <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator!= to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			!= <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION greater</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::greater@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::greater'])"><div class="token cpp_type">greater</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator&gt;</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::greater@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			&gt; <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator&gt; to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			&gt; <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION less</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::less@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::less'])"><div class="token cpp_type">less</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator&lt;</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::less@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			&lt; <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator&lt; to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			&lt; <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION greater_equal</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::greater_equal@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::greater_equal'])"><div class="token cpp_type">greater_equal</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator&gt;=</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::greater_equal@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			&gt;= <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator&gt;= to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			&gt;= <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION less_equal</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::less_equal@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::less_equal'])"><div class="token cpp_type">less_equal</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator&lt;=</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::less_equal@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			&lt;= <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))
		{	<div class="token cpp_comment ">// transparently apply operator&lt;= to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
			&lt;= <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp;&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}
	};

		<div class="token cpp_comment ">// FUNCTION TEMPLATE addressof</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::addressof@[_Ty] *([_Ty] &)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD constexpr _Ty * addressof(_Ty&amp; _Val) noexcept</div>
<div class="expanded">	 <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::addressof@[_Ty] *([_Ty] &)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> * <div class="def" id="FB$std::addressof@[_Ty] *([_Ty] &)[impl0]"><div><div class="token cpp_function">addressof</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::addressof@[_Ty] *([_Ty] &)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::addressof@[_Ty] *([_Ty] &)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>) <div class="token cpp_keyword ">noexcept</div></div></div>
	{	<div class="token cpp_comment ">// return address of _Val</div>
	<div class="token cpp_keyword ">return</div> (__builtin_addressof(<div class="ref" onclick="jumpToSymbol([], ['std::addressof@[_Ty] *([_Ty] &)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::addressof@[_Ty] const *([_Ty] const &&)[decl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
	<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::addressof@[_Ty] const *([_Ty] const &&)[decl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> * <div class="def" id="FB$std::addressof@[_Ty] const *([_Ty] const &&)[decl0]"><div><div class="token cpp_function">addressof</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::addressof@[_Ty] const *([_Ty] const &&)[decl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp;&amp;) = <div class="token cpp_keyword ">delete</div>;

		<div class="token cpp_comment ">// FUNCTION TEMPLATE _Unfancy</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Unfancy@auto([_Ptrty])[impl0]::_Ptrty"><div><div class="token cpp_type">_Ptrty</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Unfancy@auto([_Ptrty])[impl0]"><div><div class="token cpp_function">_Unfancy</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Unfancy@auto([_Ptrty])[impl0]::_Ptrty'], [], [])"><div class="token cpp_type">_Ptrty</div></div> <div class="def" id="NI$std::_Unfancy@auto([_Ptrty])[impl0]::_Ptr"><div><div class="token cpp_argument">_Ptr</div></div></div>)
	{	<div class="token cpp_comment ">// converts from a fancy pointer to a plain pointer</div>
<div class="expandable"><div class="disabled">	return (_STD addressof(*_Ptr));</div>
<div class="expanded">	<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::addressof@[_Ty] *([_Ty] &)', 'std::addressof@[_Ty] const *([_Ty] const &&)'], ['std::addressof@[_Ty] *([_Ty] &)', 'std::addressof@[_Ty] const *([_Ty] const &&)'], [], [])"><div class="token cpp_function">addressof</div></div>(*<div class="ref" onclick="jumpToSymbol([], ['std::_Unfancy@auto([_Ptrty])[impl0]::_Ptr'], [], [])"><div class="token cpp_argument">_Ptr</div></div>));</div></div>
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="ref" onclick="jumpToSymbol([], ['std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> * <div class="def" id="FB$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]"><div><div class="token cpp_function">_Unfancy</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> * <div class="def" id="NI$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ptr"><div><div class="token cpp_argument">_Ptr</div></div></div>)
	{	<div class="token cpp_comment ">// do nothing for plain pointers</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ptr'], [], [])"><div class="token cpp_argument">_Ptr</div></div>);
	}
<div class="expandable"><div class="disabled">_STD_END</div>
<div class="expanded">}</div></div>

<div class="disabled">#define _EMIT_CDECL(FUNC, OPT1, OPT2, OPT3) \</div>
<div class="disabled">	FUNC(__cdecl, OPT1, OPT2, OPT3)</div>

<div class="disabled"> #ifdef _M_CEE</div>
<div class="disabled">#define _EMIT_CLRCALL(FUNC, OPT1, OPT2, OPT3) \</div>
<div class="disabled">	FUNC(__clrcall, OPT1, OPT2, OPT3)</div>

<div class="disabled"> #else /* _M_CEE */</div>
<div class="disabled">#define _EMIT_CLRCALL(FUNC, OPT1, OPT2, OPT3)
 #endif /* _M_CEE */</div>

<div class="disabled"> #if defined(_M_IX86) &amp;&amp; !defined(_M_CEE)</div>
<div class="disabled">#define _EMIT_FASTCALL(FUNC, OPT1, OPT2, OPT3) \</div>
<div class="disabled">	FUNC(__fastcall, OPT1, OPT2, OPT3)</div>

<div class="disabled"> #else /* defined(_M_IX86) &amp;&amp; !defined(_M_CEE) */</div>
<div class="disabled">#define _EMIT_FASTCALL(FUNC, OPT1, OPT2, OPT3)
 #endif /* defined(_M_IX86) &amp;&amp; !defined(_M_CEE) */</div>

<div class="disabled"> #ifdef _M_IX86</div>
<div class="disabled">#define _EMIT_STDCALL(FUNC, OPT1, OPT2, OPT3) \</div>
<div class="disabled">	FUNC(__stdcall, OPT1, OPT2, OPT3)</div>
<div class="disabled">#define _EMIT_THISCALL(FUNC, OPT1, OPT2, OPT3) \</div>
<div class="disabled">	FUNC(__thiscall, OPT1, OPT2, OPT3)</div>

<div class="disabled"> #else /* _M_IX86 */</div>
<div class="disabled">#define _EMIT_STDCALL(FUNC, OPT1, OPT2, OPT3)</div>
<div class="disabled">#define _EMIT_THISCALL(FUNC, OPT1, OPT2, OPT3)
 #endif /* _M_IX86 */</div>

<div class="disabled"> #if ((defined(_M_IX86) &amp;&amp; _M_IX86_FP &gt;= 2) \</div>
<div class="disabled">	|| defined(_M_X64)) &amp;&amp; !defined(_M_CEE)</div>
<div class="disabled">#define _EMIT_VECTORCALL(FUNC, OPT1, OPT2, OPT3) \</div>
<div class="disabled">	FUNC(__vectorcall, OPT1, OPT2, OPT3)</div>
<div class="disabled"></div>
<div class="disabled"> #else /* defined(_M_IX86) &amp;&amp; _M_IX86_FP &gt;= 2 etc. */
#define _EMIT_VECTORCALL(FUNC, OPT1, OPT2, OPT3)
 #endif /* defined(_M_IX86) &amp;&amp; _M_IX86_FP &gt;= 2 etc. */</div>

<div class="disabled">#define _NON_MEMBER_CALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_CDECL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_CLRCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_FASTCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_STDCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_VECTORCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)</div>

<div class="disabled">#define _NON_MEMBER_CALL_CV(FUNC, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_NON_MEMBER_CALL(FUNC, , REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_NON_MEMBER_CALL(FUNC, const, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_NON_MEMBER_CALL(FUNC, volatile, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_NON_MEMBER_CALL(FUNC, const volatile, REF_OPT, NOEXCEPT_OPT)</div>

<div class="disabled">#define _NON_MEMBER_CALL_CV_REF(FUNC, NOEXCEPT_OPT) \</div>
<div class="disabled">	_NON_MEMBER_CALL_CV(FUNC, , NOEXCEPT_OPT) \</div>
<div class="disabled">	_NON_MEMBER_CALL_CV(FUNC, &amp;, NOEXCEPT_OPT) \</div>
<div class="disabled">	_NON_MEMBER_CALL_CV(FUNC, &amp;&amp;, NOEXCEPT_OPT)</div>

<div class="disabled">#if _HAS_NOEXCEPT_FUNCTION_TYPES</div>
<div class="disabled"> #define _NON_MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \</div>
<div class="disabled">	_NON_MEMBER_CALL_CV_REF(FUNC, ) \</div>
<div class="disabled">	_NON_MEMBER_CALL_CV_REF(FUNC, noexcept)
#else /* _HAS_NOEXCEPT_FUNCTION_TYPES */</div>
<div class="disabled"> #define _NON_MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \</div>
<div class="disabled">	_NON_MEMBER_CALL_CV_REF(FUNC, )
#endif /* _HAS_NOEXCEPT_FUNCTION_TYPES */</div>

<div class="disabled">#define _MEMBER_CALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_CDECL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_CLRCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_FASTCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_STDCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_THISCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_EMIT_VECTORCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)</div>

<div class="disabled">#define _MEMBER_CALL_CV(FUNC, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_MEMBER_CALL(FUNC, , REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_MEMBER_CALL(FUNC, const, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_MEMBER_CALL(FUNC, volatile, REF_OPT, NOEXCEPT_OPT) \</div>
<div class="disabled">	_MEMBER_CALL(FUNC, const volatile, REF_OPT, NOEXCEPT_OPT)</div>

<div class="disabled">#define _MEMBER_CALL_CV_REF(FUNC, NOEXCEPT_OPT) \</div>
<div class="disabled">	_MEMBER_CALL_CV(FUNC, , NOEXCEPT_OPT) \</div>
<div class="disabled">	_MEMBER_CALL_CV(FUNC, &amp;, NOEXCEPT_OPT) \</div>
<div class="disabled">	_MEMBER_CALL_CV(FUNC, &amp;&amp;, NOEXCEPT_OPT)</div>

<div class="disabled">#if _HAS_NOEXCEPT_FUNCTION_TYPES</div>
<div class="disabled"> #define _MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \</div>
<div class="disabled">	_MEMBER_CALL_CV_REF(FUNC, ) \</div>
<div class="disabled">	_MEMBER_CALL_CV_REF(FUNC, noexcept)
#else /* _HAS_NOEXCEPT_FUNCTION_TYPES */</div>
<div class="disabled"> #define _MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \</div>
<div class="disabled">	_MEMBER_CALL_CV_REF(FUNC, )
#endif /* _HAS_NOEXCEPT_FUNCTION_TYPES */</div>

<div class="disabled">#define _CLASS_DEFINE_CONST(CLASS) \</div>
<div class="disabled">	CLASS(_EMPTY_ARGUMENT) \</div>
<div class="disabled">	CLASS(const)</div>

<div class="disabled">#define _CLASS_DEFINE_CV(CLASS) \</div>
<div class="disabled">	CLASS(_EMPTY_ARGUMENT) \</div>
<div class="disabled">	CLASS(const) \</div>
<div class="disabled">	CLASS(volatile) \</div>
<div class="disabled">	CLASS(const volatile)</div>

<div class="disabled">#if _HAS_NOEXCEPT_FUNCTION_TYPES</div>
<div class="disabled"> #define _CLASS_DEFINE_CV_REF_NOEXCEPT(CLASS) \</div>
<div class="disabled">	CLASS(_EMPTY_ARGUMENT) \</div>
<div class="disabled">	CLASS(const) \</div>
<div class="disabled">	CLASS(volatile) \</div>
<div class="disabled">	CLASS(const volatile) \</div>
<div class="disabled">	CLASS(&amp;) \</div>
<div class="disabled">	CLASS(const &amp;) \</div>
<div class="disabled">	CLASS(volatile &amp;) \</div>
<div class="disabled">	CLASS(const volatile &amp;) \</div>
<div class="disabled">	CLASS(&amp;&amp;) \</div>
<div class="disabled">	CLASS(const &amp;&amp;) \</div>
<div class="disabled">	CLASS(volatile &amp;&amp;) \</div>
<div class="disabled">	CLASS(const volatile &amp;&amp;) \</div>
<div class="disabled">	CLASS(noexcept) \</div>
<div class="disabled">	CLASS(const noexcept) \</div>
<div class="disabled">	CLASS(volatile noexcept) \</div>
<div class="disabled">	CLASS(const volatile noexcept) \</div>
<div class="disabled">	CLASS(&amp; noexcept) \</div>
<div class="disabled">	CLASS(const &amp; noexcept) \</div>
<div class="disabled">	CLASS(volatile &amp; noexcept) \</div>
<div class="disabled">	CLASS(const volatile &amp; noexcept) \</div>
<div class="disabled">	CLASS(&amp;&amp; noexcept) \</div>
<div class="disabled">	CLASS(const &amp;&amp; noexcept) \</div>
<div class="disabled">	CLASS(volatile &amp;&amp; noexcept) \</div>
<div class="disabled">	CLASS(const volatile &amp;&amp; noexcept)
#else /* _HAS_NOEXCEPT_FUNCTION_TYPES */</div>
<div class="disabled"> #define _CLASS_DEFINE_CV_REF_NOEXCEPT(CLASS) \</div>
<div class="disabled">	CLASS(_EMPTY_ARGUMENT) \</div>
<div class="disabled">	CLASS(const) \</div>
<div class="disabled">	CLASS(volatile) \</div>
<div class="disabled">	CLASS(const volatile) \</div>
<div class="disabled">	CLASS(&amp;) \</div>
<div class="disabled">	CLASS(const &amp;) \</div>
<div class="disabled">	CLASS(volatile &amp;) \</div>
<div class="disabled">	CLASS(const volatile &amp;) \</div>
<div class="disabled">	CLASS(&amp;&amp;) \</div>
<div class="disabled">	CLASS(const &amp;&amp;) \</div>
<div class="disabled">	CLASS(volatile &amp;&amp;) \</div>
<div class="disabled">	CLASS(const volatile &amp;&amp;)
#endif /* _HAS_NOEXCEPT_FUNCTION_TYPES */</div>

<div class="disabled"> #pragma pop_macro(&quot;new&quot;)</div>
<div class="disabled"> _STL_RESTORE_CLANG_WARNINGS</div>
<div class="expandable"><div class="disabled"> #pragma warning(pop)</div>
<div class="expanded">#pragma warning(pop)</div></div>
<div class="expandable"><div class="disabled"> #pragma pack(pop)
#endif /* RC_INVOKED */
#endif /* _XSTDDEF_ */</div>
<div class="expanded">#pragma pack(pop)</div></div>

<div class="token cpp_comment ">/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */</div>
<div class="disabled"></div>
</div></div>
<script type="text/javascript">
referencedSymbols = {
    'std': {
        'displayNameInHtml': 'std',
        'impls': [],
        'decls': [
            'NF[0]$std',
            'NF[1]$std',
            'NF[2]$std',
            'NF[3]$std',
            'NF[4]$std',
            'NF[5]$std',
            'NF[6]$std',
            'NF[7]$std',
            'NF[8]$std',
            'NF[9]$std',
            'NF[10]$std',
            'NF[11]$std',
            'NF[12]$std',
            'NF[13]$std',
            'NF[14]$std',
            'NF[15]$std',
            'NF[16]$std',
            'NF[17]$std',
            'NF[18]$std',
            'NF[19]$std',
            'NF[20]$std',
            'NF[21]$std',
            'NF[22]$std',
            'NF[23]$std',
            'NF[24]$std',
            'NF[25]$std',
            'NF[26]$std',
            'NF[27]$std',
            'NF[28]$std',
            'NF[29]$std',
            'NF[30]$std',
            'NF[31]$std',
            'NF[32]$std',
            'NF[33]$std',
            'NF[34]$std',
            'NF[35]$std',
            'NF[36]$std',
            'NF[37]$std',
            'NF[38]$std',
            'NF[39]$std',
            'NF[40]$std',
            'NF[41]$std',
            'NF[42]$std',
            'NF[43]$std',
            'NF[44]$std',
            'NF[45]$std',
            'NF[46]$std',
            'NF[47]$std',
            'NF[48]$std',
            'NF[49]$std',
            'NF[50]$std',
            'NF[51]$std',
            'NF[52]$std',
            'NF[53]$std',
            'NF[54]$std',
            'NF[55]$std',
            'NF[56]$std',
            'NF[57]$std',
            'NF[58]$std',
            'NF[59]$std',
            'NF[60]$std',
            'NF[61]$std'
        ]
    },
    'std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::_Unfancy@auto([_Ptrty])[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Unfancy@auto([_Ptrty])[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Unfancy@auto([_Ptrty])[impl0]::_Ptrty': {
        'displayNameInHtml': '<span class="cpp_type">_Ptrty</span>',
        'impls': [
            'TA$std::_Unfancy@auto([_Ptrty])[impl0]::_Ptrty'
        ],
        'decls': []
    },
    'std::addressof@[_Ty] *([_Ty] &)': {
        'displayNameInHtml': '<span class="cpp_function">addressof</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span> &)',
        'impls': [
            'FB$std::addressof@[_Ty] *([_Ty] &)[impl0]'
        ],
        'decls': []
    },
    'std::addressof@[_Ty] *([_Ty] &)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::addressof@[_Ty] *([_Ty] &)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::addressof@[_Ty] *([_Ty] &)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::addressof@[_Ty] *([_Ty] &)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::addressof@[_Ty] const *([_Ty] const &&)': {
        'displayNameInHtml': '<span class="cpp_function">addressof</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span><span class="cpp_keyword"> const</span> &&)',
        'impls': [],
        'decls': [
            'FB$std::addressof@[_Ty] const *([_Ty] const &&)[decl0]'
        ]
    },
    'std::addressof@[_Ty] const *([_Ty] const &&)[decl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::addressof@[_Ty] const *([_Ty] const &&)[decl0]::_Ty'
        ],
        'decls': []
    },
    'std::binary_function::_Arg1': {
        'displayNameInHtml': '<span class="cpp_type">_Arg1</span>',
        'impls': [
            'TA$std::binary_function::_Arg1'
        ],
        'decls': []
    },
    'std::binary_function::_Arg2': {
        'displayNameInHtml': '<span class="cpp_type">_Arg2</span>',
        'impls': [
            'TA$std::binary_function::_Arg2'
        ],
        'decls': []
    },
    'std::binary_function::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::binary_function::_Result'
        ],
        'decls': []
    },
    'std::equal_to': {
        'displayNameInHtml': '<span class="cpp_type">equal_to</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::equal_to'
        ],
        'decls': []
    },
    'std::equal_to::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::equal_to::_Ty'
        ],
        'decls': []
    },
    'std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::equal_to@<void>': {
        'displayNameInHtml': '<span class="cpp_type">equal_to</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::equal_to@<void>'
        ],
        'decls': []
    },
    'std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::greater': {
        'displayNameInHtml': '<span class="cpp_type">greater</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::greater'
        ],
        'decls': []
    },
    'std::greater::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::greater::_Ty'
        ],
        'decls': []
    },
    'std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::greater@<void>': {
        'displayNameInHtml': '<span class="cpp_type">greater</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::greater@<void>'
        ],
        'decls': []
    },
    'std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::greater_equal': {
        'displayNameInHtml': '<span class="cpp_type">greater_equal</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::greater_equal'
        ],
        'decls': []
    },
    'std::greater_equal::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::greater_equal::_Ty'
        ],
        'decls': []
    },
    'std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::greater_equal@<void>': {
        'displayNameInHtml': '<span class="cpp_type">greater_equal</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::greater_equal@<void>'
        ],
        'decls': []
    },
    'std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::less': {
        'displayNameInHtml': '<span class="cpp_type">less</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::less'
        ],
        'decls': []
    },
    'std::less::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::less::_Ty'
        ],
        'decls': []
    },
    'std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::less@<void>': {
        'displayNameInHtml': '<span class="cpp_type">less</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::less@<void>'
        ],
        'decls': []
    },
    'std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::less_equal': {
        'displayNameInHtml': '<span class="cpp_type">less_equal</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::less_equal'
        ],
        'decls': []
    },
    'std::less_equal::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::less_equal::_Ty'
        ],
        'decls': []
    },
    'std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::less_equal@<void>': {
        'displayNameInHtml': '<span class="cpp_type">less_equal</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::less_equal@<void>'
        ],
        'decls': []
    },
    'std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::minus': {
        'displayNameInHtml': '<span class="cpp_type">minus</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::minus'
        ],
        'decls': []
    },
    'std::minus::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::minus::_Ty'
        ],
        'decls': []
    },
    'std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::minus@<void>': {
        'displayNameInHtml': '<span class="cpp_type">minus</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::minus@<void>'
        ],
        'decls': []
    },
    'std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::multiplies': {
        'displayNameInHtml': '<span class="cpp_type">multiplies</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::multiplies'
        ],
        'decls': []
    },
    'std::multiplies::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::multiplies::_Ty'
        ],
        'decls': []
    },
    'std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::multiplies@<void>': {
        'displayNameInHtml': '<span class="cpp_type">multiplies</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::multiplies@<void>'
        ],
        'decls': []
    },
    'std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::not_equal_to': {
        'displayNameInHtml': '<span class="cpp_type">not_equal_to</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::not_equal_to'
        ],
        'decls': []
    },
    'std::not_equal_to::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::not_equal_to::_Ty'
        ],
        'decls': []
    },
    'std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::not_equal_to@<void>': {
        'displayNameInHtml': '<span class="cpp_type">not_equal_to</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::not_equal_to@<void>'
        ],
        'decls': []
    },
    'std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::plus': {
        'displayNameInHtml': '<span class="cpp_type">plus</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::plus'
        ],
        'decls': []
    },
    'std::plus::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::plus::_Ty'
        ],
        'decls': []
    },
    'std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::plus@<void>': {
        'displayNameInHtml': '<span class="cpp_type">plus</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::plus@<void>'
        ],
        'decls': []
    },
    'std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::unary_function::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::unary_function::_Arg'
        ],
        'decls': []
    },
    'std::unary_function::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::unary_function::_Result'
        ],
        'decls': []
    }
};
symbolToFiles = {
    'FB$std::addressof@[_Ty] *([_Ty] &)[impl0]': null,
    'FB$std::addressof@[_Ty] const *([_Ty] const &&)[decl0]': null,
    'NF[0]$std': { 'htmlFileName': 'vcruntime_new.h', 'displayName': 'vcruntime_new.h' },
    'NF[10]$std': { 'htmlFileName': 'vcruntime_exception.h', 'displayName': 'vcruntime_exception.h' },
    'NF[11]$std': { 'htmlFileName': 'exception', 'displayName': 'exception' },
    'NF[12]$std': { 'htmlFileName': 'exception', 'displayName': 'exception' },
    'NF[13]$std': { 'htmlFileName': 'new', 'displayName': 'new' },
    'NF[14]$std': { 'htmlFileName': 'cstdint', 'displayName': 'cstdint' },
    'NF[15]$std': { 'htmlFileName': 'xtgmath.h', 'displayName': 'xtgmath.h' },
    'NF[16]$std': { 'htmlFileName': 'cmath', 'displayName': 'cmath' },
    'NF[17]$std': { 'htmlFileName': 'cwchar', 'displayName': 'cwchar' },
    'NF[18]$std': { 'htmlFileName': 'limits', 'displayName': 'limits' },
    'NF[19]$std': { 'htmlFileName': 'cstdio', 'displayName': 'cstdio' },
    'NF[1]$std': { 'htmlFileName': 'yvals.h', 'displayName': 'yvals.h' },
    'NF[20]$std': { 'htmlFileName': 'cstring', 'displayName': 'cstring' },
    'NF[21]$std': { 'htmlFileName': 'iosfwd', 'displayName': 'iosfwd' },
    'NF[22]$std': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'NF[23]$std': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'NF[24]$std': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'NF[25]$std': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'NF[26]$std': { 'htmlFileName': 'xatomic0.h', 'displayName': 'xatomic0.h' },
    'NF[27]$std': { 'htmlFileName': 'xmemory', 'displayName': 'xmemory' },
    'NF[28]$std': { 'htmlFileName': 'xstring', 'displayName': 'xstring' },
    'NF[29]$std': { 'htmlFileName': 'stdexcept', 'displayName': 'stdexcept' },
    'NF[2]$std': { 'htmlFileName': 'stddef.h', 'displayName': 'stddef.h' },
    'NF[30]$std': { 'htmlFileName': 'vector', 'displayName': 'vector' },
    'NF[31]$std': { 'htmlFileName': 'xtree', 'displayName': 'xtree' },
    'NF[32]$std': { 'htmlFileName': 'set', 'displayName': 'set' },
    'NF[33]$std': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'NF[34]$std': { 'htmlFileName': 'map', 'displayName': 'map' },
    'NF[35]$std': { 'htmlFileName': 'vcruntime_typeinfo.h', 'displayName': 'vcruntime_typeinfo.h' },
    'NF[36]$std': { 'htmlFileName': 'vcruntime_typeinfo.h', 'displayName': 'vcruntime_typeinfo.h' },
    'NF[37]$std': { 'htmlFileName': 'typeinfo', 'displayName': 'typeinfo' },
    'NF[38]$std': { 'htmlFileName': 'xlocinfo', 'displayName': 'xlocinfo' },
    'NF[39]$std': { 'htmlFileName': 'memory', 'displayName': 'memory' },
    'NF[3]$std': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NF[40]$std': { 'htmlFileName': 'xfacet', 'displayName': 'xfacet' },
    'NF[41]$std': { 'htmlFileName': 'xlocale', 'displayName': 'xlocale' },
    'NF[42]$std': { 'htmlFileName': 'xcall_once.h', 'displayName': 'xcall_once.h' },
    'NF[43]$std': { 'htmlFileName': 'xerrc.h', 'displayName': 'xerrc.h' },
    'NF[44]$std': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'NF[45]$std': { 'htmlFileName': 'xiosbase', 'displayName': 'xiosbase' },
    'NF[46]$std': { 'htmlFileName': 'streambuf', 'displayName': 'streambuf' },
    'NF[47]$std': { 'htmlFileName': 'xlocnum', 'displayName': 'xlocnum' },
    'NF[48]$std': { 'htmlFileName': 'ios', 'displayName': 'ios' },
    'NF[49]$std': { 'htmlFileName': 'ostream', 'displayName': 'ostream' },
    'NF[4]$std': { 'htmlFileName': 'cstddef', 'displayName': 'cstddef' },
    'NF[50]$std': { 'htmlFileName': 'istream', 'displayName': 'istream' },
    'NF[51]$std': { 'htmlFileName': 'xstring_insert.h', 'displayName': 'xstring_insert.h' },
    'NF[52]$std': { 'htmlFileName': 'string', 'displayName': 'string' },
    'NF[53]$std': { 'htmlFileName': 'xlocbuf', 'displayName': 'xlocbuf' },
    'NF[54]$std': { 'htmlFileName': 'xlocmes', 'displayName': 'xlocmes' },
    'NF[55]$std': { 'htmlFileName': 'xlocmon', 'displayName': 'xlocmon' },
    'NF[56]$std': { 'htmlFileName': 'ctime', 'displayName': 'ctime' },
    'NF[57]$std': { 'htmlFileName': 'xloctime', 'displayName': 'xloctime' },
    'NF[58]$std': { 'htmlFileName': 'locale', 'displayName': 'locale' },
    'NF[59]$std': { 'htmlFileName': 'codecvt', 'displayName': 'codecvt' },
    'NF[5]$std': { 'htmlFileName': 'cstdlib', 'displayName': 'cstdlib' },
    'NF[60]$std': { 'htmlFileName': 'functional', 'displayName': 'functional' },
    'NF[61]$std': { 'htmlFileName': 'iostream', 'displayName': 'iostream' },
    'NF[6]$std': { 'htmlFileName': 'initializer_list', 'displayName': 'initializer_list' },
    'NF[7]$std': null,
    'NF[8]$std': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NF[9]$std': { 'htmlFileName': 'exception', 'displayName': 'exception' },
    'NI$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ptr': null,
    'NI$std::_Unfancy@auto([_Ptrty])[impl0]::_Ptr': null,
    'NI$std::addressof@[_Ty] *([_Ty] &)[impl0]::_Val': null,
    'NI$std::equal_to': null,
    'NI$std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::equal_to@<void>': null,
    'NI$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::greater': null,
    'NI$std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::greater::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::greater@<void>': null,
    'NI$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::greater_equal': null,
    'NI$std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::greater_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::greater_equal@<void>': null,
    'NI$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::less': null,
    'NI$std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::less::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::less@<void>': null,
    'NI$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::less_equal': null,
    'NI$std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::less_equal::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::less_equal@<void>': null,
    'NI$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::minus': null,
    'NI$std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::minus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::minus@<void>': null,
    'NI$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::multiplies': null,
    'NI$std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::multiplies::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::multiplies@<void>': null,
    'NI$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::not_equal_to': null,
    'NI$std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::not_equal_to::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::not_equal_to@<void>': null,
    'NI$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::plus': null,
    'NI$std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::plus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::plus@<void>': null,
    'NI$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'TA$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]::_Ty': null,
    'TA$std::_Unfancy@auto([_Ptrty])[impl0]::_Ptrty': null,
    'TA$std::addressof@[_Ty] *([_Ty] &)[impl0]::_Ty': null,
    'TA$std::addressof@[_Ty] const *([_Ty] const &&)[decl0]::_Ty': null,
    'TA$std::binary_function::_Arg1': null,
    'TA$std::binary_function::_Arg2': null,
    'TA$std::binary_function::_Result': null,
    'TA$std::equal_to::_Ty': null,
    'TA$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::greater::_Ty': null,
    'TA$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::greater@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::greater_equal::_Ty': null,
    'TA$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::greater_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::less::_Ty': null,
    'TA$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::less@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::less_equal::_Ty': null,
    'TA$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::less_equal@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::minus::_Ty': null,
    'TA$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::minus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::multiplies::_Ty': null,
    'TA$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::multiplies@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::not_equal_to::_Ty': null,
    'TA$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::not_equal_to@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::plus::_Ty': null,
    'TA$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::plus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::unary_function::_Arg': null,
    'TA$std::unary_function::_Result': null
};
turnOnSymbol();
</script>
</body>
</html>
