<!DOCTYPE html>
<html>
<head>
    <title>functional</title>
    <link rel="stylesheet" href="../../Cpp.css" />
    <link rel="shortcut icon" href="../../favicon.ico" />
    <script type="text/javascript" src="../../Cpp.js" ></script>
</head>
<body>
<a class="button" href="../FileIndex.html">File Index</a>
<a class="button" href="../SymbolIndex.html">Symbol Index</a>
<br>
<br>
<div class="codebox"><div class="cpp_default"><div class="token cpp_comment ">// functional standard header</div>
#pragma once
<div class="disabled">#ifndef _FUNCTIONAL_</div>
<div class="disabled">#define _FUNCTIONAL_</div>
<div class="disabled">#ifndef RC_INVOKED</div>
<div class="disabled">#include &lt;exception&gt;</div>
<div class="disabled">#include &lt;tuple&gt;</div>
<div class="disabled">#include &lt;typeinfo&gt;</div>
<div class="disabled">#include &lt;xstddef&gt;</div>
<div class="disabled">#include &lt;xstring&gt;</div>
<div class="disabled">#if _HAS_CXX17</div>
<div class="disabled"> #include &lt;memory&gt;</div>
<div class="disabled"> #include &lt;unordered_map&gt;
#endif /* _HAS_CXX17 */</div>

<div class="expandable"><div class="disabled"> #pragma pack(push,_CRT_PACKING)</div>
<div class="expanded">#pragma pack(push,<div class="token cpp_number ">8</div>)</div></div>
<div class="expandable"><div class="disabled"> #pragma warning(push,_STL_WARNING_LEVEL)</div>
<div class="expanded">#pragma warning(push,<div class="token cpp_number ">3</div>)</div></div>
<div class="expandable"><div class="disabled"> #pragma warning(disable: _STL_DISABLED_WARNINGS)</div>
<div class="expanded">#pragma warning(disable: <div class="token cpp_number ">4455</div> <div class="token cpp_number ">4494</div>  <div class="token cpp_number ">4619</div> <div class="token cpp_number ">4643</div> <div class="token cpp_number ">4702</div> <div class="token cpp_number ">4984</div> <div class="token cpp_number ">4988</div> )</div></div>
<div class="disabled"> _STL_DISABLE_CLANG_WARNINGS</div>
<div class="disabled"> #pragma push_macro(&quot;new&quot;)</div>
<div class="disabled"> #undef new</div>

<div class="expandable"><div class="disabled">_STD_BEGIN</div>
<div class="expanded"><div class="token cpp_keyword ">namespace</div> <div class="def" id="NF[60]$std"><div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div></div> {</div></div>
		<div class="token cpp_comment ">// STRUCT TEMPLATE plus</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE minus</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE multiplies</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE divides</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::divides::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::divides"><div class="ref" onclick="jumpToSymbol([], [], ['std::divides@<void>'], [])"><div class="token cpp_type">divides</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator/</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::divides::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::divides::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::divides::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::divides::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::divides::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::divides::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::divides::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::divides::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::divides::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator/ to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> / <div class="ref" onclick="jumpToSymbol([], ['std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE modulus</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::modulus::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::modulus"><div class="ref" onclick="jumpToSymbol([], [], ['std::modulus@<void>'], [])"><div class="token cpp_type">modulus</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator%</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::modulus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::modulus::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::modulus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::modulus::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::modulus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::modulus::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::modulus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::modulus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::modulus::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator% to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> % <div class="ref" onclick="jumpToSymbol([], ['std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE negate</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::negate::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::negate"><div class="ref" onclick="jumpToSymbol([], [], ['std::negate@<void>'], [])"><div class="token cpp_type">negate</div></div></div>
	{	<div class="token cpp_comment ">// functor for unary operator-</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::negate::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::negate::argument_type"><div><div class="token cpp_type">argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::negate::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::negate::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::negate::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::negate::operator ()@[_Ty]([_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::negate::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::negate::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator- to operand</div>
		<div class="token cpp_keyword ">return</div> (-<div class="ref" onclick="jumpToSymbol([], ['std::negate::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE equal_to</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE not_equal_to</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE greater</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE less</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE greater_equal</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE less_equal</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE logical_and</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::logical_and::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::logical_and"><div class="ref" onclick="jumpToSymbol([], [], ['std::logical_and@<void>'], [])"><div class="token cpp_type">logical_and</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator&amp;&amp;</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::logical_and::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::logical_and::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::logical_and::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator&amp;&amp; to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> &amp;&amp; <div class="ref" onclick="jumpToSymbol([], ['std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE logical_or</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::logical_or::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::logical_or"><div class="ref" onclick="jumpToSymbol([], [], ['std::logical_or@<void>'], [])"><div class="token cpp_type">logical_or</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator||</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::logical_or::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::logical_or::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::logical_or::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator|| to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> || <div class="ref" onclick="jumpToSymbol([], ['std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE logical_not</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::logical_not::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::logical_not"><div class="ref" onclick="jumpToSymbol([], [], ['std::logical_not@<void>'], [])"><div class="token cpp_type">logical_not</div></div></div>
	{	<div class="token cpp_comment ">// functor for unary operator!</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_not::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::logical_not::argument_type"><div><div class="token cpp_type">argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::logical_not::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::logical_not::operator ()@bool([_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::logical_not::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::logical_not::operator ()@bool([_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator! to operand</div>
		<div class="token cpp_keyword ">return</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::logical_not::operator ()@bool([_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE bit_and</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_and::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::bit_and"><div class="ref" onclick="jumpToSymbol([], [], ['std::bit_and@<void>'], [])"><div class="token cpp_type">bit_and</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator&amp;</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_and::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_and::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_and::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_and::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator&amp; to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> &amp; <div class="ref" onclick="jumpToSymbol([], ['std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE bit_or</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_or::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::bit_or"><div class="ref" onclick="jumpToSymbol([], [], ['std::bit_or@<void>'], [])"><div class="token cpp_type">bit_or</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator|</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_or::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_or::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_or::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_or::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator| to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> | <div class="ref" onclick="jumpToSymbol([], ['std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE bit_xor</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_xor::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::bit_xor"><div class="ref" onclick="jumpToSymbol([], [], ['std::bit_xor@<void>'], [])"><div class="token cpp_type">bit_xor</div></div></div>
	{	<div class="token cpp_comment ">// functor for operator^</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_xor::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_xor::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_xor::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_xor::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_xor::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_xor::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_xor::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_xor::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_xor::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator^ to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div> ^ <div class="ref" onclick="jumpToSymbol([], ['std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE bit_not</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_not::_Ty"><div><div class="token cpp_type">_Ty</div></div></div> = <div class="token cpp_keyword ">void</div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::bit_not"><div class="ref" onclick="jumpToSymbol([], [], ['std::bit_not@<void>'], [])"><div class="token cpp_type">bit_not</div></div></div>
	{	<div class="token cpp_comment ">// functor for unary operator~</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty argument_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_not::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_not::argument_type"><div><div class="token cpp_type">argument_type</div></div></div>;</div></div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_not::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="NI$std::bit_not::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>

	<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_not::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> <div class="def" id="FB$std::bit_not::operator ()@[_Ty]([_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bit_not::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bit_not::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply operator~ to operand</div>
		<div class="token cpp_keyword ">return</div> (~<div class="ref" onclick="jumpToSymbol([], ['std::bit_not::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>);
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION plus</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION minus</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION multiplies</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION divides</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::divides@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::divides'])"><div class="token cpp_type">divides</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator/</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::divides@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD forward&lt;_Ty1&gt;(_Left) / _STD forward&lt;_Ty2&gt;(_Right))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) / ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator/ to operands</div>
<div class="expandable"><div class="disabled">		return (_STD forward&lt;_Ty1&gt;(_Left) / _STD forward&lt;_Ty2&gt;(_Right));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) / ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION modulus</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::modulus@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::modulus'])"><div class="token cpp_type">modulus</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator%</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::modulus@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD forward&lt;_Ty1&gt;(_Left) % _STD forward&lt;_Ty2&gt;(_Right))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) % ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator% to operands</div>
<div class="expandable"><div class="disabled">		return (_STD forward&lt;_Ty1&gt;(_Left) % _STD forward&lt;_Ty2&gt;(_Right));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) % ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION negate</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::negate@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::negate'])"><div class="token cpp_type">negate</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for unary operator-</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::negate@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp;&amp; <div class="def" id="NI$std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(-_STD forward&lt;_Ty&gt;(_Left))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(-::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator- to operand</div>
<div class="expandable"><div class="disabled">		return (-_STD forward&lt;_Ty&gt;(_Left));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (-::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION equal_to</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION not_equal_to</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION greater</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION less</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION greater_equal</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION less_equal</div>
<div class="token cpp_comment ">// defined in &lt;xstddef&gt;</div>

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION logical_and</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::logical_and@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::logical_and'])"><div class="token cpp_type">logical_and</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator&amp;&amp;</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::logical_and@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD forward&lt;_Ty1&gt;(_Left) &amp;&amp; _STD forward&lt;_Ty2&gt;(_Right))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) &amp;&amp; ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator&amp;&amp; to operands</div>
<div class="expandable"><div class="disabled">		return (_STD forward&lt;_Ty1&gt;(_Left) &amp;&amp; _STD forward&lt;_Ty2&gt;(_Right));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) &amp;&amp; ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION logical_or</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::logical_or@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::logical_or'])"><div class="token cpp_type">logical_or</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator||</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::logical_or@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD forward&lt;_Ty1&gt;(_Left) || _STD forward&lt;_Ty2&gt;(_Right))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) || ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator|| to operands</div>
<div class="expandable"><div class="disabled">		return (_STD forward&lt;_Ty1&gt;(_Left) || _STD forward&lt;_Ty2&gt;(_Right));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) || ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION logical_not</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::logical_not@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::logical_not'])"><div class="token cpp_type">logical_not</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for unary operator!</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::logical_not@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp;&amp; <div class="def" id="NI$std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(!_STD forward&lt;_Ty&gt;(_Left))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(!::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator! to operand</div>
<div class="expandable"><div class="disabled">		return (!_STD forward&lt;_Ty&gt;(_Left));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (!::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION bit_and</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::bit_and@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::bit_and'])"><div class="token cpp_type">bit_and</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator&amp;</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::bit_and@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD forward&lt;_Ty1&gt;(_Left) &amp; _STD forward&lt;_Ty2&gt;(_Right))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) &amp; ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator&amp; to operands</div>
<div class="expandable"><div class="disabled">		return (_STD forward&lt;_Ty1&gt;(_Left) &amp; _STD forward&lt;_Ty2&gt;(_Right));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) &amp; ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION bit_or</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::bit_or@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::bit_or'])"><div class="token cpp_type">bit_or</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator|</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::bit_or@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD forward&lt;_Ty1&gt;(_Left) | _STD forward&lt;_Ty2&gt;(_Right))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) | ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator| to operands</div>
<div class="expandable"><div class="disabled">		return (_STD forward&lt;_Ty1&gt;(_Left) | _STD forward&lt;_Ty2&gt;(_Right));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) | ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION bit_xor</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::bit_xor@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::bit_xor'])"><div class="token cpp_type">bit_xor</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for operator^</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::bit_xor@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1"><div><div class="token cpp_type">_Ty1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2"><div><div class="token cpp_type">_Ty2</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&amp;&amp; <div class="def" id="NI$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&amp;&amp; <div class="def" id="NI$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD forward&lt;_Ty1&gt;(_Left) ^ _STD forward&lt;_Ty2&gt;(_Right))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) ^ ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator^ to operands</div>
<div class="expandable"><div class="disabled">		return (_STD forward&lt;_Ty1&gt;(_Left) ^ _STD forward&lt;_Ty2&gt;(_Right));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'], [], [])"><div class="token cpp_type">_Ty1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>) ^ ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'], [], [])"><div class="token cpp_type">_Ty2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
		}
	};

		<div class="token cpp_comment ">// STRUCT TEMPLATE SPECIALIZATION bit_not</div>
<div class="token cpp_keyword ">template</div>&lt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::bit_not@<void>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::bit_not'])"><div class="token cpp_type">bit_not</div></div></div>&lt;<div class="token cpp_keyword ">void</div>&gt;
	{	<div class="token cpp_comment ">// transparent functor for unary operator~</div>
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::bit_not@<void>::is_transparent"><div><div class="token cpp_type">is_transparent</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
		<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp;&amp; <div class="def" id="NI$std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		-&gt; decltype(~_STD forward&lt;_Ty&gt;(_Left))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(~::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>))</div></div>
		{	<div class="token cpp_comment ">// transparently apply operator~ to operand</div>
<div class="expandable"><div class="disabled">		return (~_STD forward&lt;_Ty&gt;(_Left));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (~::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>));</div></div>
		}
	};

#pragma warning(push)
<div class="expandable"><div class="disabled">#pragma warning(disable: 4996)	// was declared deprecated</div>
<div class="expanded">#pragma warning(disable: <div class="token cpp_number ">4996</div>)	</div></div>
		<div class="token cpp_comment ">// CLASS TEMPLATE unary_negate</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::unary_negate::_Fn"><div><div class="token cpp_type">_Fn</div></div></div>&gt;
<div class="expandable"><div class="disabled">	class _CXX17_DEPRECATE_NEGATORS unary_negate</div>
<div class="expanded">	<div class="token cpp_keyword ">class</div>  <div class="def" id="NI$std::unary_negate"><div><div class="token cpp_type">unary_negate</div></div></div></div></div>
	{	<div class="token cpp_comment ">// functor adapter !_Func(left)</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_negate::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::argument_type <div class="def" id="NI$std::unary_negate::argument_type"><div><div class="token cpp_type">argument_type</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::unary_negate::result_type"><div><div class="token cpp_type">result_type</div></div></div>;

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::unary_negate::$__ctor@([_Fn] const &)[impl0]"><div><div class="token cpp_function">unary_negate</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_negate::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&amp; <div class="def" id="NI$std::unary_negate::$__ctor@([_Fn] const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>)
		: _Functor(<div class="ref" onclick="jumpToSymbol([], ['std::unary_negate::$__ctor@([_Fn] const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>)
		{	<div class="token cpp_comment ">// construct from functor</div>
		}

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::unary_negate::operator ()@bool(::std::unary_negate::argument_type const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_negate::argument_type'], [], [])"><div class="token cpp_type">argument_type</div></div>&amp; <div class="def" id="NI$std::unary_negate::operator ()@bool(::std::unary_negate::argument_type const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply functor to operand</div>
		<div class="token cpp_keyword ">return</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::unary_negate::_Functor'], [], [])"><div class="token cpp_field">_Functor</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::unary_negate::operator ()@bool(::std::unary_negate::argument_type const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>));
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::unary_negate::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div> <div class="def" id="NI$std::unary_negate::_Functor"><div><div class="token cpp_field">_Functor</div></div></div>;	<div class="token cpp_comment ">// the functor to apply</div>
	};

		<div class="token cpp_comment ">// FUNCTION TEMPLATE not1</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn"><div><div class="token cpp_type">_Fn</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD _CXX17_DEPRECATE_NEGATORS constexpr unary_negate&lt;_Fn&gt; not1(const _Fn&amp; _Func)</div>
<div class="expanded">	  <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_negate'], [], [])"><div class="token cpp_type">unary_negate</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&gt; <div class="def" id="FB$std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]"><div><div class="token cpp_function">not1</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&amp; <div class="def" id="NI$std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>)</div></div>
	{	<div class="token cpp_comment ">// return a unary_negate functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::unary_negate'], [], [])"><div class="token cpp_type">unary_negate</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>));
	}

		<div class="token cpp_comment ">// CLASS TEMPLATE binary_negate</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::binary_negate::_Fn"><div><div class="token cpp_type">_Fn</div></div></div>&gt;
<div class="expandable"><div class="disabled">	class _CXX17_DEPRECATE_NEGATORS binary_negate</div>
<div class="expanded">	<div class="token cpp_keyword ">class</div>  <div class="def" id="NI$std::binary_negate"><div><div class="token cpp_type">binary_negate</div></div></div></div></div>
	{	<div class="token cpp_comment ">// functor adapter !_Func(left, right)</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::first_argument_type <div class="def" id="NI$std::binary_negate::first_argument_type"><div><div class="token cpp_type">first_argument_type</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::second_argument_type <div class="def" id="NI$std::binary_negate::second_argument_type"><div><div class="token cpp_type">second_argument_type</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::binary_negate::result_type"><div><div class="token cpp_type">result_type</div></div></div>;

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::binary_negate::$__ctor@([_Fn] const &)[impl0]"><div><div class="token cpp_function">binary_negate</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&amp; <div class="def" id="NI$std::binary_negate::$__ctor@([_Fn] const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>)
		: _Functor(<div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::$__ctor@([_Fn] const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>)
		{	<div class="token cpp_comment ">// construct from functor</div>
		}

	<div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::first_argument_type'], [], [])"><div class="token cpp_type">first_argument_type</div></div>&amp; <div class="def" id="NI$std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>,
		<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::second_argument_type'], [], [])"><div class="token cpp_type">second_argument_type</div></div>&amp; <div class="def" id="NI$std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply functor to operands</div>
		<div class="token cpp_keyword ">return</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::_Functor'], [], [])"><div class="token cpp_field">_Functor</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::binary_negate::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div> <div class="def" id="NI$std::binary_negate::_Functor"><div><div class="token cpp_field">_Functor</div></div></div>;	<div class="token cpp_comment ">// the functor to apply</div>
	};

		<div class="token cpp_comment ">// FUNCTION TEMPLATE not2</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn"><div><div class="token cpp_type">_Fn</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD _CXX17_DEPRECATE_NEGATORS constexpr binary_negate&lt;_Fn&gt; not2(const _Fn&amp; _Func)</div>
<div class="expanded">	  <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_negate'], [], [])"><div class="token cpp_type">binary_negate</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&gt; <div class="def" id="FB$std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]"><div><div class="token cpp_function">not2</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&amp; <div class="def" id="NI$std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>)</div></div>
	{	<div class="token cpp_comment ">// return a binary_negate functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::binary_negate'], [], [])"><div class="token cpp_type">binary_negate</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>));
	}
#pragma warning(pop)

<div class="disabled"> #if _HAS_AUTO_PTR_ETC</div>
#pragma warning(push)
<div class="expandable"><div class="disabled">#pragma warning(disable: 4996)	// was declared deprecated</div>
<div class="expanded">#pragma warning(disable: <div class="token cpp_number ">4996</div>)	</div></div>
		<div class="token cpp_comment ">// CLASS TEMPLATE binder1st</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::binder1st::_Fn"><div><div class="token cpp_type">_Fn</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::binder1st"><div><div class="token cpp_type">binder1st</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::second_argument_type,
			<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::result_type&gt;
	{	<div class="token cpp_comment ">// functor adapter _Func(stored, right)</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::second_argument_type,
		<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::result_type&gt; <div class="def" id="NI$std::binder1st::_Base"><div><div class="token cpp_type">_Base</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Base'], [], [])"><div class="token cpp_type">_Base</div></div>::<div class="ref" onclick="jumpToSymbol([], ['std::unary_function::argument_type'], [], [])"><div class="token cpp_type">argument_type</div></div> <div class="def" id="NI$std::binder1st::argument_type"><div><div class="token cpp_type">argument_type</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Base'], [], [])"><div class="token cpp_type">_Base</div></div>::<div class="ref" onclick="jumpToSymbol([], ['std::unary_function::result_type'], [], [])"><div class="token cpp_type">result_type</div></div> <div class="def" id="NI$std::binder1st::result_type"><div><div class="token cpp_type">result_type</div></div></div>;

	<div class="def" id="FB$std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]"><div><div class="token cpp_function">binder1st</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&amp; <div class="def" id="NI$std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>,
		<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::first_argument_type&amp; <div class="def" id="NI$std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)
		: op(<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>), value(<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
		{	<div class="token cpp_comment ">// construct from functor and left operand</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::result_type'], [], [])"><div class="token cpp_type">result_type</div></div> <div class="def" id="FB$std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::argument_type'], [], [])"><div class="token cpp_type">argument_type</div></div>&amp; <div class="def" id="NI$std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply functor to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::op'], [], [])"><div class="token cpp_field">op</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::value'], [], [])"><div class="token cpp_field">value</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::result_type'], [], [])"><div class="token cpp_type">result_type</div></div> <div class="def" id="FB$std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::argument_type'], [], [])"><div class="token cpp_type">argument_type</div></div>&amp; <div class="def" id="NI$std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply functor to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::op'], [], [])"><div class="token cpp_field">op</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::value'], [], [])"><div class="token cpp_field">value</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}

<div class="token cpp_keyword ">protected</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div> <div class="def" id="NI$std::binder1st::op"><div><div class="token cpp_field">op</div></div></div>;	<div class="token cpp_comment ">// the functor to apply</div>
	<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::first_argument_type <div class="def" id="NI$std::binder1st::value"><div><div class="token cpp_field">value</div></div></div>;	<div class="token cpp_comment ">// the left operand</div>
	};

		<div class="token cpp_comment ">// FUNCTION TEMPLATE bind1st</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn"><div><div class="token cpp_type">_Fn</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline binder1st&lt;_Fn&gt; bind1st(const _Fn&amp; _Func, const _Ty&amp; _Left)</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder1st'], [], [])"><div class="token cpp_type">binder1st</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&gt; <div class="def" id="FB$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_function">bind1st</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&amp; <div class="def" id="NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)</div></div>
	{	<div class="token cpp_comment ">// return a binder1st functor adapter</div>
	<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::first_argument_type <div class="def" id="NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val"><div>_Val</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>);
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::binder1st'], [], [])"><div class="token cpp_type">binder1st</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val'], [], [])">_Val</div>));
	}

		<div class="token cpp_comment ">// CLASS TEMPLATE binder2nd</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::binder2nd::_Fn"><div><div class="token cpp_type">_Fn</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::binder2nd"><div><div class="token cpp_type">binder2nd</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::first_argument_type,
			<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::result_type&gt;
	{	<div class="token cpp_comment ">// functor adapter _Func(left, stored)</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::first_argument_type,
		<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::result_type&gt; <div class="def" id="NI$std::binder2nd::_Base"><div><div class="token cpp_type">_Base</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Base'], [], [])"><div class="token cpp_type">_Base</div></div>::<div class="ref" onclick="jumpToSymbol([], ['std::unary_function::argument_type'], [], [])"><div class="token cpp_type">argument_type</div></div> <div class="def" id="NI$std::binder2nd::argument_type"><div><div class="token cpp_type">argument_type</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Base'], [], [])"><div class="token cpp_type">_Base</div></div>::<div class="ref" onclick="jumpToSymbol([], ['std::unary_function::result_type'], [], [])"><div class="token cpp_type">result_type</div></div> <div class="def" id="NI$std::binder2nd::result_type"><div><div class="token cpp_type">result_type</div></div></div>;

	<div class="def" id="FB$std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]"><div><div class="token cpp_function">binder2nd</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&amp; <div class="def" id="NI$std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>,
		<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::second_argument_type&amp; <div class="def" id="NI$std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		: op(<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>), value(<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>)
		{	<div class="token cpp_comment ">// construct from functor and right operand</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::result_type'], [], [])"><div class="token cpp_type">result_type</div></div> <div class="def" id="FB$std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::argument_type'], [], [])"><div class="token cpp_type">argument_type</div></div>&amp; <div class="def" id="NI$std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply functor to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::op'], [], [])"><div class="token cpp_field">op</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::value'], [], [])"><div class="token cpp_field">value</div></div>));
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::result_type'], [], [])"><div class="token cpp_type">result_type</div></div> <div class="def" id="FB$std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::argument_type'], [], [])"><div class="token cpp_type">argument_type</div></div>&amp; <div class="def" id="NI$std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// apply functor to operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::op'], [], [])"><div class="token cpp_field">op</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::value'], [], [])"><div class="token cpp_field">value</div></div>));
		}

<div class="token cpp_keyword ">protected</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div> <div class="def" id="NI$std::binder2nd::op"><div><div class="token cpp_field">op</div></div></div>;	<div class="token cpp_comment ">// the functor to apply</div>
	<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::second_argument_type <div class="def" id="NI$std::binder2nd::value"><div><div class="token cpp_field">value</div></div></div>;	<div class="token cpp_comment ">// the right operand</div>
	};

		<div class="token cpp_comment ">// FUNCTION TEMPLATE bind2nd</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn"><div><div class="token cpp_type">_Fn</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline binder2nd&lt;_Fn&gt; bind2nd(const _Fn&amp; _Func, const _Ty&amp; _Right)</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::binder2nd'], [], [])"><div class="token cpp_type">binder2nd</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&gt; <div class="def" id="FB$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]"><div><div class="token cpp_function">bind2nd</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&amp; <div class="def" id="NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)</div></div>
	{	<div class="token cpp_comment ">// return a binder2nd functor adapter</div>
	<div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>::second_argument_type <div class="def" id="NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val"><div>_Val</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::binder2nd'], [], [])"><div class="token cpp_type">binder2nd</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val'], [], [])">_Val</div>));
	}
#pragma warning(pop)

		<div class="token cpp_comment ">// CLASS TEMPLATE pointer_to_unary_function</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::pointer_to_unary_function::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::pointer_to_unary_function::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::pointer_to_unary_function::_Fn"><div><div class="token cpp_type">_Fn</div></div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (*)(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::pointer_to_unary_function"><div><div class="token cpp_type">pointer_to_unary_function</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*pfunc)(left)</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::pointer_to_unary_function::$__ctor@([_Fn])[impl0]"><div><div class="token cpp_function">pointer_to_unary_function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div> <div class="def" id="NI$std::pointer_to_unary_function::$__ctor@([_Fn])[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)
		: _Pfun(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::$__ctor@([_Fn])[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::pointer_to_unary_function::operator ()@[_Result]([_Arg])[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div> <div class="def" id="NI$std::pointer_to_unary_function::operator ()@[_Result]([_Arg])[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function with operand</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Pfun'], [], [])"><div class="token cpp_field">_Pfun</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::operator ()@[_Result]([_Arg])[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>));
		}

<div class="token cpp_keyword ">protected</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div> <div class="def" id="NI$std::pointer_to_unary_function::_Pfun"><div><div class="token cpp_field">_Pfun</div></div></div>;	<div class="token cpp_comment ">// the function pointer</div>
	};

		<div class="token cpp_comment ">// CLASS TEMPLATE pointer_to_binary_function</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::pointer_to_binary_function::_Arg1"><div><div class="token cpp_type">_Arg1</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::pointer_to_binary_function::_Arg2"><div><div class="token cpp_type">_Arg2</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::pointer_to_binary_function::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::pointer_to_binary_function::_Fn"><div><div class="token cpp_type">_Fn</div></div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (*)(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::pointer_to_binary_function"><div><div class="token cpp_type">pointer_to_binary_function</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_function'], [], [])"><div class="token cpp_type">binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*pfunc)(left, right)</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::pointer_to_binary_function::$__ctor@([_Fn])[impl0]"><div><div class="token cpp_function">pointer_to_binary_function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div> <div class="def" id="NI$std::pointer_to_binary_function::$__ctor@([_Fn])[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)
		: _Pfun(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::$__ctor@([_Fn])[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div> <div class="def" id="NI$std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div> <div class="def" id="NI$std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function with operands</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Pfun'], [], [])"><div class="token cpp_field">_Pfun</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}

<div class="token cpp_keyword ">protected</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function::_Fn'], [], [])"><div class="token cpp_type">_Fn</div></div> <div class="def" id="NI$std::pointer_to_binary_function::_Pfun"><div><div class="token cpp_field">_Pfun</div></div></div>;	<div class="token cpp_comment ">// the function pointer</div>
	};

		<div class="token cpp_comment ">// FUNCTION TEMPLATE ptr_fun</div>
<div class="disabled">#define _PTR_FUN(CALL_OPT, X1, X2, X3) \</div>
<div class="disabled">template&lt;class _Arg, \</div>
<div class="disabled">	class _Result&gt; \</div>
<div class="disabled">	_NODISCARD inline pointer_to_unary_function&lt;_Arg, _Result, _Result (CALL_OPT *)(_Arg)&gt; \</div>
<div class="disabled">		ptr_fun(_Result (CALL_OPT *_Left)(_Arg)) \</div>
<div class="disabled">	{	/* return pointer_to_unary_function functor adapter */ \</div>
<div class="disabled">	return (pointer_to_unary_function&lt;_Arg, _Result, _Result (CALL_OPT *)(_Arg)&gt;(_Left)); \</div>
<div class="disabled">	} \</div>
<div class="disabled">template&lt;class _Arg1, \</div>
<div class="disabled">	class _Arg2, \</div>
<div class="disabled">	class _Result&gt; \</div>
<div class="disabled">	_NODISCARD inline pointer_to_binary_function&lt;_Arg1, _Arg2, _Result, _Result (CALL_OPT *)(_Arg1, _Arg2)&gt; \</div>
<div class="disabled">		ptr_fun(_Result (CALL_OPT *_Left)(_Arg1, _Arg2)) \</div>
<div class="disabled">	{	/* return pointer_to_binary_function functor adapter */ \</div>
<div class="disabled">	return (pointer_to_binary_function&lt;_Arg1, _Arg2, _Result, _Result (CALL_OPT *)(_Arg1, _Arg2)&gt;(_Left)); \</div>
<div class="disabled">	}</div>

<div class="expandable"><div class="disabled">_NON_MEMBER_CALL(_PTR_FUN, X1, X2, X3)</div>
<div class="expanded"><div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;  <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function'], [], [])"><div class="token cpp_type">pointer_to_unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__cdecl</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt; <div class="def" id="FB$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]"><div><div class="token cpp_function">ptr_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__cdecl</div> *<div class="def" id="NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function'], [], [])"><div class="token cpp_type">pointer_to_unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__cdecl</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)); } <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1"><div><div class="token cpp_type">_Arg1</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2"><div><div class="token cpp_type">_Arg2</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;  <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function'], [], [])"><div class="token cpp_type">pointer_to_binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__cdecl</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt; <div class="def" id="FB$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]"><div><div class="token cpp_function">ptr_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__cdecl</div> *<div class="def" id="NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function'], [], [])"><div class="token cpp_type">pointer_to_binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__cdecl</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)); }  <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;  <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function'], [], [])"><div class="token cpp_type">pointer_to_unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__fastcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt; <div class="def" id="FB$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]"><div><div class="token cpp_function">ptr_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__fastcall</div> *<div class="def" id="NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function'], [], [])"><div class="token cpp_type">pointer_to_unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__fastcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)); } <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1"><div><div class="token cpp_type">_Arg1</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2"><div><div class="token cpp_type">_Arg2</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;  <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function'], [], [])"><div class="token cpp_type">pointer_to_binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__fastcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt; <div class="def" id="FB$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]"><div><div class="token cpp_function">ptr_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__fastcall</div> *<div class="def" id="NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function'], [], [])"><div class="token cpp_type">pointer_to_binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__fastcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)); } <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;  <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function'], [], [])"><div class="token cpp_type">pointer_to_unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__stdcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt; <div class="def" id="FB$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]"><div><div class="token cpp_function">ptr_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__stdcall</div> *<div class="def" id="NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function'], [], [])"><div class="token cpp_type">pointer_to_unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__stdcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)); } <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1"><div><div class="token cpp_type">_Arg1</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2"><div><div class="token cpp_type">_Arg2</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;  <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function'], [], [])"><div class="token cpp_type">pointer_to_binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__stdcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt; <div class="def" id="FB$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]"><div><div class="token cpp_function">ptr_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__stdcall</div> *<div class="def" id="NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function'], [], [])"><div class="token cpp_type">pointer_to_binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__stdcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)); } <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;  <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function'], [], [])"><div class="token cpp_type">pointer_to_unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__vectorcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt; <div class="def" id="FB$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]"><div><div class="token cpp_function">ptr_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__vectorcall</div> *<div class="def" id="NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_unary_function'], [], [])"><div class="token cpp_type">pointer_to_unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__vectorcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>)&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)); } <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1"><div><div class="token cpp_type">_Arg1</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2"><div><div class="token cpp_type">_Arg2</div></div></div>, <div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>&gt;  <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function'], [], [])"><div class="token cpp_type">pointer_to_binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__vectorcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt; <div class="def" id="FB$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]"><div><div class="token cpp_function">ptr_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__vectorcall</div> *<div class="def" id="NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::pointer_to_binary_function'], [], [])"><div class="token cpp_type">pointer_to_binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="token cpp_keyword ">__vectorcall</div> *)(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1'], [], [])"><div class="token cpp_type">_Arg1</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2'], [], [])"><div class="token cpp_type">_Arg2</div></div>)&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>)); }</div></div>
<div class="disabled">#undef _PTR_FUN</div>

		<div class="token cpp_comment ">// CLASS TEMPLATE mem_fun_t</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_t::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_t::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::mem_fun_t"><div><div class="token cpp_type">mem_fun_t</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> *, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*p-&gt;*pfunc)(), non-const *pfunc</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun_t</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)())
		: _Pmemfun(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::mem_fun_t::operator ()@[_Result]([_Ty] *)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> *<div class="def" id="NI$std::mem_fun_t::operator ()@[_Result]([_Ty] *)[impl0]::_Pleft"><div><div class="token cpp_argument">_Pleft</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function</div>
		<div class="token cpp_keyword ">return</div> ((<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::operator ()@[_Result]([_Ty] *)[impl0]::_Pleft'], [], [])"><div class="token cpp_argument">_Pleft</div></div>-&gt;*<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Pmemfun'], [], [])"><div class="token cpp_field">_Pmemfun</div></div>)());
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun_t::_Pmemfun"><div><div class="token cpp_field">_Pmemfun</div></div></div>)();	<div class="token cpp_comment ">// the member function pointer</div>
	};

		<div class="token cpp_comment ">// CLASS TEMPLATE mem_fun1_t</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun1_t::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun1_t::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun1_t::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::mem_fun1_t"><div><div class="token cpp_type">mem_fun1_t</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_function'], [], [])"><div class="token cpp_type">binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> *, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*p-&gt;*pfunc)(val), non-const *pfunc</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun1_t</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>))
		: _Pmemfun(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> *<div class="def" id="NI$std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Pleft"><div><div class="token cpp_argument">_Pleft</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div> <div class="def" id="NI$std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function with operand</div>
		<div class="token cpp_keyword ">return</div> ((<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Pleft'], [], [])"><div class="token cpp_argument">_Pleft</div></div>-&gt;*<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Pmemfun'], [], [])"><div class="token cpp_field">_Pmemfun</div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun1_t::_Pmemfun"><div><div class="token cpp_field">_Pmemfun</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>);	<div class="token cpp_comment ">// the member function pointer</div>
	};

		<div class="token cpp_comment ">// CLASS TEMPLATE const_mem_fun_t</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun_t::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun_t::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::const_mem_fun_t"><div><div class="token cpp_type">const_mem_fun_t</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> *, <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*p-&gt;*pfunc)(), const *pfunc</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::const_mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">const_mem_fun_t</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::const_mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)() <div class="token cpp_keyword ">const</div>)
		: _Pmemfun(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::const_mem_fun_t::operator ()@[_Result]([_Ty] const *)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> *<div class="def" id="NI$std::const_mem_fun_t::operator ()@[_Result]([_Ty] const *)[impl0]::_Pleft"><div><div class="token cpp_argument">_Pleft</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function</div>
		<div class="token cpp_keyword ">return</div> ((<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::operator ()@[_Result]([_Ty] const *)[impl0]::_Pleft'], [], [])"><div class="token cpp_argument">_Pleft</div></div>-&gt;*<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Pmemfun'], [], [])"><div class="token cpp_field">_Pmemfun</div></div>)());
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::const_mem_fun_t::_Pmemfun"><div><div class="token cpp_field">_Pmemfun</div></div></div>)() <div class="token cpp_keyword ">const</div>;	<div class="token cpp_comment ">// the member function pointer</div>
	};

		<div class="token cpp_comment ">// CLASS TEMPLATE const_mem_fun1_t</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun1_t::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun1_t::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun1_t::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::const_mem_fun1_t"><div><div class="token cpp_type">const_mem_fun1_t</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_function'], [], [])"><div class="token cpp_type">binary_function</div></div>&lt;<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> *, <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*p-&gt;*pfunc)(val), const *pfunc</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::const_mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">const_mem_fun1_t</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::const_mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>) <div class="token cpp_keyword ">const</div>)
		: _Pmemfun(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div> *<div class="def" id="NI$std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Pleft"><div><div class="token cpp_argument">_Pleft</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div> <div class="def" id="NI$std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function with operand</div>
		<div class="token cpp_keyword ">return</div> ((<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Pleft'], [], [])"><div class="token cpp_argument">_Pleft</div></div>-&gt;*<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Pmemfun'], [], [])"><div class="token cpp_field">_Pmemfun</div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::const_mem_fun1_t::_Pmemfun"><div><div class="token cpp_field">_Pmemfun</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>) <div class="token cpp_keyword ">const</div>;	<div class="token cpp_comment ">// the member function pointer</div>
	};

		<div class="token cpp_comment ">// FUNCTION TEMPLATE mem_fun</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline mem_fun_t&lt;_Result, _Ty&gt; mem_fun(_Result (_Ty::*_Pm)())</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t'], [], [])"><div class="token cpp_type">mem_fun_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt; <div class="def" id="FB$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)())</div></div>
	{	<div class="token cpp_comment ">// return a mem_fun_t functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_t'], [], [])"><div class="token cpp_type">mem_fun_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline mem_fun1_t&lt;_Result, _Ty, _Arg&gt; mem_fun(_Result (_Ty::*_Pm)(_Arg))</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t'], [], [])"><div class="token cpp_type">mem_fun1_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>&gt; <div class="def" id="FB$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>))</div></div>
	{	<div class="token cpp_comment ">// return a mem_fun1_t functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_t'], [], [])"><div class="token cpp_type">mem_fun1_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline const_mem_fun_t&lt;_Result, _Ty&gt; mem_fun(_Result (_Ty::*_Pm)() const)</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t'], [], [])"><div class="token cpp_type">const_mem_fun_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt; <div class="def" id="FB$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)() <div class="token cpp_keyword ">const</div>)</div></div>
	{	<div class="token cpp_comment ">// return a const_mem_fun_t functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_t'], [], [])"><div class="token cpp_type">const_mem_fun_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline const_mem_fun1_t&lt;_Result, _Ty, _Arg&gt; mem_fun(_Result (_Ty::*_Pm)(_Arg) const)</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t'], [], [])"><div class="token cpp_type">const_mem_fun1_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>&gt; <div class="def" id="FB$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>) <div class="token cpp_keyword ">const</div>)</div></div>
	{	<div class="token cpp_comment ">// return a const_mem_fun1_t functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_t'], [], [])"><div class="token cpp_type">const_mem_fun1_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}

		<div class="token cpp_comment ">// CLASS TEMPLATE mem_fun_ref_t</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref_t::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref_t::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::mem_fun_ref_t"><div><div class="token cpp_type">mem_fun_ref_t</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*left.*pfunc)(), non-const *pfunc</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun_ref_t</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)())
		: _Pmemfun(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::mem_fun_ref_t::operator ()@[_Result]([_Ty] &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::mem_fun_ref_t::operator ()@[_Result]([_Ty] &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function</div>
		<div class="token cpp_keyword ">return</div> ((<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::operator ()@[_Result]([_Ty] &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>.*<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Pmemfun'], [], [])"><div class="token cpp_field">_Pmemfun</div></div>)());
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun_ref_t::_Pmemfun"><div><div class="token cpp_field">_Pmemfun</div></div></div>)();	<div class="token cpp_comment ">// the member function pointer</div>
	};

		<div class="token cpp_comment ">// CLASS TEMPLATE mem_fun1_ref_t</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun1_ref_t::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun1_ref_t::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun1_ref_t::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::mem_fun1_ref_t"><div><div class="token cpp_type">mem_fun1_ref_t</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_function'], [], [])"><div class="token cpp_type">binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*left.*pfunc)(val), non-const *pfunc</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun1_ref_t</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>))
		: _Pmemfun(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div> <div class="def" id="NI$std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function with operand</div>
		<div class="token cpp_keyword ">return</div> ((<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>.*<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Pmemfun'], [], [])"><div class="token cpp_field">_Pmemfun</div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun1_ref_t::_Pmemfun"><div><div class="token cpp_field">_Pmemfun</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>);	<div class="token cpp_comment ">// the member function pointer</div>
	};

		<div class="token cpp_comment ">// CLASS TEMPLATE const_mem_fun_ref_t</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun_ref_t::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun_ref_t::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::const_mem_fun_ref_t"><div><div class="token cpp_type">const_mem_fun_ref_t</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::unary_function'], [], [])"><div class="token cpp_type">unary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*left.*pfunc)(), const *pfunc</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::const_mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">const_mem_fun_ref_t</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::const_mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)() <div class="token cpp_keyword ">const</div>)
		: _Pmemfun(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::const_mem_fun_ref_t::operator ()@[_Result]([_Ty] const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::const_mem_fun_ref_t::operator ()@[_Result]([_Ty] const &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function</div>
		<div class="token cpp_keyword ">return</div> ((<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::operator ()@[_Result]([_Ty] const &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>.*<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Pmemfun'], [], [])"><div class="token cpp_field">_Pmemfun</div></div>)());
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::const_mem_fun_ref_t::_Pmemfun"><div><div class="token cpp_field">_Pmemfun</div></div></div>)() <div class="token cpp_keyword ">const</div>;	<div class="token cpp_comment ">// the member function pointer</div>
	};

		<div class="token cpp_comment ">// CLASS TEMPLATE const_mem_fun1_ref_t</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun1_ref_t::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun1_ref_t::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::const_mem_fun1_ref_t::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::const_mem_fun1_ref_t"><div><div class="token cpp_type">const_mem_fun1_ref_t</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::binary_function'], [], [])"><div class="token cpp_type">binary_function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>&gt;
	{	<div class="token cpp_comment ">// functor adapter (*left.*pfunc)(val), const *pfunc</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::const_mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">const_mem_fun1_ref_t</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::const_mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>) <div class="token cpp_keyword ">const</div>)
		: _Pmemfun(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>)
		{	<div class="token cpp_comment ">// construct from pointer</div>
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> <div class="def" id="FB$std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div> <div class="def" id="NI$std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// call function with operand</div>
		<div class="token cpp_keyword ">return</div> ((<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>.*<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Pmemfun'], [], [])"><div class="token cpp_field">_Pmemfun</div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));
		}

<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::const_mem_fun1_ref_t::_Pmemfun"><div><div class="token cpp_field">_Pmemfun</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>) <div class="token cpp_keyword ">const</div>;	<div class="token cpp_comment ">// the member function pointer</div>
	};

		<div class="token cpp_comment ">// FUNCTION TEMPLATE mem_fun_ref</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline mem_fun_ref_t&lt;_Result, _Ty&gt; mem_fun_ref(_Result (_Ty::*_Pm)())</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t'], [], [])"><div class="token cpp_type">mem_fun_ref_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt; <div class="def" id="FB$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun_ref</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)())</div></div>
	{	<div class="token cpp_comment ">// return a mem_fun_ref_t functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref_t'], [], [])"><div class="token cpp_type">mem_fun_ref_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline mem_fun1_ref_t&lt;_Result, _Ty, _Arg&gt; mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t'], [], [])"><div class="token cpp_type">mem_fun1_ref_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>&gt; <div class="def" id="FB$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun_ref</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>))</div></div>
	{	<div class="token cpp_comment ">// return a mem_fun1_ref_t functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun1_ref_t'], [], [])"><div class="token cpp_type">mem_fun1_ref_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline const_mem_fun_ref_t&lt;_Result, _Ty&gt; mem_fun_ref(_Result (_Ty::*_Pm)() const)</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t'], [], [])"><div class="token cpp_type">const_mem_fun_ref_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt; <div class="def" id="FB$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun_ref</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)() <div class="token cpp_keyword ">const</div>)</div></div>
	{	<div class="token cpp_comment ">// return a const_mem_fun_ref_t functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun_ref_t'], [], [])"><div class="token cpp_type">const_mem_fun_ref_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result"><div><div class="token cpp_type">_Result</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg"><div><div class="token cpp_type">_Arg</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline const_mem_fun1_ref_t&lt;_Result, _Ty, _Arg&gt; mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const)</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t'], [], [])"><div class="token cpp_type">const_mem_fun1_ref_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>&gt; <div class="def" id="FB$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fun_ref</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div> (<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*<div class="def" id="NI$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>) <div class="token cpp_keyword ">const</div>)</div></div>
	{	<div class="token cpp_comment ">// return a const_mem_fun1_ref_t functor adapter</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::const_mem_fun1_ref_t'], [], [])"><div class="token cpp_type">const_mem_fun1_ref_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'], [], [])"><div class="token cpp_type">_Result</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'], [], [])"><div class="token cpp_type">_Arg</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}
<div class="disabled"> #endif /* _HAS_AUTO_PTR_ETC */</div>

	<div class="token cpp_comment ">// FUNCTION TEMPLATE mem_fn</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Mem_fn::_Memptr"><div><div class="token cpp_type">_Memptr</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::_Mem_fn"><div><div class="token cpp_type">_Mem_fn</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Weak_types'], [], [])"><div class="token cpp_type">_Weak_types</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::_Memptr'], [], [])"><div class="token cpp_type">_Memptr</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::_Weak_types::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// wrap a pointer to member function/data</div>
<div class="token cpp_keyword ">private</div>:
	<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::_Memptr'], [], [])"><div class="token cpp_type">_Memptr</div></div> <div class="def" id="NI$std::_Mem_fn::_Pm"><div><div class="token cpp_field">_Pm</div></div></div>;

<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::_Mem_fn::$__ctor@([_Memptr])[impl0]"><div><div class="token cpp_function">_Mem_fn</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::_Memptr'], [], [])"><div class="token cpp_type">_Memptr</div></div> <div class="def" id="NI$std::_Mem_fn::$__ctor@([_Memptr])[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>) <div class="token cpp_keyword ">noexcept</div>
		: _Pm(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::$__ctor@([_Memptr])[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>)
		{	<div class="token cpp_comment ">// construct, storing a pointer to member function/data</div>
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
		<div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;... <div class="def" id="NI$std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Args"><div><div class="token cpp_argument">_Args</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="expandable"><div class="disabled">		_NOEXCEPT_COND(_NOEXCEPT_OPER(_STD invoke(_Pm, _STD forward&lt;_Types&gt;(_Args)...)))	// strengthened</div>
<div class="expanded">		<div class="token cpp_keyword ">noexcept</div>(<div class="token cpp_keyword ">noexcept</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::invoke@decltype(*)([_Callable] &&, [_Types] &&...)'], [], [])"><div class="token cpp_function">invoke</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::_Pm'], [], [])"><div class="token cpp_field">_Pm</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...)))	<div class="token cpp_comment ">// strengthened</div></div></div>
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD invoke(_Pm, _STD forward&lt;_Types&gt;(_Args)...))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::invoke@decltype(*)([_Callable] &&, [_Types] &&...)'], [], [])"><div class="token cpp_function">invoke</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::_Pm'], [], [])"><div class="token cpp_field">_Pm</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...))</div></div>
		{	<div class="token cpp_comment ">// invoke a pointer to member function/data</div>
<div class="expandable"><div class="disabled">		return (_STD invoke(_Pm, _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::invoke@decltype(*)([_Callable] &&, [_Types] &&...)'], [], [])"><div class="token cpp_function">invoke</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::_Pm'], [], [])"><div class="token cpp_field">_Pm</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...));</div></div>
		}
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Rx"><div><div class="token cpp_type">_Rx</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline _Mem_fn&lt;_Rx _Ty::*&gt; mem_fn(_Rx _Ty::* _Pm) noexcept</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn'], [], [])"><div class="token cpp_type">_Mem_fn</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div> <div class="ref" onclick="jumpToSymbol([], ['std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*&gt; <div class="def" id="FB$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]"><div><div class="token cpp_function">mem_fn</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div> <div class="ref" onclick="jumpToSymbol([], ['std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::* <div class="def" id="NI$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Pm"><div><div class="token cpp_argument">_Pm</div></div></div>) <div class="token cpp_keyword ">noexcept</div></div></div>
	{	<div class="token cpp_comment ">// wrap a pointer to member function/data</div>
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Mem_fn'], [], [])"><div class="token cpp_type">_Mem_fn</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div> <div class="ref" onclick="jumpToSymbol([], ['std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>::*&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Pm'], [], [])"><div class="token cpp_argument">_Pm</div></div>));
	}

<div class="disabled">#if _HAS_CXX17</div>
<div class="disabled">	// CLASS TEMPLATE _Ebco_base</div>
<div class="disabled">template&lt;class _Ty,</div>
<div class="disabled">	bool = is_empty_v&lt;_Ty&gt; &amp;&amp; !is_final_v&lt;_Ty&gt;&gt;</div>
<div class="disabled">	class _Ebco_base</div>
<div class="disabled">		: private _Ty</div>
<div class="disabled">	{	// Empty Base Class Optimization, active</div>
<div class="disabled">private:</div>
<div class="disabled">	using _Mybase = _Ty;	// for visualization</div>

<div class="disabled">protected:</div>
<div class="disabled">	template&lt;class _Other,</div>
<div class="disabled">		enable_if_t&lt;!is_same_v&lt;remove_cv_t&lt;remove_reference_t&lt;_Other&gt;&gt;, _Ebco_base&gt;, int&gt; = 0&gt;</div>
<div class="disabled">		explicit _Ebco_base(_Other&amp;&amp; _Val) _NOEXCEPT_COND(is_nothrow_constructible_v&lt;_Ty, _Other&gt;)</div>
<div class="disabled">		: _Ty(_STD forward&lt;_Other&gt;(_Val))</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">	_Ty&amp; _Get_val() noexcept</div>
<div class="disabled">		{</div>
<div class="disabled">		return (*this);</div>
<div class="disabled">		}</div>

<div class="disabled">	const _Ty&amp; _Get_val() const noexcept</div>
<div class="disabled">		{</div>
<div class="disabled">		return (*this);</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">template&lt;class _Ty&gt;</div>
<div class="disabled">	class _Ebco_base&lt;_Ty, false&gt;</div>
<div class="disabled">	{	// Empty Base Class Optimization, inactive</div>
<div class="disabled">private:</div>
<div class="disabled">	_Ty _Myval;</div>

<div class="disabled">protected:</div>
<div class="disabled">	template&lt;class _Other,</div>
<div class="disabled">		enable_if_t&lt;!is_same_v&lt;remove_cv_t&lt;remove_reference_t&lt;_Other&gt;&gt;, _Ebco_base&gt;, int&gt; = 0&gt;</div>
<div class="disabled">		explicit _Ebco_base(_Other&amp;&amp; _Val) _NOEXCEPT_COND(is_nothrow_constructible_v&lt;_Ty, _Other&gt;)</div>
<div class="disabled">		: _Myval(_STD forward&lt;_Other&gt;(_Val))</div>
<div class="disabled">		{</div>
<div class="disabled">		}</div>

<div class="disabled">	_Ty&amp; _Get_val() noexcept</div>
<div class="disabled">		{</div>
<div class="disabled">		return (_Myval);</div>
<div class="disabled">		}</div>

<div class="disabled">	const _Ty&amp; _Get_val() const noexcept</div>
<div class="disabled">		{</div>
<div class="disabled">		return (_Myval);</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">	// FUNCTION TEMPLATE not_fn</div>
<div class="disabled">struct _Not_fn_tag</div>
<div class="disabled">	{</div>
<div class="disabled">	};</div>

<div class="disabled">template&lt;class _Decayed&gt;</div>
<div class="disabled">	class _Not_fn</div>
<div class="disabled">		: private _Ebco_base&lt;_Decayed&gt;</div>
<div class="disabled">	{	// wrap a callable object to be negated</div>
<div class="disabled">private:</div>
<div class="disabled">	using _Mybase = _Ebco_base&lt;_Decayed&gt;;</div>

<div class="disabled">public:</div>
<div class="disabled">	template&lt;class _Callable,</div>
<div class="disabled">		class _Tag,</div>
<div class="disabled">		enable_if_t&lt;is_same_v&lt;_Tag, _Not_fn_tag&gt;, int&gt; = 0&gt;</div>
<div class="disabled">		explicit _Not_fn(_Callable&amp;&amp; _Obj, _Tag)</div>
<div class="disabled">		_NOEXCEPT_COND(is_nothrow_constructible_v&lt;_Decayed, _Callable&gt;)	// strengthened</div>
<div class="disabled">		: _Mybase(_STD forward&lt;_Callable&gt;(_Obj))</div>
<div class="disabled">		{	// store a callable object</div>
<div class="disabled">		}</div>

<div class="disabled">	_Not_fn(const _Not_fn&amp;) = default;</div>
<div class="disabled">	_Not_fn(_Not_fn&amp;&amp;) = default;</div>

<div class="disabled">	template&lt;class... _Types&gt;</div>
<div class="disabled">		auto operator()(_Types&amp;&amp;... _Args) &amp;</div>
<div class="disabled">#ifndef __EDG__ // TRANSITION, VSO#604398</div>
<div class="disabled">		_NOEXCEPT_COND(_NOEXCEPT_OPER(!_STD invoke(this-&gt;_Get_val(),</div>
<div class="disabled">			_STD forward&lt;_Types&gt;(_Args)...)))	// strengthened</div>
<div class="disabled">#endif /* __EDG__ */</div>
<div class="disabled">		-&gt; decltype(!_STD declval&lt;invoke_result_t&lt;_Decayed&amp;, _Types...&gt;&gt;())</div>
<div class="disabled">		{	// call modifiable lvalue</div>
<div class="disabled">		return (!_STD invoke(this-&gt;_Get_val(), _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class... _Types&gt;</div>
<div class="disabled">		auto operator()(_Types&amp;&amp;... _Args) const &amp;</div>
<div class="disabled">#ifndef __EDG__ // TRANSITION, VSO#604398</div>
<div class="disabled">		_NOEXCEPT_COND(_NOEXCEPT_OPER(!_STD invoke(this-&gt;_Get_val(),</div>
<div class="disabled">			_STD forward&lt;_Types&gt;(_Args)...)))	// strengthened</div>
<div class="disabled">#endif /* __EDG__ */</div>
<div class="disabled">		-&gt; decltype(!_STD declval&lt;invoke_result_t&lt;const _Decayed&amp;, _Types...&gt;&gt;())</div>
<div class="disabled">		{	// call const lvalue</div>
<div class="disabled">		return (!_STD invoke(this-&gt;_Get_val(), _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class... _Types&gt;</div>
<div class="disabled">		auto operator()(_Types&amp;&amp;... _Args) &amp;&amp;</div>
<div class="disabled">#ifndef __EDG__ // TRANSITION, VSO#604398</div>
<div class="disabled">		_NOEXCEPT_COND(_NOEXCEPT_OPER(!_STD invoke(_STD move(this-&gt;_Get_val()),</div>
<div class="disabled">			_STD forward&lt;_Types&gt;(_Args)...)))	// strengthened</div>
<div class="disabled">#endif /* __EDG__ */</div>
<div class="disabled">		-&gt; decltype(!_STD declval&lt;invoke_result_t&lt;_Decayed, _Types...&gt;&gt;())</div>
<div class="disabled">		{	// call modifiable rvalue</div>
<div class="disabled">		return (!_STD invoke(_STD move(this-&gt;_Get_val()), _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class... _Types&gt;</div>
<div class="disabled">		auto operator()(_Types&amp;&amp;... _Args) const &amp;&amp;</div>
<div class="disabled">#ifndef __EDG__ // TRANSITION, VSO#604398</div>
<div class="disabled">		_NOEXCEPT_COND(_NOEXCEPT_OPER(!_STD invoke(_STD move(this-&gt;_Get_val()),</div>
<div class="disabled">			_STD forward&lt;_Types&gt;(_Args)...)))	// strengthened</div>
<div class="disabled">#endif /* __EDG__ */</div>
<div class="disabled">		-&gt; decltype(!_STD declval&lt;invoke_result_t&lt;const _Decayed, _Types...&gt;&gt;())</div>
<div class="disabled">		{	// call const rvalue</div>
<div class="disabled">		return (!_STD invoke(_STD move(this-&gt;_Get_val()), _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">template&lt;class _Callable&gt;</div>
<div class="disabled">	_NODISCARD _Not_fn&lt;decay_t&lt;_Callable&gt;&gt; not_fn(_Callable&amp;&amp; _Obj)</div>
<div class="disabled">	_NOEXCEPT_COND(is_nothrow_constructible_v&lt;decay_t&lt;_Callable&gt;, _Callable&gt;)	// strengthened</div>
<div class="disabled">	{	// wrap a callable object to be negated</div>
<div class="disabled">	return (_Not_fn&lt;decay_t&lt;_Callable&gt;&gt;(_STD forward&lt;_Callable&gt;(_Obj), _Not_fn_tag{}));</div>
<div class="disabled">	}
#endif /* _HAS_CXX17 */</div>

<div class="token cpp_comment ">// IMPLEMENT function</div>

	<div class="token cpp_comment ">// CLASS bad_function_call</div>
<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::bad_function_call"><div><div class="token cpp_type">bad_function_call</div></div></div>
	: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::exception'], [], [])"><div class="token cpp_type">exception</div></div>
	{	<div class="token cpp_comment ">// exception thrown when an empty std::function is called</div>
<div class="token cpp_keyword ">public</div>:
	<div class="def" id="FB$std::bad_function_call::$__ctor@()[impl0]"><div><div class="token cpp_function">bad_function_call</div></div></div>() <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// construct</div>
		}

<div class="expandable"><div class="disabled">	_NODISCARD virtual const char * __CLR_OR_THIS_CALL what() const noexcept override</div>
<div class="expanded">	 <div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">char</div> *  <div class="def" id="FB$std::bad_function_call::what@char const *()[impl0]"><div><div class="token cpp_function">what</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div> <div class="token cpp_keyword ">override</div></div></div>
		{	<div class="token cpp_comment ">// return pointer to message string</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_string ">&quot;bad function call&quot;</div>);
		}
	};

<div class="expandable"><div class="disabled">[[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xbad_function_call();</div>
<div class="expanded">[[noreturn]]  <div class="token cpp_keyword ">void</div> <div class="token cpp_keyword ">__cdecl</div> <div class="def" id="FB$std::_Xbad_function_call@void()[decl0]"><div><div class="token cpp_function">_Xbad_function_call</div></div></div>();</div></div>

	<div class="token cpp_comment ">// FUNCTION TEMPLATE _Test_callable</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::_Fty"><div><div class="token cpp_type">_Fty</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NF[0]$std::function"><div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div></div>;

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]"><div><div class="token cpp_function">_Test_callable</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Arg"><div><div class="token cpp_argument">_Arg</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::true_type'], [], [])"><div class="token cpp_type">true_type</div></div>) <div class="token cpp_keyword ">noexcept</div>
	{	<div class="token cpp_comment ">// std::function must store non-null testable callable objects</div>
	<div class="token cpp_keyword ">return</div> (!!<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Arg'], [], [])"><div class="token cpp_argument">_Arg</div></div>);
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Test_callable@bool([_Ty] const &, ::std::false_type)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::_Test_callable@bool([_Ty] const &, ::std::false_type)[impl0]"><div><div class="token cpp_function">_Test_callable</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &, ::std::false_type)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp;, <div class="ref" onclick="jumpToSymbol([], ['std::false_type'], [], [])"><div class="token cpp_type">false_type</div></div>) <div class="token cpp_keyword ">noexcept</div>
	{	<div class="token cpp_comment ">// std::function must store arbitrary callable objects</div>
	<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">true</div>);
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Test_callable@bool([_Ty] const &)[impl0]::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::_Test_callable@bool([_Ty] const &)[impl0]"><div><div class="token cpp_function">_Test_callable</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&amp; <div class="def" id="NI$std::_Test_callable@bool([_Ty] const &)[impl0]::_Arg"><div><div class="token cpp_argument">_Arg</div></div></div>) <div class="token cpp_keyword ">noexcept</div>
	{	<div class="token cpp_comment ">// determine whether std::function must store _Arg</div>
	<div class="ref" onclick="jumpToSymbol([], ['std::bool_constant'], [], [])"><div class="token cpp_type">bool_constant</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_member_pointer_v'], [], [])"><div class="token cpp_enum">is_member_pointer_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt; || (<div class="ref" onclick="jumpToSymbol([], ['std::is_pointer_v'], [], [])"><div class="token cpp_enum">is_pointer_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;
		&amp;&amp; <div class="ref" onclick="jumpToSymbol([], ['std::is_function_v'], [], [])"><div class="token cpp_enum">is_function_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::remove_pointer_t'], [], [])"><div class="token cpp_type">remove_pointer_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &)[impl0]::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;&gt;)&gt; <div class="def" id="NI$std::_Test_callable@bool([_Ty] const &)[impl0]::_Testable"><div>_Testable</div></div>;
	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool(::std::function<[_Fty]> const &)', 'std::_Test_callable@bool([_Ty] const &)', 'std::_Test_callable@bool([_Ty] const &, ::std::false_type)', 'std::_Test_callable@bool([_Ty] const &, ::std::true_type)'], [], [])"><div class="token cpp_function">_Test_callable</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &)[impl0]::_Arg'], [], [])"><div class="token cpp_argument">_Arg</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool([_Ty] const &)[impl0]::_Testable'], [], [])">_Testable</div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Fty"><div><div class="token cpp_type">_Fty</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]"><div><div class="token cpp_function">_Test_callable</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Fty'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;&amp; <div class="def" id="NI$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Arg"><div><div class="token cpp_argument">_Arg</div></div></div>) <div class="token cpp_keyword ">noexcept</div>
	{	<div class="token cpp_comment ">// determine whether std::function must store _Arg</div>
	<div class="token cpp_keyword ">return</div> (!!<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Arg'], [], [])"><div class="token cpp_argument">_Arg</div></div>);
	}

#pragma warning(push)
<div class="expandable"><div class="disabled">#pragma warning(disable: 4265)	// class has virtual functions, but destructor is not virtual</div>
<div class="expanded">#pragma warning(disable: <div class="token cpp_number ">4265</div>)	</div></div>
	<div class="token cpp_comment ">// CLASS TEMPLATE _Func_base</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_base::_Rx"><div><div class="token cpp_type">_Rx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Func_base::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="token cpp_keyword ">__declspec</div>(novtable) <div class="def" id="NI$std::_Func_base"><div><div class="token cpp_type">_Func_base</div></div></div>
	{	<div class="token cpp_comment ">// abstract base for implementation types</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div> * <div class="def" id="FB$std::_Func_base::_Copy@::std::_Func_base *(void *)[decl0]"><div><div class="token cpp_function">_Copy</div></div></div>(<div class="token cpp_keyword ">void</div> *) <div class="token cpp_keyword ">const</div> = <div class="token cpp_number ">0</div>;
	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div> * <div class="def" id="FB$std::_Func_base::_Move@::std::_Func_base *(void *)[decl0]"><div><div class="token cpp_function">_Move</div></div></div>(<div class="token cpp_keyword ">void</div> *) = <div class="token cpp_number ">0</div>;
	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div> <div class="def" id="FB$std::_Func_base::_Do_call@[_Rx]([_Types] &&...)[decl0]"><div><div class="token cpp_function">_Do_call</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_base::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;...) = <div class="token cpp_number ">0</div>;
	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['type_info'], [], [])"><div class="token cpp_type">type_info</div></div>&amp; <div class="def" id="FB$std::_Func_base::_Target_type@::type_info const &()[decl0]"><div><div class="token cpp_function">_Target_type</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div> = <div class="token cpp_number ">0</div>;
	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_base::_Delete_this@void(bool)[decl0]"><div><div class="token cpp_function">_Delete_this</div></div></div>(<div class="token cpp_keyword ">bool</div>) <div class="token cpp_keyword ">noexcept</div> = <div class="token cpp_number ">0</div>;

<div class="disabled">#if _HAS_STATIC_RTTI</div>
	<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">void</div> *<div class="def" id="FB$std::_Func_base::_Target@void const *(::type_info const &)[impl0]"><div><div class="token cpp_function">_Target</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['type_info'], [], [])"><div class="token cpp_type">type_info</div></div>&amp; <div class="def" id="NI$std::_Func_base::_Target@void const *(::type_info const &)[impl0]::_Info"><div><div class="token cpp_argument">_Info</div></div></div>) <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// return pointer to stored object of type _Info</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_base::_Target_type@::type_info const &()'], ['std::_Func_base::_Target_type@::type_info const &()'], [], [])"><div class="token cpp_function">_Target_type</div></div>() <div class="ref" onclick="jumpToSymbol(['type_info::operator ==@bool(::type_info const &)'], [], [], [])"><div class="token cpp_function">=</div><div class="token cpp_function">=</div></div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base::_Target@void const *(::type_info const &)[impl0]::_Info'], [], [])"><div class="token cpp_argument">_Info</div></div> ? <div class="ref" onclick="jumpToSymbol(['std::_Func_base::_Get@void const *()'], ['std::_Func_base::_Get@void const *()'], [], [])"><div class="token cpp_function">_Get</div></div>() : <div class="token cpp_keyword ">nullptr</div>);
		}
<div class="disabled">#endif /* _HAS_STATIC_RTTI */</div>

	<div class="def" id="FB$std::_Func_base::$__ctor@()[decl0]"><div><div class="token cpp_function">_Func_base</div></div></div>() = <div class="token cpp_keyword ">default</div>;
	<div class="def" id="FB$std::_Func_base::$__ctor@(::std::_Func_base const &)[decl0]"><div><div class="token cpp_function">_Func_base</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div>&amp;) = <div class="token cpp_keyword ">delete</div>;
	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div>&amp; <div class="def" id="FB$std::_Func_base::operator =@::std::_Func_base &(::std::_Func_base const &)[decl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">=</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div>&amp;) = <div class="token cpp_keyword ">delete</div>;
	<div class="token cpp_comment ">// dtor non-virtual due to _Delete_this()</div>

<div class="token cpp_keyword ">private</div>:
	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">void</div> *<div class="def" id="FB$std::_Func_base::_Get@void const *()[decl0]"><div><div class="token cpp_function">_Get</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div> = <div class="token cpp_number ">0</div>;
	};
#pragma warning(pop)

	<div class="token cpp_comment ">// STRUCT TEMPLATE _Is_large</div>
<div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['size_t'], [], [])"><div class="token cpp_type">size_t</div></div> <div class="def" id="NI$std::_Space_size"><div>_Space_size</div></div> = (<div class="ref" onclick="jumpToSymbol([], ['std::_Small_object_num_ptrs'], [], [])">_Small_object_num_ptrs</div> - <div class="token cpp_number ">1</div>) * <div class="token cpp_keyword ">sizeof</div> (<div class="token cpp_keyword ">void</div> *);

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Is_large::_Impl"><div><div class="token cpp_type">_Impl</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Is_large"><div><div class="token cpp_type">_Is_large</div></div></div>
		: <div class="ref" onclick="jumpToSymbol([], ['std::bool_constant'], [], [])"><div class="token cpp_type">bool_constant</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Space_size'], [], [])">_Space_size</div> <div class="ref" onclick="jumpToSymbol(['std::operator <@bool(::std::error_code const &, ::std::error_code const &)', 'std::operator <@bool(::std::error_condition const &, ::std::error_condition const &)'], [], [], [])"><div class="token cpp_function">&lt;</div></div> <div class="token cpp_keyword ">sizeof</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Is_large::_Impl'], [], [])"><div class="token cpp_type">_Impl</div></div>)
			|| !<div class="ref" onclick="jumpToSymbol([], ['std::_Is_large::_Impl'], [], [])"><div class="token cpp_type">_Impl</div></div>::_Nothrow_move::value&gt;
	{	<div class="token cpp_comment ">// determine whether _Impl must be dynamically allocated</div>
	};

#pragma warning(push)
<div class="expandable"><div class="disabled">#pragma warning(disable: 4265)	// class has virtual functions, but destructor is not virtual</div>
<div class="expanded">#pragma warning(disable: <div class="token cpp_number ">4265</div>)	</div></div>

<div class="disabled">#if _HAS_FUNCTION_ALLOCATOR_SUPPORT</div>
	<div class="token cpp_comment ">// CLASS TEMPLATE _Func_impl</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl::_Callable"><div><div class="token cpp_type">_Callable</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl::_Rx"><div><div class="token cpp_type">_Rx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Func_impl::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::_Func_impl"><div><div class="token cpp_type">_Func_impl</div></div></div> <div class="token cpp_keyword ">final</div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;
	{	<div class="token cpp_comment ">// derived class for specific implementation types that use allocators</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="NI$std::_Func_impl::_Mybase"><div><div class="token cpp_type">_Mybase</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Rebind_alloc_t'], [], [])"><div class="token cpp_type">_Rebind_alloc_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl'], [], [])"><div class="token cpp_type">_Func_impl</div></div>&gt; <div class="def" id="NI$std::_Func_impl::_Myalty"><div><div class="token cpp_type">_Myalty</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::allocator_traits'], [], [])"><div class="token cpp_type">allocator_traits</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty'], [], [])"><div class="token cpp_type">_Myalty</div></div>&gt; <div class="def" id="NI$std::_Func_impl::_Myalty_traits"><div><div class="token cpp_type">_Myalty_traits</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::is_nothrow_move_constructible'], [], [])"><div class="token cpp_type">is_nothrow_move_constructible</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>&gt; <div class="def" id="NI$std::_Func_impl::_Nothrow_move"><div><div class="token cpp_type">_Nothrow_move</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other1"><div><div class="token cpp_type">_Other1</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other2"><div><div class="token cpp_type">_Other2</div></div></div>&gt;
		<div class="def" id="FB$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]"><div><div class="token cpp_function">_Func_impl</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other1'], [], [])"><div class="token cpp_type">_Other1</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other2'], [], [])"><div class="token cpp_type">_Other2</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Ax"><div><div class="token cpp_argument">_Ax</div></div></div>)
		: _Mypair(<div class="ref" onclick="jumpToSymbol([], ['std::_One_then_variadic_args_t'], [], [])"><div class="token cpp_type">_One_then_variadic_args_t</div></div>(),
<div class="expandable"><div class="disabled">			_STD forward&lt;_Other2&gt;(_Ax), _STD forward&lt;_Other1&gt;(_Val))</div>
<div class="expanded">			::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other2'], [], [])"><div class="token cpp_type">_Other2</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Ax'], [], [])"><div class="token cpp_argument">_Ax</div></div>), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other1'], [], [])"><div class="token cpp_type">_Other1</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>))</div></div>
		{	<div class="token cpp_comment ">// construct</div>
		}

	<div class="token cpp_comment ">// dtor non-virtual due to _Delete_this()</div>

<div class="token cpp_keyword ">private</div>:
	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div> *<div class="def" id="FB$std::_Func_impl::_Copy@::std::_Func_impl::_Mybase *(void *)[impl0]"><div><div class="token cpp_function">_Copy</div></div></div>(<div class="token cpp_keyword ">void</div> *<div class="def" id="NI$std::_Func_impl::_Copy@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where"><div><div class="token cpp_argument">_Where</div></div></div>) <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// return clone of *this</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)', 'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)'], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)', 'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)'], [], [])"><div class="token cpp_function">_Clone</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Copy@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where'], [], [])"><div class="token cpp_argument">_Where</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Is_large'], [], [])"><div class="token cpp_type">_Is_large</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl'], [], [])"><div class="token cpp_type">_Func_impl</div></div>&gt;()));
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div> *<div class="def" id="FB$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]"><div><div class="token cpp_function">_Clone</div></div></div>(<div class="token cpp_keyword ">void</div> *, <div class="ref" onclick="jumpToSymbol([], ['std::true_type'], [], [])"><div class="token cpp_type">true_type</div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// return clone of *this, large (dynamically allocated)</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty'], [], [])"><div class="token cpp_type">_Myalty</div></div> <div class="def" id="NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Al"><div>_Al</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Myax@[_Alloc] const &()'], ['std::_Func_impl::_Myax@[_Alloc] &()', 'std::_Func_impl::_Myax@[_Alloc] const &()'], [], [])"><div class="token cpp_function">_Myax</div></div>());
		<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Ptr"><div>_Ptr</div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty_traits'], [], [])"><div class="token cpp_type">_Myalty_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const)'], ['std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const)', 'std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const, ::std::_Default_allocator_traits::const_void_pointer)'], [], [])"><div class="token cpp_function">allocate</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Al'], [], [])">_Al</div>, <div class="token cpp_number ">1</div>);

<div class="expandable"><div class="disabled">		_TRY_BEGIN</div>
<div class="expanded">		<div class="token cpp_keyword ">try</div> {</div></div>
			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty_traits'], [], [])"><div class="token cpp_type">_Myalty_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], ['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], [], [])"><div class="token cpp_function">construct</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Al'], [], [])">_Al</div>, <div class="ref" onclick="jumpToSymbol(['std::_Unfancy@[_Ty] *([_Ty] *)', 'std::_Unfancy@auto([_Ptrty])'], ['std::_Unfancy@[_Ty] *([_Ty] *)', 'std::_Unfancy@auto([_Ptrty])'], [], [])"><div class="token cpp_function">_Unfancy</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Ptr'], [], [])">_Ptr</div>), <div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Callee@[_Callable] const &()'], ['std::_Func_impl::_Callee@[_Callable] &()', 'std::_Func_impl::_Callee@[_Callable] const &()'], [], [])"><div class="token cpp_function">_Callee</div></div>(), <div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Myax@[_Alloc] const &()'], ['std::_Func_impl::_Myax@[_Alloc] &()', 'std::_Func_impl::_Myax@[_Alloc] const &()'], [], [])"><div class="token cpp_function">_Myax</div></div>());
<div class="expandable"><div class="disabled">		_CATCH_ALL</div>
<div class="expanded">		} <div class="token cpp_keyword ">catch</div> (...) {</div></div>
			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty_traits'], [], [])"><div class="token cpp_type">_Myalty_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::deallocate@void([_Alloc] &, ::std::_Default_allocator_traits::pointer const, ::std::_Default_allocator_traits::size_type const)'], ['std::_Default_allocator_traits::deallocate@void([_Alloc] &, ::std::_Default_allocator_traits::pointer const, ::std::_Default_allocator_traits::size_type const)'], [], [])"><div class="token cpp_function">deallocate</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Al'], [], [])">_Al</div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Ptr'], [], [])">_Ptr</div>, <div class="token cpp_number ">1</div>);
<div class="expandable"><div class="disabled">		_RERAISE;</div>
<div class="expanded">		<div class="token cpp_keyword ">throw</div>;</div></div>
<div class="expandable"><div class="disabled">		_CATCH_END</div>
<div class="expanded">		}</div></div>

		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Unfancy@[_Ty] *([_Ty] *)', 'std::_Unfancy@auto([_Ptrty])'], ['std::_Unfancy@[_Ty] *([_Ty] *)', 'std::_Unfancy@auto([_Ptrty])'], [], [])"><div class="token cpp_function">_Unfancy</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Ptr'], [], [])">_Ptr</div>));
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div> *<div class="def" id="FB$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]"><div><div class="token cpp_function">_Clone</div></div></div>(<div class="token cpp_keyword ">void</div> *<div class="def" id="NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Where"><div><div class="token cpp_argument">_Where</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::false_type'], [], [])"><div class="token cpp_type">false_type</div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// return clone of *this, small (locally stored)</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty'], [], [])"><div class="token cpp_type">_Myalty</div></div> <div class="def" id="NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Al"><div>_Al</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Myax@[_Alloc] const &()'], ['std::_Func_impl::_Myax@[_Alloc] &()', 'std::_Func_impl::_Myax@[_Alloc] const &()'], [], [])"><div class="token cpp_function">_Myax</div></div>());
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl'], [], [])"><div class="token cpp_type">_Func_impl</div></div> * <div class="def" id="NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Ptr"><div>_Ptr</div></div> = <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl'], [], [])"><div class="token cpp_type">_Func_impl</div></div> *&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Where'], [], [])"><div class="token cpp_argument">_Where</div></div>);
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty_traits'], [], [])"><div class="token cpp_type">_Myalty_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], ['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], [], [])"><div class="token cpp_function">construct</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Al'], [], [])">_Al</div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Ptr'], [], [])">_Ptr</div>, <div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Callee@[_Callable] const &()'], ['std::_Func_impl::_Callee@[_Callable] &()', 'std::_Func_impl::_Callee@[_Callable] const &()'], [], [])"><div class="token cpp_function">_Callee</div></div>(), <div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Myax@[_Alloc] const &()'], ['std::_Func_impl::_Myax@[_Alloc] &()', 'std::_Func_impl::_Myax@[_Alloc] const &()'], [], [])"><div class="token cpp_function">_Myax</div></div>());
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Ptr'], [], [])">_Ptr</div>);
		}

	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div> *<div class="def" id="FB$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]"><div><div class="token cpp_function">_Move</div></div></div>(<div class="token cpp_keyword ">void</div> *<div class="def" id="NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where"><div><div class="token cpp_argument">_Where</div></div></div>) <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// return clone of *this</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty'], [], [])"><div class="token cpp_type">_Myalty</div></div> <div class="def" id="NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Al"><div>_Al</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Myax@[_Alloc] &()'], ['std::_Func_impl::_Myax@[_Alloc] &()', 'std::_Func_impl::_Myax@[_Alloc] const &()'], [], [])"><div class="token cpp_function">_Myax</div></div>());
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl'], [], [])"><div class="token cpp_type">_Func_impl</div></div> *<div class="def" id="NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Ptr"><div>_Ptr</div></div> = <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl'], [], [])"><div class="token cpp_type">_Func_impl</div></div> *&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where'], [], [])"><div class="token cpp_argument">_Where</div></div>);
<div class="expandable"><div class="disabled">		_Myalty_traits::construct(_Al, _Ptr, _STD move(_Callee()), _STD move(_Myax()));</div>
<div class="expanded">		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty_traits'], [], [])"><div class="token cpp_type">_Myalty_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], ['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], [], [])"><div class="token cpp_function">construct</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Al'], [], [])">_Al</div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Ptr'], [], [])">_Ptr</div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Callee@[_Callable] &()'], ['std::_Func_impl::_Callee@[_Callable] &()', 'std::_Func_impl::_Callee@[_Callable] const &()'], [], [])"><div class="token cpp_function">_Callee</div></div>()), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Myax@[_Alloc] &()'], ['std::_Func_impl::_Myax@[_Alloc] &()', 'std::_Func_impl::_Myax@[_Alloc] const &()'], [], [])"><div class="token cpp_function">_Myax</div></div>()));</div></div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Ptr'], [], [])">_Ptr</div>);
		}

	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div> <div class="def" id="FB$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[decl0]"><div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)'], [], [])"><div class="token cpp_function">_Do_call</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;... <div class="def" id="NI$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[decl0]::_Args"><div>_Args</div></div>) <div class="token cpp_keyword ">override</div>;

	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['type_info'], [], [])"><div class="token cpp_type">type_info</div></div>&amp; <div class="def" id="FB$std::_Func_impl::_Target_type@::type_info const &()[impl0]"><div><div class="token cpp_function">_Target_type</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div> <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// return type information for stored object</div>
<div class="disabled">#if _HAS_STATIC_RTTI</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">typeid</div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>));
<div class="disabled">#else /* _HAS_STATIC_RTTI */</div>
<div class="disabled">		return (typeid(void));
#endif /* _HAS_STATIC_RTTI */</div>
		}

	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">void</div> *<div class="def" id="FB$std::_Func_impl::_Get@void const *()[impl0]"><div><div class="token cpp_function">_Get</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div> <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// return address of stored object</div>
<div class="expandable"><div class="disabled">		return (_STD addressof(_Callee()));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::addressof@[_Ty] *([_Ty] &)'], ['std::addressof@[_Ty] *([_Ty] &)', 'std::addressof@[_Ty] const *([_Ty] const &&)'], [], [])"><div class="token cpp_function">addressof</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Callee@[_Callable] const &()'], ['std::_Func_impl::_Callee@[_Callable] &()', 'std::_Func_impl::_Callee@[_Callable] const &()'], [], [])"><div class="token cpp_function">_Callee</div></div>()));</div></div>
		}

	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_impl::_Delete_this@void(bool)[impl0]"><div><div class="token cpp_function">_Delete_this</div></div></div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::_Func_impl::_Delete_this@void(bool)[impl0]::_Deallocate"><div><div class="token cpp_argument">_Deallocate</div></div></div>) <div class="token cpp_keyword ">noexcept</div> <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// destroy self</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty'], [], [])"><div class="token cpp_type">_Myalty</div></div> <div class="def" id="NI$std::_Func_impl::_Delete_this@void(bool)[impl0]::_Al"><div>_Al</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Myax@[_Alloc] &()'], ['std::_Func_impl::_Myax@[_Alloc] &()', 'std::_Func_impl::_Myax@[_Alloc] const &()'], [], [])"><div class="token cpp_function">_Myax</div></div>());
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Myalty_traits'], [], [])"><div class="token cpp_type">_Myalty_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::destroy@void([_Alloc] &, [_Uty] * const)'], ['std::_Default_allocator_traits::destroy@void([_Alloc] &, [_Uty] * const)'], [], [])"><div class="token cpp_function">destroy</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Delete_this@void(bool)[impl0]::_Al'], [], [])">_Al</div>, <div class="token cpp_keyword ">this</div>);
		<div class="token cpp_keyword ">if</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Delete_this@void(bool)[impl0]::_Deallocate'], [], [])"><div class="token cpp_argument">_Deallocate</div></div>)
			{
			<div class="ref" onclick="jumpToSymbol([], ['std::_Deallocate_plain@void([_Alloc] &, value_type * const)'], [], [])"><div class="token cpp_function">_Deallocate_plain</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Delete_this@void(bool)[impl0]::_Al'], [], [])">_Al</div>, <div class="token cpp_keyword ">this</div>);
			}
		}

	<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>'], ['std::_Compressed_pair'], [], [])"><div class="token cpp_type">_Compressed_pair</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>&gt; <div class="def" id="NI$std::_Func_impl::_Mypair"><div><div class="token cpp_field">_Mypair</div></div></div>;

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="FB$std::_Func_impl::_Myax@[_Alloc] &()[impl0]"><div><div class="token cpp_function">_Myax</div></div></div>() <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// return reference to allocator</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()'], ['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], [], [])"><div class="token cpp_function">_Get_first</div></div>());
		}

	<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="FB$std::_Func_impl::_Myax@[_Alloc] const &()[impl0]"><div><div class="token cpp_function">_Myax</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// return const reference to allocator</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], ['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], [], [])"><div class="token cpp_function">_Get_first</div></div>());
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>&amp; <div class="def" id="FB$std::_Func_impl::_Callee@[_Callable] &()[impl0]"><div><div class="token cpp_function">_Callee</div></div></div>() <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// return reference to wrapped function</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()'], ['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], [], [])"><div class="token cpp_function">_Get_second</div></div>());
		}

	<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>&amp; <div class="def" id="FB$std::_Func_impl::_Callee@[_Callable] const &()[impl0]"><div><div class="token cpp_function">_Callee</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// return const reference to wrapped function</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], ['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], [], [])"><div class="token cpp_function">_Get_second</div></div>());
		}
	};
<div class="disabled">#endif /* _HAS_FUNCTION_ALLOCATOR_SUPPORT */</div>

	<div class="token cpp_comment ">// CLASS TEMPLATE _Func_impl_no_alloc</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl_no_alloc::_Callable"><div><div class="token cpp_type">_Callable</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl_no_alloc::_Rx"><div><div class="token cpp_type">_Rx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Func_impl_no_alloc::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::_Func_impl_no_alloc"><div><div class="token cpp_type">_Func_impl_no_alloc</div></div></div> <div class="token cpp_keyword ">final</div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;
	{	<div class="token cpp_comment ">// derived class for specific implementation types that don&apos;t use allocators</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="NI$std::_Func_impl_no_alloc::_Mybase"><div><div class="token cpp_type">_Mybase</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::is_nothrow_move_constructible'], [], [])"><div class="token cpp_type">is_nothrow_move_constructible</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>&gt; <div class="def" id="NI$std::_Func_impl_no_alloc::_Nothrow_move"><div><div class="token cpp_type">_Nothrow_move</div></div></div>;

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Other"><div><div class="token cpp_type">_Other</div></div></div>,
		<div class="token cpp_keyword ">class</div> = <div class="ref" onclick="jumpToSymbol([], ['std::enable_if_t'], [], [])"><div class="token cpp_type">enable_if_t</div></div>&lt;!<div class="ref" onclick="jumpToSymbol([], ['std::is_same_v'], [], [])"><div class="token cpp_enum">is_same_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::decay_t'], [], [])"><div class="token cpp_type">decay_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Other'], [], [])"><div class="token cpp_type">_Other</div></div>&gt;&gt;&gt;&gt;
		<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]"><div><div class="token cpp_function">_Func_impl_no_alloc</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Other'], [], [])"><div class="token cpp_type">_Other</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>)
<div class="expandable"><div class="disabled">		: _Callee(_STD forward&lt;_Other&gt;(_Val))</div>
<div class="expanded">		: _Callee(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Other'], [], [])"><div class="token cpp_type">_Other</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>))</div></div>
		{	<div class="token cpp_comment ">// construct</div>
		}

	<div class="token cpp_comment ">// dtor non-virtual due to _Delete_this()</div>

<div class="token cpp_keyword ">private</div>:
	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div> *<div class="def" id="FB$std::_Func_impl_no_alloc::_Copy@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]"><div><div class="token cpp_function">_Copy</div></div></div>(<div class="token cpp_keyword ">void</div> *<div class="def" id="NI$std::_Func_impl_no_alloc::_Copy@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where"><div><div class="token cpp_argument">_Where</div></div></div>) <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// return clone of *this</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)', 'std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::true_type)'], ['std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)', 'std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::true_type)'], [], [])"><div class="token cpp_function">_Clone</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Copy@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where'], [], [])"><div class="token cpp_argument">_Where</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Is_large'], [], [])"><div class="token cpp_type">_Is_large</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>&gt;()));
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div> *<div class="def" id="FB$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::true_type)[impl0]"><div><div class="token cpp_function">_Clone</div></div></div>(<div class="token cpp_keyword ">void</div> *, <div class="ref" onclick="jumpToSymbol([], ['std::true_type'], [], [])"><div class="token cpp_type">true_type</div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// return clone of *this, large (dynamically allocated)</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Global_new@[_Ty] *([_Types] &&...)'], ['std::_Global_new@[_Ty] *([_Types] &&...)'], [], [])"><div class="token cpp_function">_Global_new</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Callee'], [], [])"><div class="token cpp_field">_Callee</div></div>));
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div> *<div class="def" id="FB$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)[impl0]"><div><div class="token cpp_function">_Clone</div></div></div>(<div class="token cpp_keyword ">void</div> *<div class="def" id="NI$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)[impl0]::_Where"><div><div class="token cpp_argument">_Where</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::false_type'], [], [])"><div class="token cpp_type">false_type</div></div>) <div class="token cpp_keyword ">const</div>
		{	<div class="token cpp_comment ">// return clone of *this, small (locally stored)</div>
		<div class="token cpp_keyword ">return</div> (::<div class="token cpp_keyword ">new</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)[impl0]::_Where'], [], [])"><div class="token cpp_argument">_Where</div></div>) <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Callee'], [], [])"><div class="token cpp_field">_Callee</div></div>));
		}

	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div> *<div class="def" id="FB$std::_Func_impl_no_alloc::_Move@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]"><div><div class="token cpp_function">_Move</div></div></div>(<div class="token cpp_keyword ">void</div> *<div class="def" id="NI$std::_Func_impl_no_alloc::_Move@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where"><div><div class="token cpp_argument">_Where</div></div></div>) <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// return clone of *this</div>
<div class="expandable"><div class="disabled">		return (::new (_Where) _Func_impl_no_alloc(_STD move(_Callee)));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="token cpp_keyword ">new</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Move@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where'], [], [])"><div class="token cpp_argument">_Where</div></div>) <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Callee'], [], [])"><div class="token cpp_field">_Callee</div></div>)));</div></div>
		}

	<div class="token cpp_keyword ">virtual</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div> <div class="def" id="FB$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[decl0]"><div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)'], [], [])"><div class="token cpp_function">_Do_call</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;... <div class="def" id="NI$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[decl0]::_Args"><div>_Args</div></div>) <div class="token cpp_keyword ">override</div>;

	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['type_info'], [], [])"><div class="token cpp_type">type_info</div></div>&amp; <div class="def" id="FB$std::_Func_impl_no_alloc::_Target_type@::type_info const &()[impl0]"><div><div class="token cpp_function">_Target_type</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div> <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// return type information for stored object</div>
<div class="disabled">#if _HAS_STATIC_RTTI</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">typeid</div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>));
<div class="disabled">#else /* _HAS_STATIC_RTTI */</div>
<div class="disabled">		return (typeid(void));
#endif /* _HAS_STATIC_RTTI */</div>
		}

	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">void</div> *<div class="def" id="FB$std::_Func_impl_no_alloc::_Get@void const *()[impl0]"><div><div class="token cpp_function">_Get</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div> <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// return address of stored object</div>
<div class="expandable"><div class="disabled">		return (_STD addressof(_Callee));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::addressof@[_Ty] *([_Ty] &)'], ['std::addressof@[_Ty] *([_Ty] &)', 'std::addressof@[_Ty] const *([_Ty] const &&)'], [], [])"><div class="token cpp_function">addressof</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Callee'], [], [])"><div class="token cpp_field">_Callee</div></div>));</div></div>
		}

	<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_impl_no_alloc::_Delete_this@void(bool)[impl0]"><div><div class="token cpp_function">_Delete_this</div></div></div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::_Func_impl_no_alloc::_Delete_this@void(bool)[impl0]::_Dealloc"><div><div class="token cpp_argument">_Dealloc</div></div></div>) <div class="token cpp_keyword ">noexcept</div> <div class="token cpp_keyword ">override</div>
		{	<div class="token cpp_comment ">// destroy self</div>
		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_impl_no_alloc::~_Func_impl_no_alloc@()'], ['std::_Func_impl_no_alloc::~_Func_impl_no_alloc@()'], [], [])"><div class="token cpp_function">~</div><div class="token cpp_function">_Func_impl_no_alloc</div></div>();
		<div class="token cpp_keyword ">if</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Delete_this@void(bool)[impl0]::_Dealloc'], [], [])"><div class="token cpp_argument">_Dealloc</div></div>)
			{
			<div class="ref" onclick="jumpToSymbol(['std::_Deallocate@void(void *, ::size_t)'], ['std::_Deallocate@void(void *, ::size_t)'], [], [])"><div class="token cpp_function">_Deallocate</div></div>&lt;alignof(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>)&gt;(<div class="token cpp_keyword ">this</div>, <div class="token cpp_keyword ">sizeof</div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>));
			}
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div> <div class="def" id="NI$std::_Func_impl_no_alloc::_Callee"><div><div class="token cpp_field">_Callee</div></div></div>;
	};
#pragma warning(pop)

	<div class="token cpp_comment ">// CLASS TEMPLATE _Func_class</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Func_class::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::_Func_class"><div><div class="token cpp_type">_Func_class</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol(['std::_Arg_types', 'std::_Arg_types@<[_Ty1], [_Ty2]>', 'std::_Arg_types@<[_Ty1]>'], ['std::_Arg_types'], [], [])"><div class="token cpp_type">_Arg_types</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;
	{	<div class="token cpp_comment ">// implement function template</div>
<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div> <div class="def" id="NI$std::_Func_class::result_type"><div><div class="token cpp_type">result_type</div></div></div>;

	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_base'], [], [])"><div class="token cpp_type">_Func_base</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="NI$std::_Func_class::_Ptrt"><div><div class="token cpp_type">_Ptrt</div></div></div>;

	<div class="def" id="FB$std::_Func_class::$__ctor@()[impl0]"><div><div class="token cpp_function">_Func_class</div></div></div>() <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// construct without stored object</div>
		<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="token cpp_keyword ">nullptr</div>);
		}

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div> <div class="def" id="FB$std::_Func_class::operator ()@[_Ret]([_Types]...)[decl0]"><div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)'], [], [])"><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>... <div class="def" id="NI$std::_Func_class::operator ()@[_Ret]([_Types]...)[decl0]::_Args"><div>_Args</div></div>) <div class="token cpp_keyword ">const</div>;

	<div class="def" id="FB$std::_Func_class::~_Func_class@()[impl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">_Func_class</div></div></div>() <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// destroy the object</div>
		<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Tidy@void()'], ['std::_Func_class::_Tidy@void()'], [], [])"><div class="token cpp_function">_Tidy</div></div>();
		}

<div class="token cpp_keyword ">protected</div>:
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Enable_if_callable_t::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Enable_if_callable_t::_Function"><div><div class="token cpp_type">_Function</div></div></div>&gt;
		<div class="token cpp_keyword ">using</div> <div class="def" id="NI$std::_Func_class::_Enable_if_callable_t"><div><div class="token cpp_type">_Enable_if_callable_t</div></div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::enable_if_t'], [], [])"><div class="token cpp_type">enable_if_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::conjunction_v'], [], [])"><div class="token cpp_enum">conjunction_v</div></div>&lt;
			<div class="ref" onclick="jumpToSymbol([], ['std::negation'], [], [])"><div class="token cpp_type">negation</div></div>&lt;<div class="ref" onclick="jumpToSymbol(['std::is_same', 'std::is_same@<[_Ty1], [_Ty1]>'], ['std::is_same'], [], [])"><div class="token cpp_type">is_same</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::decay_t'], [], [])"><div class="token cpp_type">decay_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Enable_if_callable_t::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Enable_if_callable_t::_Function'], [], [])"><div class="token cpp_type">_Function</div></div>&gt;&gt;,
			<div class="ref" onclick="jumpToSymbol([], ['std::_Is_invocable_r'], [], [])"><div class="token cpp_type">_Is_invocable_r</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Enable_if_callable_t::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;&gt;&gt;;

	<div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::_Func_class::_Empty@bool()[impl0]"><div><div class="token cpp_function">_Empty</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// return true if no stored object</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>() == <div class="token cpp_keyword ">nullptr</div>);
		}

	<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]"><div><div class="token cpp_function">_Reset_copy</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div>&amp; <div class="def" id="NI$std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		{	<div class="token cpp_comment ">// copy _Right&apos;s stored object</div>
		<div class="token cpp_keyword ">if</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Empty@bool()'], ['std::_Func_class::_Empty@bool()'], [], [])"><div class="token cpp_function">_Empty</div></div>())
			{
			<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>()-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_base::_Copy@::std::_Func_base *(void *)'], ['std::_Func_base::_Copy@::std::_Func_base *(void *)'], [], [])"><div class="token cpp_function">_Copy</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getspace@void *()'], ['std::_Func_class::_Getspace@void *()', 'std::_Func_class::_Getspace@void const *()'], [], [])"><div class="token cpp_function">_Getspace</div></div>()));
			}
		}

	<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]"><div><div class="token cpp_function">_Reset_move</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		{	<div class="token cpp_comment ">// move _Right&apos;s stored object</div>
		<div class="token cpp_keyword ">if</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Empty@bool()'], ['std::_Func_class::_Empty@bool()'], [], [])"><div class="token cpp_function">_Empty</div></div>())
			{
			<div class="token cpp_keyword ">if</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Local@bool()'], ['std::_Func_class::_Local@bool()'], [], [])"><div class="token cpp_function">_Local</div></div>())
				{	<div class="token cpp_comment ">// move and tidy</div>
				<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>()-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_base::_Move@::std::_Func_base *(void *)'], ['std::_Func_base::_Move@::std::_Func_base *(void *)'], [], [])"><div class="token cpp_function">_Move</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getspace@void *()'], ['std::_Func_class::_Getspace@void *()', 'std::_Func_class::_Getspace@void const *()'], [], [])"><div class="token cpp_function">_Getspace</div></div>()));
				<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Tidy@void()'], ['std::_Func_class::_Tidy@void()'], [], [])"><div class="token cpp_function">_Tidy</div></div>();
				}
			<div class="token cpp_keyword ">else</div>
				{	<div class="token cpp_comment ">// steal from _Right</div>
				<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>());
				<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="token cpp_keyword ">nullptr</div>);
				}
			}
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>&gt;
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Reset@void([_Fx] &&)[impl0]"><div><div class="token cpp_function">_Reset</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>)
		{	<div class="token cpp_comment ">// store copy of _Val</div>
		<div class="token cpp_keyword ">if</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool(::std::function<[_Fty]> const &)', 'std::_Test_callable@bool([_Ty] const &)', 'std::_Test_callable@bool([_Ty] const &, ::std::false_type)', 'std::_Test_callable@bool([_Ty] const &, ::std::true_type)'], [], [])"><div class="token cpp_function">_Test_callable</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>))
			{	<div class="token cpp_comment ">// null member pointer/function pointer/std::function</div>
			<div class="token cpp_keyword ">return</div>;	<div class="token cpp_comment ">// already empty</div>
			}

		<div class="token cpp_keyword ">using</div> <div class="def" id="NI$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Impl"><div><div class="token cpp_type">_Impl</div></div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::decay_t'], [], [])"><div class="token cpp_type">decay_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;;
<div class="expandable"><div class="disabled">		_Reset_impl&lt;_Impl&gt;(_STD forward&lt;_Fx&gt;(_Val), _Is_large&lt;_Impl&gt;());</div>
<div class="expanded">		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)', 'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)'], [], [])"><div class="token cpp_function">_Reset_impl</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Impl'], [], [])"><div class="token cpp_type">_Impl</div></div>&gt;(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>), <div class="ref" onclick="jumpToSymbol([], ['std::_Is_large'], [], [])"><div class="token cpp_type">_Is_large</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Impl'], [], [])"><div class="token cpp_type">_Impl</div></div>&gt;());</div></div>
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Myimpl"><div><div class="token cpp_type">_Myimpl</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>&gt;
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]"><div><div class="token cpp_function">_Reset_impl</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::true_type'], [], [])"><div class="token cpp_type">true_type</div></div>)
		{	<div class="token cpp_comment ">// store copy of _Val, large (dynamically allocated)</div>
<div class="expandable"><div class="disabled">		_Set(_Global_new&lt;_Myimpl&gt;(_STD forward&lt;_Fx&gt;(_Val)));</div>
<div class="expanded">		<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Global_new@[_Ty] *([_Types] &&...)'], ['std::_Global_new@[_Ty] *([_Types] &&...)'], [], [])"><div class="token cpp_function">_Global_new</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div>&gt;(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>)));</div></div>
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Myimpl"><div><div class="token cpp_type">_Myimpl</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>&gt;
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]"><div><div class="token cpp_function">_Reset_impl</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::false_type'], [], [])"><div class="token cpp_type">false_type</div></div>)
		{	<div class="token cpp_comment ">// store copy of _Val, small (locally stored)</div>
<div class="expandable"><div class="disabled">		_Set(::new (_Getspace()) _Myimpl(_STD forward&lt;_Fx&gt;(_Val)));</div>
<div class="expanded">		<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(::<div class="token cpp_keyword ">new</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getspace@void *()'], ['std::_Func_class::_Getspace@void *()', 'std::_Func_class::_Getspace@void const *()'], [], [])"><div class="token cpp_function">_Getspace</div></div>()) <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>)));</div></div>
		}

<div class="disabled">#if _HAS_FUNCTION_ALLOCATOR_SUPPORT</div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>&gt;
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]"><div><div class="token cpp_function">_Reset_alloc</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax"><div><div class="token cpp_argument">_Ax</div></div></div>)
		{	<div class="token cpp_comment ">// store copy of _Val with allocator</div>
		<div class="token cpp_keyword ">if</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::_Test_callable@bool(::std::function<[_Fty]> const &)', 'std::_Test_callable@bool([_Ty] const &)', 'std::_Test_callable@bool([_Ty] const &, ::std::false_type)', 'std::_Test_callable@bool([_Ty] const &, ::std::true_type)'], [], [])"><div class="token cpp_function">_Test_callable</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>))
			{	<div class="token cpp_comment ">// null member pointer/function pointer/std::function</div>
			<div class="token cpp_keyword ">return</div>;	<div class="token cpp_comment ">// already empty</div>
			}

		<div class="token cpp_keyword ">using</div> <div class="def" id="NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Myimpl"><div><div class="token cpp_type">_Myimpl</div></div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl'], [], [])"><div class="token cpp_type">_Func_impl</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::decay_t'], [], [])"><div class="token cpp_type">decay_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;;
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div> *<div class="def" id="NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ptr"><div>_Ptr</div></div> = <div class="token cpp_keyword ">nullptr</div>;

		<div class="ref" onclick="jumpToSymbol([], ['std::_Rebind_alloc_t'], [], [])"><div class="token cpp_type">_Rebind_alloc_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div>&gt; <div class="def" id="NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Al"><div>_Al</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax'], [], [])"><div class="token cpp_argument">_Ax</div></div>);
<div class="expandable"><div class="disabled">		_Reset_impl_alloc(_STD forward&lt;_Fx&gt;(_Val), _Ax, _Ptr, _Al, _Is_large&lt;_Myimpl&gt;());</div>
<div class="expanded">		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)', 'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)'], [], [])"><div class="token cpp_function">_Reset_impl_alloc</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>), <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax'], [], [])"><div class="token cpp_argument">_Ax</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ptr'], [], [])">_Ptr</div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Al'], [], [])">_Al</div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Is_large'], [], [])"><div class="token cpp_type">_Is_large</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div>&gt;());</div></div>
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Myimpl"><div><div class="token cpp_type">_Myimpl</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl"><div><div class="token cpp_type">_Alimpl</div></div></div>&gt;
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]"><div><div class="token cpp_function">_Reset_impl_alloc</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ax"><div><div class="token cpp_argument">_Ax</div></div></div>,
			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div> *, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl'], [], [])"><div class="token cpp_type">_Alimpl</div></div>&amp; <div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Al"><div><div class="token cpp_argument">_Al</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::true_type'], [], [])"><div class="token cpp_type">true_type</div></div>)
		{	<div class="token cpp_comment ">// store copy of _Val with allocator, large (dynamically allocated)</div>
		<div class="token cpp_keyword ">using</div> <div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl_traits"><div><div class="token cpp_type">_Alimpl_traits</div></div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::allocator_traits'], [], [])"><div class="token cpp_type">allocator_traits</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl'], [], [])"><div class="token cpp_type">_Alimpl</div></div>&gt;;
		<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ptr"><div>_Ptr</div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl_traits'], [], [])"><div class="token cpp_type">_Alimpl_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const)'], ['std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const)', 'std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const, ::std::_Default_allocator_traits::const_void_pointer)'], [], [])"><div class="token cpp_function">allocate</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Al'], [], [])"><div class="token cpp_argument">_Al</div></div>, <div class="token cpp_number ">1</div>);

<div class="expandable"><div class="disabled">		_TRY_BEGIN</div>
<div class="expanded">		<div class="token cpp_keyword ">try</div> {</div></div>
<div class="expandable"><div class="disabled">			_Alimpl_traits::construct(_Al, _Unfancy(_Ptr), _STD forward&lt;_Fx&gt;(_Val), _Ax);</div>
<div class="expanded">			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl_traits'], [], [])"><div class="token cpp_type">_Alimpl_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], ['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], [], [])"><div class="token cpp_function">construct</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Al'], [], [])"><div class="token cpp_argument">_Al</div></div>, <div class="ref" onclick="jumpToSymbol(['std::_Unfancy@[_Ty] *([_Ty] *)', 'std::_Unfancy@auto([_Ptrty])'], ['std::_Unfancy@[_Ty] *([_Ty] *)', 'std::_Unfancy@auto([_Ptrty])'], [], [])"><div class="token cpp_function">_Unfancy</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ptr'], [], [])">_Ptr</div>), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>), <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ax'], [], [])"><div class="token cpp_argument">_Ax</div></div>);</div></div>
<div class="expandable"><div class="disabled">		_CATCH_ALL</div>
<div class="expanded">		} <div class="token cpp_keyword ">catch</div> (...) {</div></div>
			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl_traits'], [], [])"><div class="token cpp_type">_Alimpl_traits</div></div>::<div class="ref" onclick="jumpToSymbol(['std::_Default_allocator_traits::deallocate@void([_Alloc] &, ::std::_Default_allocator_traits::pointer const, ::std::_Default_allocator_traits::size_type const)'], ['std::_Default_allocator_traits::deallocate@void([_Alloc] &, ::std::_Default_allocator_traits::pointer const, ::std::_Default_allocator_traits::size_type const)'], [], [])"><div class="token cpp_function">deallocate</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Al'], [], [])"><div class="token cpp_argument">_Al</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ptr'], [], [])">_Ptr</div>, <div class="token cpp_number ">1</div>);
<div class="expandable"><div class="disabled">		_RERAISE;</div>
<div class="expanded">		<div class="token cpp_keyword ">throw</div>;</div></div>
<div class="expandable"><div class="disabled">		_CATCH_END</div>
<div class="expanded">		}</div></div>

		<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Unfancy@[_Ty] *([_Ty] *)', 'std::_Unfancy@auto([_Ptrty])'], ['std::_Unfancy@[_Ty] *([_Ty] *)', 'std::_Unfancy@auto([_Ptrty])'], [], [])"><div class="token cpp_function">_Unfancy</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ptr'], [], [])">_Ptr</div>));
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Myimpl"><div><div class="token cpp_type">_Myimpl</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alimpl"><div><div class="token cpp_type">_Alimpl</div></div></div>&gt;
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]"><div><div class="token cpp_function">_Reset_impl_alloc</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Val"><div><div class="token cpp_argument">_Val</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ax"><div><div class="token cpp_argument">_Ax</div></div></div>,
			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div> *, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alimpl'], [], [])"><div class="token cpp_type">_Alimpl</div></div>&amp; <div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Al"><div><div class="token cpp_argument">_Al</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::false_type'], [], [])"><div class="token cpp_type">false_type</div></div>)
		{	<div class="token cpp_comment ">// store copy of _Val with allocator, small (locally stored)</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div> *<div class="def" id="NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ptr"><div>_Ptr</div></div> = <div class="token cpp_keyword ">static_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Myimpl'], [], [])"><div class="token cpp_type">_Myimpl</div></div> *&gt;(<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getspace@void *()'], ['std::_Func_class::_Getspace@void *()', 'std::_Func_class::_Getspace@void const *()'], [], [])"><div class="token cpp_function">_Getspace</div></div>());
<div class="expandable"><div class="disabled">		allocator_traits&lt;_Alimpl&gt;::construct(_Al, _Ptr, _STD forward&lt;_Fx&gt;(_Val), _Ax);</div>
<div class="expanded">		<div class="ref" onclick="jumpToSymbol([], ['std::allocator_traits'], [], [])"><div class="token cpp_type">allocator_traits</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alimpl'], [], [])"><div class="token cpp_type">_Alimpl</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)'], [], [])"><div class="token cpp_function">construct</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Al'], [], [])"><div class="token cpp_argument">_Al</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ptr'], [], [])">_Ptr</div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Val'], [], [])"><div class="token cpp_argument">_Val</div></div>), <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ax'], [], [])"><div class="token cpp_argument">_Ax</div></div>);</div></div>
		<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ptr'], [], [])">_Ptr</div>);
		}
<div class="disabled">#endif /* _HAS_FUNCTION_ALLOCATOR_SUPPORT */</div>

	<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Tidy@void()[impl0]"><div><div class="token cpp_function">_Tidy</div></div></div>() <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// clean up</div>
		<div class="token cpp_keyword ">if</div> (!<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Empty@bool()'], ['std::_Func_class::_Empty@bool()'], [], [])"><div class="token cpp_function">_Empty</div></div>())
			{	<div class="token cpp_comment ">// destroy callable object and maybe delete it</div>
			<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>()-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_base::_Delete_this@void(bool)'], ['std::_Func_base::_Delete_this@void(bool)'], [], [])"><div class="token cpp_function">_Delete_this</div></div>(!<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Local@bool()'], ['std::_Func_class::_Local@bool()'], [], [])"><div class="token cpp_function">_Local</div></div>());
			<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="token cpp_keyword ">nullptr</div>);
			}
		}

	<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]"><div><div class="token cpp_function">_Swap</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div>&amp; <div class="def" id="NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// swap contents with contents of _Right</div>
		<div class="token cpp_keyword ">if</div> (!<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Local@bool()'], ['std::_Func_class::_Local@bool()'], [], [])"><div class="token cpp_function">_Local</div></div>() &amp;&amp; !<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Local@bool()'], ['std::_Func_class::_Local@bool()'], [], [])"><div class="token cpp_function">_Local</div></div>())
			{	<div class="token cpp_comment ">// just swap pointers</div>
			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ptrt'], [], [])"><div class="token cpp_type">_Ptrt</div></div> *<div class="def" id="NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp"><div>_Temp</div></div> = <div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>();
			<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>());
			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)'], [], [])"><div class="token cpp_function">_Set</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp'], [], [])">_Temp</div>);
			}
		<div class="token cpp_keyword ">else</div>
			{	<div class="token cpp_comment ">// do three-way move</div>
			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div> <div class="def" id="NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp2"><div>_Temp</div></div>;
<div class="expandable"><div class="disabled">			_Temp._Reset_move(_STD move(*this));</div>
<div class="expanded">			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp2'], [], [])">_Temp</div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], [], [])"><div class="token cpp_function">_Reset_move</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(*<div class="token cpp_keyword ">this</div>));</div></div>
<div class="expandable"><div class="disabled">			_Reset_move(_STD move(_Right));</div>
<div class="expanded">			<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], [], [])"><div class="token cpp_function">_Reset_move</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
<div class="expandable"><div class="disabled">			_Right._Reset_move(_STD move(_Temp));</div>
<div class="expanded">			<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], [], [])"><div class="token cpp_function">_Reset_move</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp2'], [], [])">_Temp</div>));</div></div>
			}
		}

<div class="disabled">#if _HAS_STATIC_RTTI</div>
	<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['type_info'], [], [])"><div class="token cpp_type">type_info</div></div>&amp; <div class="def" id="FB$std::_Func_class::_Target_type@::type_info const &()[impl0]"><div><div class="token cpp_function">_Target_type</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// return type information for stored object</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>() ? <div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>()-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_base::_Target_type@::type_info const &()'], ['std::_Func_base::_Target_type@::type_info const &()'], [], [])"><div class="token cpp_function">_Target_type</div></div>() : <div class="token cpp_keyword ">typeid</div>(<div class="token cpp_keyword ">void</div>));
		}

	<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">void</div> *<div class="def" id="FB$std::_Func_class::_Target@void const *(::type_info const &)[impl0]"><div><div class="token cpp_function">_Target</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['type_info'], [], [])"><div class="token cpp_type">type_info</div></div>&amp; <div class="def" id="NI$std::_Func_class::_Target@void const *(::type_info const &)[impl0]::_Info"><div><div class="token cpp_argument">_Info</div></div></div>) <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// return pointer to stored object</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>() ? <div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>()-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_base::_Target@void const *(::type_info const &)'], ['std::_Func_base::_Target@void const *(::type_info const &)'], [], [])"><div class="token cpp_function">_Target</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Target@void const *(::type_info const &)[impl0]::_Info'], [], [])"><div class="token cpp_argument">_Info</div></div>) : <div class="token cpp_keyword ">nullptr</div>);
		}
<div class="disabled">#endif /* _HAS_STATIC_RTTI */</div>

<div class="token cpp_keyword ">private</div>:
	<div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::_Func_class::_Local@bool()[impl0]"><div><div class="token cpp_function">_Local</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// test for locally stored copy of object</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>() <div class="ref" onclick="jumpToSymbol(['std::operator ==@bool(::std::error_code const &, ::std::error_code const &)', 'std::operator ==@bool(::std::error_code const &, ::std::error_condition const &)', 'std::operator ==@bool(::std::error_condition const &, ::std::error_code const &)', 'std::operator ==@bool(::std::error_condition const &, ::std::error_condition const &)'], [], [], [])"><div class="token cpp_function">=</div><div class="token cpp_function">=</div></div> <div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getspace@void const *()'], ['std::_Func_class::_Getspace@void *()', 'std::_Func_class::_Getspace@void const *()'], [], [])"><div class="token cpp_function">_Getspace</div></div>());
		}

	<div class="token cpp_keyword ">union</div> <div class="def" id="NI$std::_Func_class::_Storage"><div><div class="token cpp_type">_Storage</div></div></div>
		{	<div class="token cpp_comment ">// storage for small objects (basic_string is small)</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::max_align_t'], [], [])"><div class="token cpp_type">max_align_t</div></div> <div class="def" id="NI$std::_Func_class::_Storage::_Dummy1"><div><div class="token cpp_field">_Dummy1</div></div></div>;	<div class="token cpp_comment ">// for maximum alignment</div>
		<div class="token cpp_keyword ">char</div> <div class="def" id="NI$std::_Func_class::_Storage::_Dummy2"><div><div class="token cpp_field">_Dummy2</div></div></div>[<div class="ref" onclick="jumpToSymbol([], ['std::_Space_size'], [], [])">_Space_size</div>];	<div class="token cpp_comment ">// to permit aliasing</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ptrt'], [], [])"><div class="token cpp_type">_Ptrt</div></div> *<div class="def" id="NI$std::_Func_class::_Storage::_Ptrs"><div><div class="token cpp_field">_Ptrs</div></div></div>[<div class="ref" onclick="jumpToSymbol([], ['std::_Small_object_num_ptrs'], [], [])">_Small_object_num_ptrs</div>];	<div class="token cpp_comment ">// _Ptrs[_Small_object_num_ptrs - 1] is reserved</div>
		};

	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Storage'], [], [])"><div class="token cpp_type">_Storage</div></div> <div class="def" id="NI$std::_Func_class::_Mystorage"><div><div class="token cpp_field">_Mystorage</div></div></div>;
	<div class="token cpp_keyword ">enum</div> {<div class="def" id="NI$std::_Func_class::<anonymous>31::_EEN_IMPL"><div><div class="token cpp_enum">_EEN_IMPL</div></div></div> = <div class="ref" onclick="jumpToSymbol([], ['std::_Small_object_num_ptrs'], [], [])">_Small_object_num_ptrs</div> - <div class="token cpp_number ">1</div>};	<div class="token cpp_comment ">// helper for expression evaluator</div>
	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ptrt'], [], [])"><div class="token cpp_type">_Ptrt</div></div> *<div class="def" id="FB$std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()[impl0]"><div><div class="token cpp_function">_Getimpl</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// get pointer to object</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Mystorage'], [], [])"><div class="token cpp_field">_Mystorage</div></div>.<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Storage::_Ptrs'], [], [])"><div class="token cpp_field">_Ptrs</div></div>[<div class="ref" onclick="jumpToSymbol([], ['std::_Small_object_num_ptrs'], [], [])">_Small_object_num_ptrs</div> - <div class="token cpp_number ">1</div>]);
		}

	<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)[impl0]"><div><div class="token cpp_function">_Set</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Ptrt'], [], [])"><div class="token cpp_type">_Ptrt</div></div> *<div class="def" id="NI$std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)[impl0]::_Ptr"><div><div class="token cpp_argument">_Ptr</div></div></div>) <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// store pointer to object</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Mystorage'], [], [])"><div class="token cpp_field">_Mystorage</div></div>.<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Storage::_Ptrs'], [], [])"><div class="token cpp_field">_Ptrs</div></div>[<div class="ref" onclick="jumpToSymbol([], ['std::_Small_object_num_ptrs'], [], [])">_Small_object_num_ptrs</div> - <div class="token cpp_number ">1</div>] = <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)[impl0]::_Ptr'], [], [])"><div class="token cpp_argument">_Ptr</div></div>;
		}

	<div class="token cpp_keyword ">void</div> *<div class="def" id="FB$std::_Func_class::_Getspace@void *()[impl0]"><div><div class="token cpp_function">_Getspace</div></div></div>() <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// get pointer to storage space</div>
		<div class="token cpp_keyword ">return</div> (&amp;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Mystorage'], [], [])"><div class="token cpp_field">_Mystorage</div></div>);
		}

	<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">void</div> *<div class="def" id="FB$std::_Func_class::_Getspace@void const *()[impl0]"><div><div class="token cpp_function">_Getspace</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// get pointer to storage space</div>
		<div class="token cpp_keyword ">return</div> (&amp;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Mystorage'], [], [])"><div class="token cpp_field">_Mystorage</div></div>);
		}
	};

	<div class="token cpp_comment ">// STRUCT TEMPLATE _Get_function_impl</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Get_function_impl::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$std::_Get_function_impl"><div class="ref" onclick="jumpToSymbol([], [], ['std::_Get_function_impl@<[_Ret]([_Types]...)>', 'std::_Get_function_impl@<[_Ret]([_Types]...)>2', 'std::_Get_function_impl@<[_Ret]([_Types]...)>3', 'std::_Get_function_impl@<[_Ret]([_Types]...)>4'], [])"><div class="token cpp_type">_Get_function_impl</div></div></div>;

<div class="disabled">#define _GET_FUNCTION_IMPL(CALL_OPT, X1, X2, X3) \</div>
<div class="disabled">template&lt;class _Ret, \</div>
<div class="disabled">	class... _Types&gt; \</div>
<div class="disabled">	struct _Get_function_impl&lt;_Ret CALL_OPT (_Types...)&gt; \</div>
<div class="disabled">	{	/* determine type from argument list */ \</div>
<div class="disabled">	typedef _Func_class&lt;_Ret, _Types...&gt; type; \</div>
<div class="disabled">	};</div>

<div class="expandable"><div class="disabled">_NON_MEMBER_CALL(_GET_FUNCTION_IMPL, X1, X2, X3)</div>
<div class="expanded"><div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Get_function_impl@<[_Ret]([_Types]...)>::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>, <div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Get_function_impl@<[_Ret]([_Types]...)>::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt; <div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Get_function_impl@<[_Ret]([_Types]...)>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::_Get_function_impl'])"><div class="token cpp_type">_Get_function_impl</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div> <div class="token cpp_keyword ">__cdecl</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...)&gt; { <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="NI$std::_Get_function_impl@<[_Ret]([_Types]...)>::type"><div><div class="token cpp_type">type</div></div></div>; };  <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>, <div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt; <div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Get_function_impl@<[_Ret]([_Types]...)>2"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::_Get_function_impl'])"><div class="token cpp_type">_Get_function_impl</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div> <div class="token cpp_keyword ">__fastcall</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...)&gt; { <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="NI$std::_Get_function_impl@<[_Ret]([_Types]...)>2::type"><div><div class="token cpp_type">type</div></div></div>; }; <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>, <div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt; <div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Get_function_impl@<[_Ret]([_Types]...)>3"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::_Get_function_impl'])"><div class="token cpp_type">_Get_function_impl</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div> <div class="token cpp_keyword ">__stdcall</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...)&gt; { <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="NI$std::_Get_function_impl@<[_Ret]([_Types]...)>3::type"><div><div class="token cpp_type">type</div></div></div>; }; <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>, <div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt; <div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Get_function_impl@<[_Ret]([_Types]...)>4"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::_Get_function_impl'])"><div class="token cpp_type">_Get_function_impl</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div> <div class="token cpp_keyword ">__vectorcall</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...)&gt; { <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="NI$std::_Get_function_impl@<[_Ret]([_Types]...)>4::type"><div><div class="token cpp_type">type</div></div></div>; };</div></div>
<div class="disabled">#undef _GET_FUNCTION_IMPL</div>

	<div class="token cpp_comment ">// CLASS TEMPLATE function</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::_Fty2"><div><div class="token cpp_type">_Fty</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::function"><div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol(['std::_Get_function_impl', 'std::_Get_function_impl@<[_Ret]([_Types]...)>', 'std::_Get_function_impl@<[_Ret]([_Types]...)>2', 'std::_Get_function_impl@<[_Ret]([_Types]...)>3', 'std::_Get_function_impl@<[_Ret]([_Types]...)>4'], ['std::_Get_function_impl'], [], [])"><div class="token cpp_type">_Get_function_impl</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::_Fty2'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>2::type', 'std::_Get_function_impl@<[_Ret]([_Types]...)>3::type', 'std::_Get_function_impl@<[_Ret]([_Types]...)>4::type', 'std::_Get_function_impl@<[_Ret]([_Types]...)>::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// wrapper for callable objects</div>
<div class="token cpp_keyword ">private</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol(['std::_Get_function_impl', 'std::_Get_function_impl@<[_Ret]([_Types]...)>', 'std::_Get_function_impl@<[_Ret]([_Types]...)>2', 'std::_Get_function_impl@<[_Ret]([_Types]...)>3', 'std::_Get_function_impl@<[_Ret]([_Types]...)>4'], ['std::_Get_function_impl'], [], [])"><div class="token cpp_type">_Get_function_impl</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::_Fty2'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::_Get_function_impl@<[_Ret]([_Types]...)>2::type', 'std::_Get_function_impl@<[_Ret]([_Types]...)>3::type', 'std::_Get_function_impl@<[_Ret]([_Types]...)>4::type', 'std::_Get_function_impl@<[_Ret]([_Types]...)>::type'], [], [])"><div class="token cpp_type">type</div></div> <div class="def" id="NI$std::function::_Mybase"><div><div class="token cpp_type">_Mybase</div></div></div>;

<div class="token cpp_keyword ">public</div>:
	<div class="def" id="FB$std::function::$__ctor@()[impl0]"><div><div class="token cpp_function">function</div></div></div>() <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// construct empty function wrapper</div>
		}

	<div class="def" id="FB$std::function::$__ctor@(::std::nullptr_t)[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::nullptr_t'], [], [])"><div class="token cpp_type">nullptr_t</div></div>) <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// construct empty function wrapper from null pointer</div>
		}

	<div class="def" id="FB$std::function::$__ctor@(::std::function const &)[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="NI$std::function::$__ctor@(::std::function const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		{	<div class="token cpp_comment ">// construct holding copy of _Right</div>
		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Reset_copy@void(::std::_Func_class const &)'], ['std::_Func_class::_Reset_copy@void(::std::_Func_class const &)'], [], [])"><div class="token cpp_function">_Reset_copy</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::function const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::$__ctor@([_Fx])[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
		<div class="token cpp_keyword ">class</div> = <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div>::<div class="token cpp_keyword ">template</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Enable_if_callable_t'], [], [])"><div class="token cpp_type">_Enable_if_callable_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@([_Fx])[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;, <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&gt;&gt;
		<div class="def" id="FB$std::function::$__ctor@([_Fx])[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@([_Fx])[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div> <div class="def" id="NI$std::function::$__ctor@([_Fx])[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>)
		{	<div class="token cpp_comment ">// construct wrapper holding copy of _Func</div>
<div class="expandable"><div class="disabled">		this-&gt;_Reset(_STD move(_Func));</div>
<div class="expanded">		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Reset@void([_Fx] &&)'], ['std::_Func_class::_Reset@void([_Fx] &&)'], [], [])"><div class="token cpp_function">_Reset</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@([_Fx])[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>));</div></div>
		}

<div class="disabled">#if _HAS_FUNCTION_ALLOCATOR_SUPPORT</div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>&gt;
		<div class="def" id="FB$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &)[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::allocator_arg_t'], [], [])"><div class="token cpp_type">allocator_arg_t</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp;) <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// construct empty function wrapper, allocator</div>
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::nullptr_t)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>&gt;
		<div class="def" id="FB$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::nullptr_t)[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::allocator_arg_t'], [], [])"><div class="token cpp_type">allocator_arg_t</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::nullptr_t)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp;, <div class="ref" onclick="jumpToSymbol([], ['std::nullptr_t'], [], [])"><div class="token cpp_type">nullptr_t</div></div>) <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// construct empty function wrapper from null pointer, allocator</div>
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>&gt;
		<div class="def" id="FB$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::allocator_arg_t'], [], [])"><div class="token cpp_type">allocator_arg_t</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Ax"><div><div class="token cpp_argument">_Ax</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		{	<div class="token cpp_comment ">// construct wrapper holding copy of _Right, allocator</div>
		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)'], [], [])"><div class="token cpp_function">_Reset_alloc</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Ax'], [], [])"><div class="token cpp_argument">_Ax</div></div>);
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>,
		<div class="token cpp_keyword ">class</div> = <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div>::<div class="token cpp_keyword ">template</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Enable_if_callable_t'], [], [])"><div class="token cpp_type">_Enable_if_callable_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;, <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&gt;&gt;
		<div class="def" id="FB$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::allocator_arg_t'], [], [])"><div class="token cpp_type">allocator_arg_t</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Ax"><div><div class="token cpp_argument">_Ax</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div> <div class="def" id="NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>)
		{	<div class="token cpp_comment ">// construct wrapper holding copy of _Func, allocator</div>
<div class="expandable"><div class="disabled">		this-&gt;_Reset_alloc(_STD move(_Func), _Ax);</div>
<div class="expanded">		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)'], [], [])"><div class="token cpp_function">_Reset_alloc</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>), <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Ax'], [], [])"><div class="token cpp_argument">_Ax</div></div>);</div></div>
		}
<div class="disabled">#endif /* _HAS_FUNCTION_ALLOCATOR_SUPPORT */</div>

	<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="FB$std::function::operator =@::std::function &(::std::function const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">=</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="NI$std::function::operator =@::std::function &(::std::function const &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		{	<div class="token cpp_comment ">// assign _Right</div>
		<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &(::std::function const &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>).<div class="ref" onclick="jumpToSymbol(['std::function::swap@void(::std::function &)'], ['std::function::swap@void(::std::function &)'], [], [])"><div class="token cpp_function">swap</div></div>(*<div class="token cpp_keyword ">this</div>);
		<div class="token cpp_keyword ">return</div> (*<div class="token cpp_keyword ">this</div>);
		}

	<div class="def" id="FB$std::function::$__ctor@(::std::function &&)[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp;&amp; <div class="def" id="NI$std::function::$__ctor@(::std::function &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		{	<div class="token cpp_comment ">// construct holding moved copy of _Right</div>
<div class="expandable"><div class="disabled">		this-&gt;_Reset_move(_STD move(_Right));</div>
<div class="expanded">		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], [], [])"><div class="token cpp_function">_Reset_move</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::function &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
		}

<div class="disabled">#if _HAS_FUNCTION_ALLOCATOR_SUPPORT</div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>&gt;
		<div class="def" id="FB$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]"><div><div class="token cpp_function">function</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::allocator_arg_t'], [], [])"><div class="token cpp_type">allocator_arg_t</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Al"><div><div class="token cpp_argument">_Al</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp;&amp; <div class="def" id="NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		{	<div class="token cpp_comment ">// construct wrapper holding moved copy of _Right, allocator</div>
<div class="expandable"><div class="disabled">		this-&gt;_Reset_alloc(_STD move(_Right), _Al);</div>
<div class="expanded">		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)'], [], [])"><div class="token cpp_function">_Reset_alloc</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>), <div class="ref" onclick="jumpToSymbol([], ['std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Al'], [], [])"><div class="token cpp_argument">_Al</div></div>);</div></div>
		}
<div class="disabled">#endif /* _HAS_FUNCTION_ALLOCATOR_SUPPORT */</div>

	<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="FB$std::function::operator =@::std::function &(::std::function &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">=</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp;&amp; <div class="def" id="NI$std::function::operator =@::std::function &(::std::function &&)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>)
		{	<div class="token cpp_comment ">// assign by moving _Right</div>
<div class="expandable"><div class="disabled">		if (this != _STD addressof(_Right))</div>
<div class="expanded">		<div class="token cpp_keyword ">if</div> (<div class="token cpp_keyword ">this</div> <div class="ref" onclick="jumpToSymbol(['std::operator !=@bool(::std::error_code const &, ::std::error_code const &)', 'std::operator !=@bool(::std::error_code const &, ::std::error_condition const &)', 'std::operator !=@bool(::std::error_condition const &, ::std::error_code const &)', 'std::operator !=@bool(::std::error_condition const &, ::std::error_condition const &)'], [], [], [])"><div class="token cpp_function">!</div><div class="token cpp_function">=</div></div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::addressof@[_Ty] *([_Ty] &)'], ['std::addressof@[_Ty] *([_Ty] &)', 'std::addressof@[_Ty] const *([_Ty] const &&)'], [], [])"><div class="token cpp_function">addressof</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &(::std::function &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>))</div></div>
			{	<div class="token cpp_comment ">// clean up and copy</div>
			<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Tidy@void()'], ['std::_Func_class::_Tidy@void()'], [], [])"><div class="token cpp_function">_Tidy</div></div>();
<div class="expandable"><div class="disabled">			this-&gt;_Reset_move(_STD move(_Right));</div>
<div class="expanded">			<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], ['std::_Func_class::_Reset_move@void(::std::_Func_class &&)'], [], [])"><div class="token cpp_function">_Reset_move</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &(::std::function &&)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>));</div></div>
			}
		<div class="token cpp_keyword ">return</div> (*<div class="token cpp_keyword ">this</div>);
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
		<div class="token cpp_keyword ">class</div> = <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::_Mybase'], [], [])"><div class="token cpp_type">_Mybase</div></div>::<div class="token cpp_keyword ">template</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::_Enable_if_callable_t'], [], [])"><div class="token cpp_type">_Enable_if_callable_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::decay_t'], [], [])"><div class="token cpp_type">decay_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;&amp;, <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&gt;&gt;
		<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="FB$std::function::operator =@::std::function &([_Fx] &&)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">=</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>)
		{	<div class="token cpp_comment ">// assign function object _Func</div>
<div class="expandable"><div class="disabled">		function(_STD forward&lt;_Fx&gt;(_Func)).swap(*this);</div>
<div class="expanded">		<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>)).<div class="ref" onclick="jumpToSymbol(['std::function::swap@void(::std::function &)'], ['std::function::swap@void(::std::function &)'], [], [])"><div class="token cpp_function">swap</div></div>(*<div class="token cpp_keyword ">this</div>);</div></div>
		<div class="token cpp_keyword ">return</div> (*<div class="token cpp_keyword ">this</div>);
		}

<div class="disabled">#if _HAS_FUNCTION_ALLOCATOR_SUPPORT</div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
		<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>&gt;
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]"><div><div class="token cpp_function">assign</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&amp; <div class="def" id="NI$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax"><div><div class="token cpp_argument">_Ax</div></div></div>)
		{	<div class="token cpp_comment ">// assign wrapper holding copy of _Func, allocator</div>
<div class="expandable"><div class="disabled">		function(allocator_arg, _Ax, _STD forward&lt;_Fx&gt;(_Func)).swap(*this);</div>
<div class="expanded">		<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::allocator_arg'], [], [])">allocator_arg</div>, <div class="ref" onclick="jumpToSymbol([], ['std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax'], [], [])"><div class="token cpp_argument">_Ax</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>)).<div class="ref" onclick="jumpToSymbol(['std::function::swap@void(::std::function &)'], ['std::function::swap@void(::std::function &)'], [], [])"><div class="token cpp_function">swap</div></div>(*<div class="token cpp_keyword ">this</div>);</div></div>
		}
<div class="disabled">#endif /* _HAS_FUNCTION_ALLOCATOR_SUPPORT */</div>

	<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="FB$std::function::operator =@::std::function &(::std::nullptr_t)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">=</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::nullptr_t'], [], [])"><div class="token cpp_type">nullptr_t</div></div>) <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// clear function object</div>
		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Tidy@void()'], ['std::_Func_class::_Tidy@void()'], [], [])"><div class="token cpp_function">_Tidy</div></div>();
		<div class="token cpp_keyword ">return</div> (*<div class="token cpp_keyword ">this</div>);
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>&gt;
		<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="FB$std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">=</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::reference_wrapper'], [], [])"><div class="token cpp_type">reference_wrapper</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt; <div class="def" id="NI$std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>) <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// assign wrapper holding reference_wrapper to function object</div>
		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Tidy@void()'], ['std::_Func_class::_Tidy@void()'], [], [])"><div class="token cpp_function">_Tidy</div></div>();
		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Reset@void([_Fx] &&)'], ['std::_Func_class::_Reset@void([_Fx] &&)'], [], [])"><div class="token cpp_function">_Reset</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>);
		<div class="token cpp_keyword ">return</div> (*<div class="token cpp_keyword ">this</div>);
		}

	<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::function::swap@void(::std::function &)[impl0]"><div><div class="token cpp_function">swap</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&amp; <div class="def" id="NI$std::function::swap@void(::std::function &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// swap with _Right</div>
		<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Swap@void(::std::_Func_class &)'], ['std::_Func_class::_Swap@void(::std::_Func_class &)'], [], [])"><div class="token cpp_function">_Swap</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::swap@void(::std::function &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
		}

	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::function::$__type@bool()[impl0]"><div><div class="token cpp_keyword ">operator</div></div></div> <div class="token cpp_keyword ">bool</div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div>
		{	<div class="token cpp_comment ">// test if wrapper holds function object</div>
		<div class="token cpp_keyword ">return</div> (!<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Empty@bool()'], ['std::_Func_class::_Empty@bool()'], [], [])"><div class="token cpp_function">_Empty</div></div>());
		}

<div class="disabled">#if _HAS_STATIC_RTTI</div>
<div class="expandable"><div class="disabled">	_NODISCARD const type_info&amp; target_type() const noexcept</div>
<div class="expanded">	 <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['type_info'], [], [])"><div class="token cpp_type">type_info</div></div>&amp; <div class="def" id="FB$std::function::target_type@::type_info const &()[impl0]"><div><div class="token cpp_function">target_type</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div></div></div>
		{	<div class="token cpp_comment ">// return type_info object for target type</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Target_type@::type_info const &()'], ['std::_Func_class::_Target_type@::type_info const &()'], [], [])"><div class="token cpp_function">_Target_type</div></div>());
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::target@[_Fx] *()[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>&gt;
<div class="expandable"><div class="disabled">		_NODISCARD _Fx * target() noexcept</div>
<div class="expanded">		 <div class="ref" onclick="jumpToSymbol([], ['std::function::target@[_Fx] *()[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div> * <div class="def" id="FB$std::function::target@[_Fx] *()[impl0]"><div><div class="token cpp_function">target</div></div></div>() <div class="token cpp_keyword ">noexcept</div></div></div>
		{	<div class="token cpp_comment ">// return pointer to target object</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">reinterpret_cast</div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function::target@[_Fx] *()[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div> *&gt;(<div class="token cpp_keyword ">const_cast</div>&lt;<div class="token cpp_keyword ">void</div> *&gt;(<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Target@void const *(::type_info const &)'], ['std::_Func_class::_Target@void const *(::type_info const &)'], [], [])"><div class="token cpp_function">_Target</div></div>(<div class="token cpp_keyword ">typeid</div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::target@[_Fx] *()[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>)))));
		}

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::function::target@[_Fx] const *()[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>&gt;
<div class="expandable"><div class="disabled">		_NODISCARD const _Fx * target() const noexcept</div>
<div class="expanded">		 <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::target@[_Fx] const *()[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div> * <div class="def" id="FB$std::function::target@[_Fx] const *()[impl0]"><div><div class="token cpp_function">target</div></div></div>() <div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">noexcept</div></div></div>
		{	<div class="token cpp_comment ">// return pointer to target object</div>
		<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">reinterpret_cast</div>&lt;<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function::target@[_Fx] const *()[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div> *&gt;(<div class="token cpp_keyword ">this</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Target@void const *(::type_info const &)'], ['std::_Func_class::_Target@void const *(::type_info const &)'], [], [])"><div class="token cpp_function">_Target</div></div>(<div class="token cpp_keyword ">typeid</div>(<div class="ref" onclick="jumpToSymbol([], ['std::function::target@[_Fx] const *()[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>))));
		}
<div class="disabled">#else /* _HAS_STATIC_RTTI */</div>
<div class="disabled">	const type_info&amp; target_type() const noexcept = delete;	// requires static RTTI</div>

<div class="disabled">	template&lt;class _Fx&gt;</div>
<div class="disabled">		_Fx *target() noexcept = delete;	// requires static RTTI</div>

<div class="disabled">	template&lt;class _Fx&gt;</div>
<div class="disabled">		const _Fx *target() const noexcept = delete;	// requires static RTTI
#endif /* _HAS_STATIC_RTTI */</div>
	};

<div class="disabled">#if _HAS_CXX17</div>

<div class="disabled">#define _FUNCTION_POINTER_DEDUCTION_GUIDE(CALL_OPT, X1, X2, X3) \</div>
<div class="disabled">template&lt;class _Ret, \</div>
<div class="disabled">	class... _Types&gt; \</div>
<div class="disabled">	function(_Ret (CALL_OPT *)(_Types...)) \</div>
<div class="disabled">		-&gt; function&lt;_Ret (_Types...)&gt;;	// intentionally discards CALL_OPT</div>

<div class="disabled">_NON_MEMBER_CALL(_FUNCTION_POINTER_DEDUCTION_GUIDE, X1, X2, X3)</div>
<div class="disabled">#undef _FUNCTION_POINTER_DEDUCTION_GUIDE</div>

<div class="disabled">	// STRUCT TEMPLATE _Deduce_signature</div>
<div class="disabled">template&lt;class _Fx,</div>
<div class="disabled">	class = void&gt;</div>
<div class="disabled">	struct _Deduce_signature</div>
<div class="disabled">	{	// can&apos;t deduce signature when &amp;_Fx::operator() is missing, inaccessible, or ambiguous</div>
<div class="disabled">	};</div>

<div class="disabled">template&lt;class _Fx&gt;</div>
<div class="disabled">	struct _Deduce_signature&lt;_Fx, void_t&lt;decltype(&amp;_Fx::operator())&gt;&gt;</div>
<div class="disabled">		: _Is_memfunptr&lt;decltype(&amp;_Fx::operator())&gt;::_Guide_type</div>
<div class="disabled">	{	// N4687 23.14.13.2.1 [func.wrap.func.con]/12</div>
<div class="disabled">	};</div>

<div class="disabled">template&lt;class _Fx&gt;</div>
<div class="disabled">	function(_Fx)</div>
<div class="disabled">		-&gt; function&lt;typename _Deduce_signature&lt;_Fx&gt;::type&gt;;
#endif /* _HAS_CXX17 */</div>

	<div class="token cpp_comment ">// FUNCTION TEMPLATE swap</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Fty"><div><div class="token cpp_type">_Fty</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_keyword ">void</div> <div class="def" id="FB$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]"><div><div class="token cpp_function">swap</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Fty'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;&amp; <div class="def" id="NI$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Left"><div><div class="token cpp_argument">_Left</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Fty'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;&amp; <div class="def" id="NI$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Right"><div><div class="token cpp_argument">_Right</div></div></div>) <div class="token cpp_keyword ">noexcept</div>
	{	<div class="token cpp_comment ">// swap contents of _Left with contents of _Right</div>
	<div class="ref" onclick="jumpToSymbol([], ['std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Left'], [], [])"><div class="token cpp_argument">_Left</div></div>.<div class="ref" onclick="jumpToSymbol(['std::function::swap@void(::std::function &)'], ['std::function::swap@void(::std::function &)'], [], [])"><div class="token cpp_function">swap</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Right'], [], [])"><div class="token cpp_argument">_Right</div></div>);
	}

	<div class="token cpp_comment ">// TEMPLATE NULL POINTER COMPARISONS</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty"><div><div class="token cpp_type">_Fty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline bool operator==(const function&lt;_Fty&gt;&amp; _Other, nullptr_t) noexcept</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">=</div><div class="token cpp_function">=</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;&amp; <div class="def" id="NI$std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other"><div><div class="token cpp_argument">_Other</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::nullptr_t'], [], [])"><div class="token cpp_type">nullptr_t</div></div>) <div class="token cpp_keyword ">noexcept</div></div></div>
	{	<div class="token cpp_comment ">// compare to null pointer</div>
	<div class="token cpp_keyword ">return</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other'], [], [])"><div class="token cpp_argument">_Other</div></div>);
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty"><div><div class="token cpp_type">_Fty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline bool operator==(nullptr_t, const function&lt;_Fty&gt;&amp; _Other) noexcept</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">=</div><div class="token cpp_function">=</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::nullptr_t'], [], [])"><div class="token cpp_type">nullptr_t</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;&amp; <div class="def" id="NI$std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other"><div><div class="token cpp_argument">_Other</div></div></div>) <div class="token cpp_keyword ">noexcept</div></div></div>
	{	<div class="token cpp_comment ">// compare to null pointer</div>
	<div class="token cpp_keyword ">return</div> (!<div class="ref" onclick="jumpToSymbol([], ['std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other'], [], [])"><div class="token cpp_argument">_Other</div></div>);
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty"><div><div class="token cpp_type">_Fty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline bool operator!=(const function&lt;_Fty&gt;&amp; _Other, nullptr_t) noexcept</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">!</div><div class="token cpp_function">=</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;&amp; <div class="def" id="NI$std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other"><div><div class="token cpp_argument">_Other</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::nullptr_t'], [], [])"><div class="token cpp_type">nullptr_t</div></div>) <div class="token cpp_keyword ">noexcept</div></div></div>
	{	<div class="token cpp_comment ">// compare to null pointer</div>
	<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="token cpp_keyword ">bool</div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other'], [], [])"><div class="token cpp_argument">_Other</div></div>));
	}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty"><div><div class="token cpp_type">_Fty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline bool operator!=(nullptr_t, const function&lt;_Fty&gt;&amp; _Other) noexcept</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="FB$std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">!</div><div class="token cpp_function">=</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::nullptr_t'], [], [])"><div class="token cpp_type">nullptr_t</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;&amp; <div class="def" id="NI$std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other"><div><div class="token cpp_argument">_Other</div></div></div>) <div class="token cpp_keyword ">noexcept</div></div></div>
	{	<div class="token cpp_comment ">// compare to null pointer</div>
	<div class="token cpp_keyword ">return</div> (<div class="token cpp_keyword ">static_cast</div>&lt;<div class="token cpp_keyword ">bool</div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other'], [], [])"><div class="token cpp_argument">_Other</div></div>));
	}

	<div class="token cpp_comment ">// PLACEHOLDERS</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">int</div> <div class="def" id="TA$std::_Ph::_Nx"><div><div class="token cpp_enum">_Nx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Ph"><div><div class="token cpp_type">_Ph</div></div></div>
	{	<div class="token cpp_comment ">// placeholder</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_placeholder::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_placeholder"><div class="ref" onclick="jumpToSymbol([], [], ['std::is_placeholder@<::std::_Ph<*>>', 'std::is_placeholder@<[_Tx] const>', 'std::is_placeholder@<[_Tx] volatile>', 'std::is_placeholder@<[_Tx] const volatile>'], [])"><div class="token cpp_type">is_placeholder</div></div></div>
		: <div class="ref" onclick="jumpToSymbol([], ['std::integral_constant'], [], [])"><div class="token cpp_type">integral_constant</div></div>&lt;<div class="token cpp_keyword ">int</div>, <div class="token cpp_number ">0</div>&gt;
	{	<div class="token cpp_comment ">// template to indicate that _Tx is not a placeholder</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">int</div> <div class="def" id="TA$std::is_placeholder@<::std::_Ph<*>>::_Nx"><div><div class="token cpp_enum">_Nx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_placeholder@<::std::_Ph<*>>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::is_placeholder'])"><div class="token cpp_type">is_placeholder</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder@<::std::_Ph<*>>::_Nx'], [], [])"><div class="token cpp_enum">_Nx</div></div>&gt;&gt;
		: <div class="ref" onclick="jumpToSymbol([], ['std::integral_constant'], [], [])"><div class="token cpp_type">integral_constant</div></div>&lt;<div class="token cpp_keyword ">int</div>, <div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder@<::std::_Ph<*>>::_Nx'], [], [])"><div class="token cpp_enum">_Nx</div></div>&gt;
	{	<div class="token cpp_comment ">// template specialization to indicate that _Ph&lt;_Nx&gt; is a placeholder</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_placeholder@<[_Tx] const>::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_placeholder@<[_Tx] const>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::is_placeholder'])"><div class="token cpp_type">is_placeholder</div></div></div>&lt;<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder@<[_Tx] const>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;
		: <div class="ref" onclick="jumpToSymbol(['std::is_placeholder', 'std::is_placeholder@<::std::_Ph<*>>', 'std::is_placeholder@<[_Tx] const volatile>', 'std::is_placeholder@<[_Tx] const>', 'std::is_placeholder@<[_Tx] volatile>'], ['std::is_placeholder@<[_Tx] const>'], [], [])"><div class="token cpp_type">is_placeholder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder@<[_Tx] const>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::integral_constant::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// ignore cv-qualifiers</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_placeholder@<[_Tx] volatile>::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_placeholder@<[_Tx] volatile>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::is_placeholder'])"><div class="token cpp_type">is_placeholder</div></div></div>&lt;<div class="token cpp_keyword ">volatile</div> <div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder@<[_Tx] volatile>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;
		: <div class="ref" onclick="jumpToSymbol(['std::is_placeholder', 'std::is_placeholder@<::std::_Ph<*>>', 'std::is_placeholder@<[_Tx] const volatile>', 'std::is_placeholder@<[_Tx] const>', 'std::is_placeholder@<[_Tx] volatile>'], ['std::is_placeholder@<[_Tx] volatile>'], [], [])"><div class="token cpp_type">is_placeholder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder@<[_Tx] volatile>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::integral_constant::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// ignore cv-qualifiers</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_placeholder@<[_Tx] const volatile>::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_placeholder@<[_Tx] const volatile>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::is_placeholder'])"><div class="token cpp_type">is_placeholder</div></div></div>&lt;<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">volatile</div> <div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder@<[_Tx] const volatile>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;
		: <div class="ref" onclick="jumpToSymbol(['std::is_placeholder', 'std::is_placeholder@<::std::_Ph<*>>', 'std::is_placeholder@<[_Tx] const volatile>', 'std::is_placeholder@<[_Tx] const>', 'std::is_placeholder@<[_Tx] volatile>'], ['std::is_placeholder@<[_Tx] const volatile>'], [], [])"><div class="token cpp_type">is_placeholder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder@<[_Tx] const volatile>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::integral_constant::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// ignore cv-qualifiers</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_placeholder_v::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_INLINE_VAR constexpr int is_placeholder_v = is_placeholder&lt;_Ty&gt;::value;</div>
<div class="expanded">	 <div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">int</div> <div class="def" id="NI$std::is_placeholder_v"><div><div class="token cpp_enum">is_placeholder_v</div></div></div> = <div class="ref" onclick="jumpToSymbol(['std::is_placeholder', 'std::is_placeholder@<::std::_Ph<*>>', 'std::is_placeholder@<[_Tx] const volatile>', 'std::is_placeholder@<[_Tx] const>', 'std::is_placeholder@<[_Tx] volatile>'], ['std::is_placeholder'], [], [])"><div class="token cpp_type">is_placeholder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder_v::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::integral_constant::value'], [], [])"><div class="token cpp_field">value</div></div>;</div></div>

	<div class="token cpp_comment ">// CLASS TEMPLATE _Binder FORWARD DECLARATION</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Binder::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Binder::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Binder::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NF[0]$std::_Binder"><div class="ref" onclick="jumpToSymbol([], ['std::_Binder'], [], [])"><div class="token cpp_type">_Binder</div></div></div>;

	<div class="token cpp_comment ">// STRUCT TEMPLATE is_bind_expression</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_bind_expression::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_bind_expression"><div class="ref" onclick="jumpToSymbol([], [], ['std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>', 'std::is_bind_expression@<[_Tx] const>', 'std::is_bind_expression@<[_Tx] volatile>', 'std::is_bind_expression@<[_Tx] const volatile>'], [])"><div class="token cpp_type">is_bind_expression</div></div></div>
		: <div class="ref" onclick="jumpToSymbol([], ['std::false_type'], [], [])"><div class="token cpp_type">false_type</div></div>
	{	<div class="token cpp_comment ">// template to indicate that _Tx is not a bind expression</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::is_bind_expression'])"><div class="token cpp_type">is_bind_expression</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder'], [], [])"><div class="token cpp_type">_Binder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;&gt;
		: <div class="ref" onclick="jumpToSymbol([], ['std::true_type'], [], [])"><div class="token cpp_type">true_type</div></div>
	{	<div class="token cpp_comment ">// template specialization to indicate a bind expression</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_bind_expression@<[_Tx] const>::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_bind_expression@<[_Tx] const>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::is_bind_expression'])"><div class="token cpp_type">is_bind_expression</div></div></div>&lt;<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<[_Tx] const>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;
		: <div class="ref" onclick="jumpToSymbol(['std::is_bind_expression', 'std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>', 'std::is_bind_expression@<[_Tx] const volatile>', 'std::is_bind_expression@<[_Tx] const>', 'std::is_bind_expression@<[_Tx] volatile>'], ['std::is_bind_expression@<[_Tx] const>'], [], [])"><div class="token cpp_type">is_bind_expression</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<[_Tx] const>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::integral_constant::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// ignore cv-qualifiers</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_bind_expression@<[_Tx] volatile>::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_bind_expression@<[_Tx] volatile>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::is_bind_expression'])"><div class="token cpp_type">is_bind_expression</div></div></div>&lt;<div class="token cpp_keyword ">volatile</div> <div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<[_Tx] volatile>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;
		: <div class="ref" onclick="jumpToSymbol(['std::is_bind_expression', 'std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>', 'std::is_bind_expression@<[_Tx] const volatile>', 'std::is_bind_expression@<[_Tx] const>', 'std::is_bind_expression@<[_Tx] volatile>'], ['std::is_bind_expression@<[_Tx] volatile>'], [], [])"><div class="token cpp_type">is_bind_expression</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<[_Tx] volatile>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::integral_constant::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// ignore cv-qualifiers</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_bind_expression@<[_Tx] const volatile>::_Tx"><div><div class="token cpp_type">_Tx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::is_bind_expression@<[_Tx] const volatile>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::is_bind_expression'])"><div class="token cpp_type">is_bind_expression</div></div></div>&lt;<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">volatile</div> <div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<[_Tx] const volatile>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;
		: <div class="ref" onclick="jumpToSymbol(['std::is_bind_expression', 'std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>', 'std::is_bind_expression@<[_Tx] const volatile>', 'std::is_bind_expression@<[_Tx] const>', 'std::is_bind_expression@<[_Tx] volatile>'], ['std::is_bind_expression@<[_Tx] const volatile>'], [], [])"><div class="token cpp_type">is_bind_expression</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression@<[_Tx] const volatile>::_Tx'], [], [])"><div class="token cpp_type">_Tx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::integral_constant::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// ignore cv-qualifiers</div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::is_bind_expression_v::_Ty"><div><div class="token cpp_type">_Ty</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_INLINE_VAR constexpr bool is_bind_expression_v = is_bind_expression&lt;_Ty&gt;::value;</div>
<div class="expanded">	 <div class="token cpp_keyword ">constexpr</div> <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$std::is_bind_expression_v"><div><div class="token cpp_enum">is_bind_expression_v</div></div></div> = <div class="ref" onclick="jumpToSymbol(['std::is_bind_expression', 'std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>', 'std::is_bind_expression@<[_Tx] const volatile>', 'std::is_bind_expression@<[_Tx] const>', 'std::is_bind_expression@<[_Tx] volatile>'], ['std::is_bind_expression'], [], [])"><div class="token cpp_type">is_bind_expression</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression_v::_Ty'], [], [])"><div class="token cpp_type">_Ty</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::integral_constant::value'], [], [])"><div class="token cpp_field">value</div></div>;</div></div>

	<div class="token cpp_comment ">// FUNCTION TEMPLATE _Fix_arg</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer::_Cv_TiD"><div><div class="token cpp_type">_Cv_TiD</div></div></div>,
	<div class="token cpp_keyword ">bool</div> = <div class="ref" onclick="jumpToSymbol([], ['std::_Is_specialization_v'], [], [])"><div class="token cpp_enum">_Is_specialization_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::remove_cv_t'], [], [])"><div class="token cpp_type">remove_cv_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&gt;, <div class="ref" onclick="jumpToSymbol([], ['std::reference_wrapper'], [], [])"><div class="token cpp_type">reference_wrapper</div></div>&gt;,
	<div class="token cpp_keyword ">bool</div> = <div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression_v'], [], [])"><div class="token cpp_enum">is_bind_expression_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&gt;,
	<div class="token cpp_keyword ">int</div> = <div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder_v'], [], [])"><div class="token cpp_enum">is_placeholder_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&gt;&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$std::_Select_fixer"><div class="ref" onclick="jumpToSymbol([], [], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>2', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>3', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>4'], [])"><div class="token cpp_type">_Select_fixer</div></div></div>;

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Cv_TiD"><div><div class="token cpp_type">_Cv_TiD</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::_Select_fixer'])"><div class="token cpp_type">_Select_fixer</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>, <div class="token cpp_keyword ">true</div>, <div class="token cpp_keyword ">false</div>, <div class="token cpp_number ">0</div>&gt;
	{	<div class="token cpp_comment ">// reference_wrapper fixer</div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple"><div><div class="token cpp_type">_Untuple</div></div></div>&gt;
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]"><div><div class="token cpp_function">_Fix</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&amp; <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid"><div><div class="token cpp_argument">_Tid</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&amp;&amp;)
		-&gt; <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>::type&amp;
		{	<div class="token cpp_comment ">// unwrap a reference_wrapper</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'], [], [])"><div class="token cpp_argument">_Tid</div></div>.get());
		}
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Cv_TiD"><div><div class="token cpp_type">_Cv_TiD</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::_Select_fixer'])"><div class="token cpp_type">_Select_fixer</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>, <div class="token cpp_keyword ">false</div>, <div class="token cpp_keyword ">true</div>, <div class="token cpp_number ">0</div>&gt;
	{	<div class="token cpp_comment ">// nested bind fixer</div>
#pragma warning(push)
<div class="expandable"><div class="disabled">#pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter</div>
<div class="expanded">#pragma warning(disable: <div class="token cpp_number ">4100</div>)	</div></div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Untuple"><div><div class="token cpp_type">_Untuple</div></div></div>,
		<div class="ref" onclick="jumpToSymbol([], ['size_t'], [], [])"><div class="token cpp_type">size_t</div></div>... <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Jx"><div><div class="token cpp_enum">_Jx</div></div></div>&gt;
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]"><div><div class="token cpp_function">_Apply</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&amp; <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Tid"><div><div class="token cpp_argument">_Tid</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&amp;&amp; <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Ut"><div><div class="token cpp_argument">_Ut</div></div></div>,
			<div class="ref" onclick="jumpToSymbol([], ['std::index_sequence'], [], [])"><div class="token cpp_type">index_sequence</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Jx'], [], [])"><div class="token cpp_enum">_Jx</div></div>...&gt;)
<div class="expandable"><div class="disabled">		-&gt; decltype(_Tid(_STD get&lt;_Jx&gt;(_STD move(_Ut))...))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Tid'], [], [])"><div class="token cpp_argument">_Tid</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)', 'std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)', 'std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)', 'std::get@[_Ty] &(::std::array<[_Ty], *> &)', 'std::get@[_Ty] &(::std::tuple<[_Types]...> &)', 'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)', 'std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)', 'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)', 'std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)'], [], [])"><div class="token cpp_function">get</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Jx'], [], [])"><div class="token cpp_enum">_Jx</div></div>&gt;(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>))...))</div></div>
		{	<div class="token cpp_comment ">// call a nested bind expression</div>
<div class="expandable"><div class="disabled">		return (_Tid(_STD get&lt;_Jx&gt;(_STD move(_Ut))...));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Tid'], [], [])"><div class="token cpp_argument">_Tid</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)', 'std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)', 'std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)', 'std::get@[_Ty] &(::std::array<[_Ty], *> &)', 'std::get@[_Ty] &(::std::tuple<[_Types]...> &)', 'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)', 'std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)', 'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)', 'std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)'], [], [])"><div class="token cpp_function">get</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Jx'], [], [])"><div class="token cpp_enum">_Jx</div></div>&gt;(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>))...));</div></div>
		}
#pragma warning(pop)

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple"><div><div class="token cpp_type">_Untuple</div></div></div>&gt;
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]"><div><div class="token cpp_function">_Fix</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&amp; <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid"><div><div class="token cpp_argument">_Tid</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&amp;&amp; <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut"><div><div class="token cpp_argument">_Ut</div></div></div>)
<div class="expandable"><div class="disabled">		-&gt; decltype(_Apply(_Tid, _STD move(_Ut),</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)'], [], [])"><div class="token cpp_function">_Apply</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'], [], [])"><div class="token cpp_argument">_Tid</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>),</div></div>
			<div class="ref" onclick="jumpToSymbol([], ['std::make_index_sequence'], [], [])"><div class="token cpp_type">make_index_sequence</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::tuple_size_v'], [], [])"><div class="token cpp_enum">tuple_size_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&gt;&gt;()))
		{	<div class="token cpp_comment ">// call a nested bind expression</div>
<div class="expandable"><div class="disabled">		return (_Apply(_Tid, _STD move(_Ut),</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)'], [], [])"><div class="token cpp_function">_Apply</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'], [], [])"><div class="token cpp_argument">_Tid</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>),</div></div>
			<div class="ref" onclick="jumpToSymbol([], ['std::make_index_sequence'], [], [])"><div class="token cpp_type">make_index_sequence</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::tuple_size_v'], [], [])"><div class="token cpp_enum">tuple_size_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&gt;&gt;()));
		}
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Cv_TiD"><div><div class="token cpp_type">_Cv_TiD</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>3"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::_Select_fixer'])"><div class="token cpp_type">_Select_fixer</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>, <div class="token cpp_keyword ">false</div>, <div class="token cpp_keyword ">false</div>, <div class="token cpp_number ">0</div>&gt;
	{	<div class="token cpp_comment ">// identity fixer</div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple"><div><div class="token cpp_type">_Untuple</div></div></div>&gt;
		<div class="token cpp_keyword ">static</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&amp; <div class="def" id="FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]"><div><div class="token cpp_function">_Fix</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&amp; <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid"><div><div class="token cpp_argument">_Tid</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&amp;&amp;)
		{	<div class="token cpp_comment ">// pass a bound argument as an lvalue (important!)</div>
		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'], [], [])"><div class="token cpp_argument">_Tid</div></div>);
		}
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Cv_TiD"><div><div class="token cpp_type">_Cv_TiD</div></div></div>,
	<div class="token cpp_keyword ">int</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Jx"><div><div class="token cpp_enum">_Jx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>4"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::_Select_fixer'])"><div class="token cpp_type">_Select_fixer</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>, <div class="token cpp_keyword ">false</div>, <div class="token cpp_keyword ">false</div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Jx'], [], [])"><div class="token cpp_enum">_Jx</div></div>&gt;
	{	<div class="token cpp_comment ">// placeholder fixer</div>
	<div class="token cpp_keyword ">static_assert</div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Jx'], [], [])"><div class="token cpp_enum">_Jx</div></div> &gt; <div class="token cpp_number ">0</div>, <div class="token cpp_string ">&quot;invalid is_placeholder value&quot;</div>);

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple"><div><div class="token cpp_type">_Untuple</div></div></div>&gt;
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]"><div><div class="token cpp_function">_Fix</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&amp;, <div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&amp;&amp; <div class="def" id="NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut"><div><div class="token cpp_argument">_Ut</div></div></div>)
<div class="expandable"><div class="disabled">		-&gt; decltype(_STD get&lt;_Jx - 1&gt;(_STD move(_Ut)))</div>
<div class="expanded">		-&gt; <div class="token cpp_keyword ">decltype</div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)', 'std::get@[_Ty] &(::std::array<[_Ty], *> &)', 'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)', 'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)'], ['std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)', 'std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)', 'std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)', 'std::get@[_Ty] &(::std::array<[_Ty], *> &)', 'std::get@[_Ty] &(::std::tuple<[_Types]...> &)', 'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)', 'std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)', 'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)', 'std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)'], [], [])"><div class="token cpp_function">get</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Jx'], [], [])"><div class="token cpp_enum">_Jx</div></div> - <div class="token cpp_number ">1</div>&gt;(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>)))</div></div>
		{	<div class="token cpp_comment ">// choose the Jth unbound argument (1-based indexing)</div>
<div class="expandable"><div class="disabled">		return (_STD get&lt;_Jx - 1&gt;(_STD move(_Ut)));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)', 'std::get@[_Ty] &(::std::array<[_Ty], *> &)', 'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)', 'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)'], ['std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)', 'std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)', 'std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)', 'std::get@[_Ty] &(::std::array<[_Ty], *> &)', 'std::get@[_Ty] &(::std::tuple<[_Types]...> &)', 'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)', 'std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)', 'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)', 'std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)'], [], [])"><div class="token cpp_function">get</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Jx'], [], [])"><div class="token cpp_enum">_Jx</div></div> - <div class="token cpp_number ">1</div>&gt;(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>)));</div></div>
		}
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Cv_TiD"><div><div class="token cpp_type">_Cv_TiD</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple"><div><div class="token cpp_type">_Untuple</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]"><div><div class="token cpp_function">_Fix_arg</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&amp; <div class="def" id="NI$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid"><div><div class="token cpp_argument">_Tid</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&amp;&amp; <div class="def" id="NI$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut"><div><div class="token cpp_argument">_Ut</div></div></div>)
<div class="expandable"><div class="disabled">	-&gt; decltype(_Select_fixer&lt;_Cv_TiD&gt;::_Fix(_Tid, _STD move(_Ut)))</div>
<div class="expanded">	-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="ref" onclick="jumpToSymbol(['std::_Select_fixer', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>2', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>3', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>4'], ['std::_Select_fixer'], [], [])"><div class="token cpp_type">_Select_fixer</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&gt;::<div class="ref" onclick="jumpToSymbol(['std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)'], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)'], [], [])"><div class="token cpp_function">_Fix</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'], [], [])"><div class="token cpp_argument">_Tid</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>)))</div></div>
	{	<div class="token cpp_comment ">// translate an argument for bind</div>
<div class="expandable"><div class="disabled">	return (_Select_fixer&lt;_Cv_TiD&gt;::_Fix(_Tid, _STD move(_Ut)));</div>
<div class="expanded">	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Select_fixer', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>2', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>3', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>4'], ['std::_Select_fixer'], [], [])"><div class="token cpp_type">_Select_fixer</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Cv_TiD'], [], [])"><div class="token cpp_type">_Cv_TiD</div></div>&gt;::<div class="ref" onclick="jumpToSymbol(['std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)'], ['std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)', 'std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)'], [], [])"><div class="token cpp_function">_Fix</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'], [], [])"><div class="token cpp_argument">_Tid</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>)));</div></div>
	}

#pragma warning(push)
<div class="expandable"><div class="disabled">#pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter</div>
<div class="expanded">#pragma warning(disable: <div class="token cpp_number ">4100</div>)	</div></div>
	<div class="token cpp_comment ">// FUNCTION TEMPLATE _Call_binder</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>,
	<div class="ref" onclick="jumpToSymbol([], ['size_t'], [], [])"><div class="token cpp_type">size_t</div></div>... <div class="def" id="TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ix"><div><div class="token cpp_enum">_Ix</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_FD"><div><div class="token cpp_type">_Cv_FD</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_tuple_TiD"><div><div class="token cpp_type">_Cv_tuple_TiD</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Untuple"><div><div class="token cpp_type">_Untuple</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]"><div><div class="token cpp_function">_Call_binder</div></div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>&gt;, <div class="ref" onclick="jumpToSymbol([], ['std::index_sequence'], [], [])"><div class="token cpp_type">index_sequence</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ix'], [], [])"><div class="token cpp_enum">_Ix</div></div>...&gt;,
		<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_FD'], [], [])"><div class="token cpp_type">_Cv_FD</div></div>&amp; <div class="def" id="NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Obj"><div><div class="token cpp_argument">_Obj</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_tuple_TiD'], [], [])"><div class="token cpp_type">_Cv_tuple_TiD</div></div>&amp; <div class="def" id="NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Tpl"><div><div class="token cpp_argument">_Tpl</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Untuple'], [], [])"><div class="token cpp_type">_Untuple</div></div>&amp;&amp; <div class="def" id="NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ut"><div><div class="token cpp_argument">_Ut</div></div></div>)
<div class="expandable"><div class="disabled">	-&gt; decltype(_Invoker_ret&lt;_Ret&gt;::_Call(_Obj, _Fix_arg(_STD get&lt;_Ix&gt;(_Tpl), _STD move(_Ut))...))</div>
<div class="expanded">	-&gt; <div class="token cpp_keyword ">decltype</div>(<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>&gt;::<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)', 'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)'], ['std::_Invoker_ret@<::std::_Unforced, *>::_Call@decltype(*)([_Valtys] &&...)', 'std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)', 'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)'], [], [])"><div class="token cpp_function">_Call</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Obj'], [], [])"><div class="token cpp_argument">_Obj</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)'], [], [])"><div class="token cpp_function">_Fix_arg</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)', 'std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)', 'std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)', 'std::get@[_Ty] &(::std::array<[_Ty], *> &)', 'std::get@[_Ty] &(::std::tuple<[_Types]...> &)', 'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)', 'std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)', 'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)', 'std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)'], [], [])"><div class="token cpp_function">get</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ix'], [], [])"><div class="token cpp_enum">_Ix</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Tpl'], [], [])"><div class="token cpp_argument">_Tpl</div></div>), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>))...))</div></div>
	{	<div class="token cpp_comment ">// bind() and bind&lt;R&gt;() invocation</div>
<div class="expandable"><div class="disabled">	return (_Invoker_ret&lt;_Ret&gt;::_Call(_Obj, _Fix_arg(_STD get&lt;_Ix&gt;(_Tpl), _STD move(_Ut))...));</div>
<div class="expanded">	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>&gt;::<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)', 'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)'], ['std::_Invoker_ret@<::std::_Unforced, *>::_Call@decltype(*)([_Valtys] &&...)', 'std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)', 'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)'], [], [])"><div class="token cpp_function">_Call</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Obj'], [], [])"><div class="token cpp_argument">_Obj</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)'], [], [])"><div class="token cpp_function">_Fix_arg</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)', 'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)', 'std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)', 'std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)', 'std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)', 'std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)', 'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)', 'std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)', 'std::get@[_Ty] &(::std::array<[_Ty], *> &)', 'std::get@[_Ty] &(::std::tuple<[_Types]...> &)', 'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)', 'std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)', 'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)', 'std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)'], [], [])"><div class="token cpp_function">get</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ix'], [], [])"><div class="token cpp_enum">_Ix</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Tpl'], [], [])"><div class="token cpp_argument">_Tpl</div></div>), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)'], ['std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)', 'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])'], [], [])"><div class="token cpp_function">move</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ut'], [], [])"><div class="token cpp_argument">_Ut</div></div>))...));</div></div>
	}
#pragma warning(pop)

	<div class="token cpp_comment ">// CLASS TEMPLATE _Binder</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Forced_result_type::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Forced_result_type"><div><div class="token cpp_type">_Forced_result_type</div></div></div>
	{	<div class="token cpp_comment ">// used by bind&lt;R&gt;()</div>
<div class="expandable"><div class="disabled">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type;</div>
<div class="expanded">	 <div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Forced_result_type::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div> <div class="def" id="NI$std::_Forced_result_type::result_type"><div><div class="token cpp_type">result_type</div></div></div>;</div></div>
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Binder_result_type::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Binder_result_type::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::_Binder_result_type"><div><div class="token cpp_type">_Binder_result_type</div></div></div>
	{	<div class="token cpp_comment ">// provide result_type (sometimes)</div>
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::decay_t'], [], [])"><div class="token cpp_type">decay_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder_result_type::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt; <div class="def" id="NI$std::_Binder_result_type::_Decayed"><div><div class="token cpp_type">_Decayed</div></div></div>;

	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">typename</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Weak_types'], [], [])"><div class="token cpp_type">_Weak_types</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder_result_type::_Decayed'], [], [])"><div class="token cpp_type">_Decayed</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::_Weak_types::type'], [], [])"><div class="token cpp_type">type</div></div> <div class="def" id="NI$std::_Binder_result_type::_All_weak_types"><div><div class="token cpp_type">_All_weak_types</div></div></div>;

	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::conditional_t'], [], [])"><div class="token cpp_type">conditional_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::is_same_v'], [], [])"><div class="token cpp_enum">is_same_v</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder_result_type::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Unforced'], [], [])"><div class="token cpp_type">_Unforced</div></div>&gt;,
		<div class="ref" onclick="jumpToSymbol(['std::_Weak_result_type@<[_Ty], ::std::void_t<result_type>>'], ['std::_Weak_result_type'], [], [])"><div class="token cpp_type">_Weak_result_type</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder_result_type::_All_weak_types'], [], [])"><div class="token cpp_type">_All_weak_types</div></div>&gt;,
		<div class="ref" onclick="jumpToSymbol([], ['std::_Forced_result_type'], [], [])"><div class="token cpp_type">_Forced_result_type</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder_result_type::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>&gt;&gt; <div class="def" id="NI$std::_Binder_result_type::type"><div><div class="token cpp_type">type</div></div></div>;
	};

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Binder::_Ret2"><div><div class="token cpp_type">_Ret</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Binder::_Fx2"><div><div class="token cpp_type">_Fx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Binder::_Types2"><div><div class="token cpp_type">_Types</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$std::_Binder"><div class="ref" onclick="jumpToSymbol([], ['std::_Binder'], [], [])"><div class="token cpp_type">_Binder</div></div></div>
		: <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Binder_result_type'], [], [])"><div class="token cpp_type">_Binder_result_type</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Ret2'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Fx2'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol([], ['std::_Binder_result_type::type'], [], [])"><div class="token cpp_type">type</div></div>
	{	<div class="token cpp_comment ">// wrap bound callable object and arguments</div>
<div class="token cpp_keyword ">private</div>:
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::index_sequence_for'], [], [])"><div class="token cpp_type">index_sequence_for</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Types2'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="NI$std::_Binder::_Seq"><div><div class="token cpp_type">_Seq</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol([], ['std::decay_t'], [], [])"><div class="token cpp_type">decay_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Fx2'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt; <div class="def" id="NI$std::_Binder::_First"><div><div class="token cpp_type">_First</div></div></div>;
	<div class="token cpp_keyword ">typedef</div> <div class="ref" onclick="jumpToSymbol(['std::tuple', 'std::tuple@<>', 'std::tuple@<[_This], [_Rest]...>'], ['std::tuple'], [], [])"><div class="token cpp_type">tuple</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::decay_t'], [], [])"><div class="token cpp_type">decay_t</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Types2'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;...&gt; <div class="def" id="NI$std::_Binder::_Second"><div><div class="token cpp_type">_Second</div></div></div>;

	<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>'], ['std::_Compressed_pair'], [], [])"><div class="token cpp_type">_Compressed_pair</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_First'], [], [])"><div class="token cpp_type">_First</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Second'], [], [])"><div class="token cpp_type">_Second</div></div>&gt; <div class="def" id="NI$std::_Binder::_Mypair"><div><div class="token cpp_field">_Mypair</div></div></div>;

<div class="token cpp_keyword ">public</div>:
	<div class="token cpp_keyword ">explicit</div> <div class="def" id="FB$std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]"><div><div class="token cpp_function">_Binder</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Fx2'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Types2'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;... <div class="def" id="NI$std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Args"><div><div class="token cpp_argument">_Args</div></div></div>)
		: _Mypair(<div class="ref" onclick="jumpToSymbol([], ['std::_One_then_variadic_args_t'], [], [])"><div class="token cpp_type">_One_then_variadic_args_t</div></div>(),
<div class="expandable"><div class="disabled">			_STD forward&lt;_Fx&gt;(_Func), _STD forward&lt;_Types&gt;(_Args)...)</div>
<div class="expanded">			::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Fx2'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Types2'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...)</div></div>
		{	<div class="token cpp_comment ">// construct from forwarded callable object and arguments</div>
		}

<div class="disabled">#define _BINDER_OPERATOR(CONST_OPT) \</div>
<div class="disabled">	template&lt;class... _Unbound&gt; \</div>
<div class="disabled">		auto operator()(_Unbound&amp;&amp;... _Unbargs) CONST_OPT \</div>
<div class="disabled">		-&gt; decltype(_Call_binder(_Invoker_ret&lt;_Ret&gt;(), _Seq(), \</div>
<div class="disabled">			_Mypair._Get_first(), _Mypair._Get_second(), \</div>
<div class="disabled">			_STD forward_as_tuple(_STD forward&lt;_Unbound&gt;(_Unbargs)...))) \</div>
<div class="disabled">		{	/* invoke bound callable object with bound/unbound arguments */ \</div>
<div class="disabled">		return (_Call_binder(_Invoker_ret&lt;_Ret&gt;(), _Seq(), \</div>
<div class="disabled">			_Mypair._Get_first(), _Mypair._Get_second(), \</div>
<div class="disabled">			_STD forward_as_tuple(_STD forward&lt;_Unbound&gt;(_Unbargs)...))); \</div>
<div class="disabled">		}</div>

<div class="expandable"><div class="disabled">_CLASS_DEFINE_CONST(_BINDER_OPERATOR)</div>
<div class="expanded"><div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbound"><div><div class="token cpp_type">_Unbound</div></div></div>&gt; <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbound'], [], [])"><div class="token cpp_type">_Unbound</div></div>&amp;&amp;... <div class="def" id="NI$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbargs"><div><div class="token cpp_argument">_Unbargs</div></div></div>)  -&gt; <div class="token cpp_keyword ">decltype</div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)'], [], [])"><div class="token cpp_function">_Call_binder</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Ret2'], [], [])"><div class="token cpp_type">_Ret</div></div>&gt;(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Seq'], [], [])"><div class="token cpp_type">_Seq</div></div>(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()'], ['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], [], [])"><div class="token cpp_function">_Get_first</div></div>(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()'], ['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], [], [])"><div class="token cpp_function">_Get_second</div></div>(), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)'], ['std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)'], [], [])"><div class="token cpp_function">forward_as_tuple</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbound'], [], [])"><div class="token cpp_type">_Unbound</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbargs'], [], [])"><div class="token cpp_argument">_Unbargs</div></div>)...))) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)'], [], [])"><div class="token cpp_function">_Call_binder</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Ret2'], [], [])"><div class="token cpp_type">_Ret</div></div>&gt;(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Seq'], [], [])"><div class="token cpp_type">_Seq</div></div>(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()'], ['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], [], [])"><div class="token cpp_function">_Get_first</div></div>(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()'], ['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], [], [])"><div class="token cpp_function">_Get_second</div></div>(), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)'], ['std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)'], [], [])"><div class="token cpp_function">forward_as_tuple</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbound'], [], [])"><div class="token cpp_type">_Unbound</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbargs'], [], [])"><div class="token cpp_argument">_Unbargs</div></div>)...))); } <div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbound"><div><div class="token cpp_type">_Unbound</div></div></div>&gt; <div class="token cpp_keyword ">auto</div> <div class="def" id="FB$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]"><div><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbound'], [], [])"><div class="token cpp_type">_Unbound</div></div>&amp;&amp;... <div class="def" id="NI$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbargs"><div><div class="token cpp_argument">_Unbargs</div></div></div>) <div class="token cpp_keyword ">const</div> -&gt; <div class="token cpp_keyword ">decltype</div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)'], [], [])"><div class="token cpp_function">_Call_binder</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Ret2'], [], [])"><div class="token cpp_type">_Ret</div></div>&gt;(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Seq'], [], [])"><div class="token cpp_type">_Seq</div></div>(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], ['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], [], [])"><div class="token cpp_function">_Get_first</div></div>(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], ['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], [], [])"><div class="token cpp_function">_Get_second</div></div>(), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)'], ['std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)'], [], [])"><div class="token cpp_function">forward_as_tuple</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbound'], [], [])"><div class="token cpp_type">_Unbound</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbargs'], [], [])"><div class="token cpp_argument">_Unbargs</div></div>)...))) { <div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)'], [], [])"><div class="token cpp_function">_Call_binder</div></div>(<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Ret2'], [], [])"><div class="token cpp_type">_Ret</div></div>&gt;(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Seq'], [], [])"><div class="token cpp_type">_Seq</div></div>(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], ['std::_Compressed_pair::_Get_first@[_Ty1] &()', 'std::_Compressed_pair::_Get_first@[_Ty1] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()'], [], [])"><div class="token cpp_function">_Get_first</div></div>(), <div class="ref" onclick="jumpToSymbol([], ['std::_Binder::_Mypair'], [], [])"><div class="token cpp_field">_Mypair</div></div>.<div class="ref" onclick="jumpToSymbol(['std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], ['std::_Compressed_pair::_Get_second@[_Ty2] &()', 'std::_Compressed_pair::_Get_second@[_Ty2] const &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()', 'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()'], [], [])"><div class="token cpp_function">_Get_second</div></div>(), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)'], ['std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)'], [], [])"><div class="token cpp_function">forward_as_tuple</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbound'], [], [])"><div class="token cpp_type">_Unbound</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbargs'], [], [])"><div class="token cpp_argument">_Unbargs</div></div>)...))); }</div></div>
<div class="disabled">#undef _BINDER_OPERATOR</div>
	};

	<div class="token cpp_comment ">// FUNCTION TEMPLATE bind (implicit return type)</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD inline _Binder&lt;_Unforced, _Fx, _Types...&gt; bind(_Fx&amp;&amp; _Func, _Types&amp;&amp;... _Args)</div>
<div class="expanded">	 <div class="token cpp_keyword ">inline</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Binder'], [], [])"><div class="token cpp_type">_Binder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Unforced'], [], [])"><div class="token cpp_type">_Unforced</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="FB$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]"><div><div class="token cpp_function">bind</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;... <div class="def" id="NI$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args"><div><div class="token cpp_argument">_Args</div></div></div>)</div></div>
	{	<div class="token cpp_comment ">// bind a callable object with an implicit return type</div>
<div class="expandable"><div class="disabled">	return (_Binder&lt;_Unforced, _Fx, _Types...&gt;(_STD forward&lt;_Fx&gt;(_Func), _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="expanded">	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Binder'], [], [])"><div class="token cpp_type">_Binder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Unforced'], [], [])"><div class="token cpp_type">_Unforced</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...));</div></div>
	}

	<div class="token cpp_comment ">// FUNCTION TEMPLATE bind (explicit return type)</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx"><div><div class="token cpp_type">_Fx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt;
<div class="expandable"><div class="disabled">	_NODISCARD _Binder&lt;_Ret, _Fx, _Types...&gt; bind(_Fx&amp;&amp; _Func, _Types&amp;&amp;... _Args)</div>
<div class="expanded">	 <div class="ref" onclick="jumpToSymbol([], ['std::_Binder'], [], [])"><div class="token cpp_type">_Binder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt; <div class="def" id="FB$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]"><div><div class="token cpp_function">bind</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&amp;&amp; <div class="def" id="NI$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func"><div><div class="token cpp_argument">_Func</div></div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;... <div class="def" id="NI$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args"><div><div class="token cpp_argument">_Args</div></div></div>)</div></div>
	{	<div class="token cpp_comment ">// bind a callable object with an explicit return type</div>
<div class="expandable"><div class="disabled">	return (_Binder&lt;_Ret, _Fx, _Types...&gt;(_STD forward&lt;_Fx&gt;(_Func), _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="expanded">	<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Binder'], [], [])"><div class="token cpp_type">_Binder</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol(['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'], [], [])"><div class="token cpp_type">_Fx</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func'], [], [])"><div class="token cpp_argument">_Func</div></div>), ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...));</div></div>
	}

	<div class="token cpp_comment ">// PLACEHOLDER ARGUMENTS</div>
		<div class="token cpp_keyword ">namespace</div> <div class="def" id="NF[0]$std::placeholders"><div>placeholders</div></div> {	<div class="token cpp_comment ">// placeholders</div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;1&gt; _1{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">1</div>&gt; <div class="def" id="NI$std::placeholders::_1"><div>_1</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;2&gt; _2{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">2</div>&gt; <div class="def" id="NI$std::placeholders::_2"><div>_2</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;3&gt; _3{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">3</div>&gt; <div class="def" id="NI$std::placeholders::_3"><div>_3</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;4&gt; _4{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">4</div>&gt; <div class="def" id="NI$std::placeholders::_4"><div>_4</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;5&gt; _5{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">5</div>&gt; <div class="def" id="NI$std::placeholders::_5"><div>_5</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;6&gt; _6{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">6</div>&gt; <div class="def" id="NI$std::placeholders::_6"><div>_6</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;7&gt; _7{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">7</div>&gt; <div class="def" id="NI$std::placeholders::_7"><div>_7</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;8&gt; _8{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">8</div>&gt; <div class="def" id="NI$std::placeholders::_8"><div>_8</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;9&gt; _9{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">9</div>&gt; <div class="def" id="NI$std::placeholders::_9"><div>_9</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;10&gt; _10{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">10</div>&gt; <div class="def" id="NI$std::placeholders::_10"><div>_10</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;11&gt; _11{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">11</div>&gt; <div class="def" id="NI$std::placeholders::_11"><div>_11</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;12&gt; _12{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">12</div>&gt; <div class="def" id="NI$std::placeholders::_12"><div>_12</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;13&gt; _13{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">13</div>&gt; <div class="def" id="NI$std::placeholders::_13"><div>_13</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;14&gt; _14{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">14</div>&gt; <div class="def" id="NI$std::placeholders::_14"><div>_14</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;15&gt; _15{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">15</div>&gt; <div class="def" id="NI$std::placeholders::_15"><div>_15</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;16&gt; _16{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">16</div>&gt; <div class="def" id="NI$std::placeholders::_16"><div>_16</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;17&gt; _17{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">17</div>&gt; <div class="def" id="NI$std::placeholders::_17"><div>_17</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;18&gt; _18{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">18</div>&gt; <div class="def" id="NI$std::placeholders::_18"><div>_18</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;19&gt; _19{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">19</div>&gt; <div class="def" id="NI$std::placeholders::_19"><div>_19</div></div>{};</div></div>
<div class="expandable"><div class="disabled">_INLINE_VAR constexpr _Ph&lt;20&gt; _20{};</div>
<div class="expanded"> <div class="token cpp_keyword ">constexpr</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Ph'], [], [])"><div class="token cpp_type">_Ph</div></div>&lt;<div class="token cpp_number ">20</div>&gt; <div class="def" id="NI$std::placeholders::_20"><div>_20</div></div>{};</div></div>
		}	<div class="token cpp_comment ">// namespace placeholders</div>

<div class="disabled">#if _HAS_FUNCTION_ALLOCATOR_SUPPORT</div>
	<div class="token cpp_comment ">// STRUCT TEMPLATE uses_allocator</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Fty"><div><div class="token cpp_type">_Fty</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>&gt;
	<div class="token cpp_keyword ">struct</div> <div class="def" id="NI$std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>"><div class="ref" onclick="jumpToSymbol([], [], [], ['std::uses_allocator'])"><div class="token cpp_type">uses_allocator</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Fty'], [], [])"><div class="token cpp_type">_Fty</div></div>&gt;, <div class="ref" onclick="jumpToSymbol([], ['std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>&gt;
		: <div class="ref" onclick="jumpToSymbol([], ['std::true_type'], [], [])"><div class="token cpp_type">true_type</div></div>
	{	<div class="token cpp_comment ">// true_type if container allocator enabled</div>
	};
<div class="disabled">#endif /* _HAS_FUNCTION_ALLOCATOR_SUPPORT */</div>

<div class="disabled">#if _HAS_CXX17</div>
<div class="disabled">	// HETEROGENEOUS MEMORY BLOCK UTILITIES</div>
<div class="disabled">inline void _Add_alloc_size(size_t&amp; _Size, const size_t _Size_added, const size_t _Alignment)</div>
<div class="disabled">	{	// moves _Size up to account for storing an object of size _Size_added with alignment</div>
<div class="disabled">		// _Alignment in a memory buffer</div>
<div class="disabled">		// assumes that the memory buffer will be allocated for the &quot;worst&quot; alignment used in the</div>
<div class="disabled">		// resulting buffer</div>
<div class="disabled">	const size_t _Align_masked = _Size &amp; (_Alignment - 1u);</div>
<div class="disabled">	_Size += _Size_added;</div>
<div class="disabled">	if (_Align_masked != 0)</div>
<div class="disabled">		{</div>
<div class="disabled">		_Size += _Alignment - _Align_masked;</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>

<div class="disabled">template&lt;class _Ty&gt; inline</div>
<div class="disabled">	void _Add_alloc_size(size_t&amp; _Size)</div>
<div class="disabled">	{	// moves _Size up to account for allocating a _Ty</div>
<div class="disabled">	_Add_alloc_size(_Size, sizeof(_Ty), alignof(_Ty));</div>
<div class="disabled">	}</div>

<div class="disabled">template&lt;class _Ty&gt; inline</div>
<div class="disabled">	void _Add_alloc_size(size_t&amp; _Size, const size_t _Count)</div>
<div class="disabled">	{	// moves _Size up to account for allocating an array of _Count _Ty instances</div>
<div class="disabled">	if (static_cast&lt;size_t&gt;(-1) / sizeof(_Ty) &lt; _Count)</div>
<div class="disabled">		{</div>
<div class="disabled">		_Xbad_alloc();</div>
<div class="disabled">		}</div>

<div class="disabled">	_Add_alloc_size(_Size, sizeof(_Ty) * _Count, alignof(_Ty));</div>
<div class="disabled">	}</div>

<div class="disabled">inline void * _Decode_aligned_block(void *&amp; _Base, size_t _Size, const size_t _Alignment)</div>
<div class="disabled">	{	// &quot;allocates&quot; an object of size _Size and alignment _Alignment from _Base, and shifts</div>
<div class="disabled">		// _Base up by the size necessary to decode that object.</div>
<div class="disabled">	auto _Space = static_cast&lt;size_t&gt;(-1);</div>
<div class="disabled">	auto _Result = _STD align(_Alignment, _Size, _Base, _Space);</div>
<div class="disabled">	_Base = static_cast&lt;char *&gt;(_Base) + _Size;</div>
<div class="disabled">	return (_Result);</div>
<div class="disabled">	}</div>

<div class="disabled">template&lt;class _Ty&gt; inline</div>
<div class="disabled">	_Ty * _Decode_aligned_block(void *&amp; _Base)</div>
<div class="disabled">	{	// &quot;allocates&quot; a _Ty from _Base</div>
<div class="disabled">	return (static_cast&lt;_Ty *&gt;(_Decode_aligned_block(_Base, sizeof(_Ty), alignof(_Ty))));</div>
<div class="disabled">	}</div>

<div class="disabled">template&lt;class _Ty&gt; inline</div>
<div class="disabled">	_Ty * _Decode_aligned_block(void *&amp; _Base, const size_t _Count)</div>
<div class="disabled">	{	// &quot;allocates&quot; an array of _Count _Ty instances from _Base</div>
<div class="disabled">	return (static_cast&lt;_Ty *&gt;(_Decode_aligned_block(_Base, sizeof(_Ty) * _Count, alignof(_Ty))));</div>
<div class="disabled">	}</div>

<div class="disabled">		// STRUCT _Global_delete</div>
<div class="disabled">struct _Global_delete</div>
<div class="disabled">	{</div>
<div class="disabled">	void operator()(void * const _Ptr) const</div>
<div class="disabled">		{</div>
<div class="disabled">		::operator delete(_Ptr);</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">		// CLASS TEMPLATE default_searcher</div>
<div class="disabled">template&lt;class _FwdItHaystack,</div>
<div class="disabled">	class _FwdItPat,</div>
<div class="disabled">	class _Pred_eq&gt; inline</div>
<div class="disabled">	pair&lt;_FwdItHaystack, _FwdItHaystack&gt; _Search_pair_unchecked(_FwdItHaystack _First1, _FwdItHaystack _Last1,</div>
<div class="disabled">		_FwdItPat _First2, _FwdItPat _Last2, _Pred_eq&amp; _Eq,</div>
<div class="disabled">		forward_iterator_tag, forward_iterator_tag)</div>
<div class="disabled">	{	// find first [_First2, _Last2) satisfying _Eq, arbitrary iterators</div>
<div class="disabled">	for (; ; ++_First1)</div>
<div class="disabled">		{	// loop until match or end of a sequence</div>
<div class="disabled">		_FwdItHaystack _Mid1 = _First1;</div>
<div class="disabled">		for (_FwdItPat _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)</div>
<div class="disabled">			{</div>
<div class="disabled">			if (_Mid2 == _Last2)</div>
<div class="disabled">				{</div>
<div class="disabled">				return {_First1, _Mid1};</div>
<div class="disabled">				}</div>

<div class="disabled">			if (_Mid1 == _Last1)</div>
<div class="disabled">				{</div>
<div class="disabled">				return {_Last1, _Last1};</div>
<div class="disabled">				}</div>

<div class="disabled">			if (!_Eq(*_Mid1, *_Mid2))</div>
<div class="disabled">				{</div>
<div class="disabled">				break;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>

<div class="disabled">template&lt;class _FwdItHaystack,</div>
<div class="disabled">	class _FwdItPat,</div>
<div class="disabled">	class _Pred_eq&gt; inline</div>
<div class="disabled">	pair&lt;_FwdItHaystack, _FwdItHaystack&gt; _Search_pair_unchecked(_FwdItHaystack _First1, _FwdItHaystack _Last1,</div>
<div class="disabled">		_FwdItPat _First2, _FwdItPat _Last2, _Pred_eq&amp; _Eq,</div>
<div class="disabled">		random_access_iterator_tag, random_access_iterator_tag)</div>
<div class="disabled">	{	// find first [_First2, _Last2) satisfying _Eq, random-access iterators</div>
<div class="disabled">	_Iter_diff_t&lt;_FwdItHaystack&gt; _Count1 = _Last1 - _First1;</div>
<div class="disabled">	_Iter_diff_t&lt;_FwdItPat&gt; _Count2 = _Last2 - _First2;</div>

<div class="disabled">	for (; _Count2 &lt;= _Count1; ++_First1, (void)--_Count1)</div>
<div class="disabled">		{	// room for match, try it</div>
<div class="disabled">		_FwdItHaystack _Mid1 = _First1;</div>
<div class="disabled">		for (_FwdItPat _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)</div>
<div class="disabled">			{</div>
<div class="disabled">			if (_Mid2 == _Last2)</div>
<div class="disabled">				{</div>
<div class="disabled">				return {_First1, _Mid1};</div>
<div class="disabled">				}</div>

<div class="disabled">			if (!_Eq(*_Mid1, *_Mid2))</div>
<div class="disabled">				{</div>
<div class="disabled">				break;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	return {_Last1, _Last1};</div>
<div class="disabled">	}</div>

<div class="disabled">template&lt;class _FwdItPat,</div>
<div class="disabled">	class _Pred_eq = equal_to&lt;&gt;&gt;</div>
<div class="disabled">	class default_searcher</div>
<div class="disabled">	{	// functor to search haystacks for needles</div>
<div class="disabled">public:</div>
<div class="disabled">	default_searcher(_FwdItPat _First, _FwdItPat _Last, _Pred_eq _Eq = _Pred_eq())</div>
<div class="disabled">		: _Data{_One_then_variadic_args_t{}, _STD move(_Eq), pair&lt;_FwdItPat, _FwdItPat&gt;{_First, _Last}}</div>
<div class="disabled">		{	// construct a default_searcher</div>
<div class="disabled">		const auto&amp; _Pat = _Data._Get_second();</div>
<div class="disabled">		_Adl_verify_range(_Pat.first, _Pat.second);</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class _FwdItHaystack&gt;</div>
<div class="disabled">		_NODISCARD pair&lt;_FwdItHaystack, _FwdItHaystack&gt; operator()(_FwdItHaystack _First, _FwdItHaystack _Last) const</div>
<div class="disabled">		{	// search [_First, _Last) for the searcher&apos;s pattern</div>
<div class="disabled">		_Adl_verify_range(_First, _Last);</div>
<div class="disabled">		const auto&amp; _Eq = _Data._Get_first();</div>
<div class="disabled">		const auto&amp; _Pat = _Data._Get_second();</div>
<div class="disabled">		_Adl_verify_range(_Pat.first, _Pat.second); // check again to ensure container is not destroyed</div>
<div class="disabled">		const auto _Result = _Search_pair_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last),</div>
<div class="disabled">			_Get_unwrapped(_Pat.first), _Get_unwrapped(_Pat.second), _Eq,</div>
<div class="disabled">			_Iter_cat_t&lt;_FwdItHaystack&gt;{}, _Iter_cat_t&lt;_FwdItPat&gt;{});</div>
<div class="disabled">		_Seek_wrapped(_Last, _Result.second);</div>
<div class="disabled">		_Seek_wrapped(_First, _Result.first);</div>
<div class="disabled">		return {_First, _Last};</div>
<div class="disabled">		}</div>

<div class="disabled">private:</div>
<div class="disabled">	_Compressed_pair&lt;_Pred_eq, pair&lt;_FwdItPat, _FwdItPat&gt;&gt; _Data;</div>
<div class="disabled">	};</div>


<div class="disabled">		// STRUCT TEMPLATE _Boyer_moore_hash_delta_1_table</div>
<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	class _Hash_ty,</div>
<div class="disabled">	class _Pred_eq&gt;</div>
<div class="disabled">	struct _Boyer_moore_hash_delta_1_table</div>
<div class="disabled">	{	// stores the Boyer-Moore delta_1 table using a hash table</div>
<div class="disabled">	using _Value_t = _Iter_value_t&lt;_RanItPat&gt;;</div>
<div class="disabled">	using _Diff = _Iter_diff_t&lt;_RanItPat&gt;;</div>

<div class="disabled">	_Boyer_moore_hash_delta_1_table(_RanItPat _Pat_first_arg, _Unwrapped_t&lt;_RanItPat&gt; _UPat_first,</div>
<div class="disabled">			const _Diff _Pat_size_arg, _Hash_ty&amp;&amp; _Hash_fn, _Pred_eq&amp;&amp; _Eq)</div>
<div class="disabled">		: _Pat_first(_Pat_first_arg),</div>
<div class="disabled">		_Pat_size(_Pat_size_arg),</div>
<div class="disabled">		_Map(0, _STD move(_Hash_fn), _STD move(_Eq))</div>
<div class="disabled">		{	// initialize a delta_1 hash table</div>
<div class="disabled">		for (_Diff _Idx = 1; _Idx &lt;= _Pat_size; ++_Idx, (void)++_UPat_first)</div>
<div class="disabled">			{</div>
<div class="disabled">			_Map.insert_or_assign(*_UPat_first, _Pat_size - _Idx);</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	_Diff _Lookup(const _Value_t&amp; _Value) const</div>
<div class="disabled">		{	// lookup the &quot;character&quot; _Value in the table, returning the maximum shift if found</div>
<div class="disabled">		const auto _Iter = _Map.find(_Value);</div>
<div class="disabled">		if (_Iter == _Map.end())</div>
<div class="disabled">			{</div>
<div class="disabled">			return (_Pat_size);</div>
<div class="disabled">			}</div>

<div class="disabled">		return (_Iter-&gt;second);</div>
<div class="disabled">		}</div>

<div class="disabled">	_Pred_eq _Get_eq() const</div>
<div class="disabled">		{	// return the comparison predicate</div>
<div class="disabled">		return (_Map.key_eq());</div>
<div class="disabled">		}</div>

<div class="disabled">	const _RanItPat _Pat_first;</div>
<div class="disabled">	const _Diff _Pat_size;</div>

<div class="disabled">private:</div>
<div class="disabled">	unordered_map&lt;_Value_t, _Diff, _Hash_ty, _Pred_eq&gt; _Map;</div>
<div class="disabled">	};</div>


<div class="disabled">		// STRUCT TEMPLATE _Boyer_moore_flat_delta_1_table</div>
<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	_Iter_diff_t&lt;_RanItPat&gt; _Limit&gt;</div>
<div class="disabled">	struct _Boyer_moore_flat_delta_1_table</div>
<div class="disabled">	{	// stores the Boyer-Moore delta_1 table using a plain array lookup</div>
<div class="disabled">	using _Value_t = _Iter_value_t&lt;_RanItPat&gt;;</div>
<div class="disabled">	using _Diff = _Iter_diff_t&lt;_RanItPat&gt;;</div>

<div class="disabled">	_Boyer_moore_flat_delta_1_table(_RanItPat _Pat_first_arg, _Unwrapped_t&lt;_RanItPat&gt; _UPat_first,</div>
<div class="disabled">		const _Diff _Pat_size_arg, _Unused_parameter, _Unused_parameter)</div>
<div class="disabled">		: _Pat_first(_Pat_first_arg),</div>
<div class="disabled">		_Pat_size(_Pat_size_arg)</div>
<div class="disabled">		{	// initialize a delta_1 flat table</div>
<div class="disabled">		_STD fill(_STD begin(_Table), _STD end(_Table), _Pat_size);</div>
<div class="disabled">		for (_Diff _Idx = 1; _Idx &lt;= _Pat_size; ++_Idx, (void)++_UPat_first)</div>
<div class="disabled">			{</div>
<div class="disabled">			_Table[_Unsigned_value(*_UPat_first)] = _Pat_size - _Idx;</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	_Diff _Lookup(const _Value_t _Value) const</div>
<div class="disabled">		{	// lookup the &quot;character&quot; _Value in the table</div>
<div class="disabled">		const auto _UValue = _Unsigned_value(_Value);</div>
<div class="disabled">		if (_UValue &lt; _STD size(_Table))</div>
<div class="disabled">			{</div>
<div class="disabled">			return (_Table[_UValue]);</div>
<div class="disabled">			}</div>

<div class="disabled">		return (_Pat_size);</div>
<div class="disabled">		}</div>

<div class="disabled">	equal_to&lt;&gt; _Get_eq() const</div>
<div class="disabled">		{	// return an equality comparer</div>
<div class="disabled">		return {};</div>
<div class="disabled">		}</div>

<div class="disabled">	const _RanItPat _Pat_first;</div>
<div class="disabled">	const _Diff _Pat_size;</div>

<div class="disabled">private:</div>
<div class="disabled">	_Diff _Table[_Limit];</div>
<div class="disabled">	};</div>


<div class="disabled">		// FUNCTION TEMPLATE _Build_boyer_moore_delta_2_table</div>
<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	class _Pred_eq&gt; inline</div>
<div class="disabled">	void _Build_boyer_moore_delta_2_table(</div>
<div class="disabled">		_Iter_diff_t&lt;_RanItPat&gt; * _Shifts,</div>
<div class="disabled">		const _RanItPat _Pat_first, const _Iter_diff_t&lt;_RanItPat&gt; _Pat_size,</div>
<div class="disabled">		_Pred_eq&amp; _Eq)</div>
<div class="disabled">	{	// builds Boyer-Moore&apos;s delta_2 table from a pattern [_Pat_first, _Pat_first + _Pat_size)</div>
<div class="disabled">		// pre: _Shifts is a pointer to _Pat_size _Iter_diff_t&lt;_RanIt&gt;s</div>
<div class="disabled">	if (_Pat_size == 0)</div>
<div class="disabled">		{</div>
<div class="disabled">		return;</div>
<div class="disabled">		}</div>

<div class="disabled">	using _Diff = _Iter_diff_t&lt;_RanItPat&gt;;</div>
<div class="disabled">	unique_ptr&lt;_Diff[]&gt; _Suffix_fn{::new _Diff[static_cast&lt;size_t&gt;(_Pat_size)]};</div>
<div class="disabled">	for (_Diff _Idx = 0; _Idx &lt; _Pat_size; ++_Idx)</div>
<div class="disabled">		{</div>
<div class="disabled">		_Shifts[_Idx] = 2 * _Pat_size - _Idx - 1;</div>
<div class="disabled">		}</div>

<div class="disabled">	_Diff _Suffix = _Pat_size;</div>
<div class="disabled">	for (_Diff _Idx = _Pat_size; _Idx &gt; 0; --_Idx, (void)--_Suffix)</div>
<div class="disabled">		{</div>
<div class="disabled">		_Suffix_fn[static_cast&lt;size_t&gt;(_Idx - 1)] = _Suffix;</div>
<div class="disabled">		while (_Suffix &lt; _Pat_size &amp;&amp; !_Eq(_Pat_first[_Idx - 1], _Pat_first[_Suffix]))</div>
<div class="disabled">			{</div>
<div class="disabled">			_Shifts[_Suffix] = _Min_value(_Shifts[_Suffix], _Pat_size - _Idx);</div>
<div class="disabled">			_Suffix = _Suffix_fn[static_cast&lt;size_t&gt;(_Suffix)];</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	for (_Diff _Idx = 0; _Idx &lt;= _Suffix; ++_Idx)</div>
<div class="disabled">		{</div>
<div class="disabled">		_Shifts[_Idx] = _Min_value(_Shifts[_Idx], _Pat_size + _Suffix - _Idx);</div>
<div class="disabled">		}</div>
<div class="disabled">	}</div>


<div class="disabled">		// FUNCTION TEMPLATE _Boyer_moore_search</div>
<div class="disabled">template&lt;class _Delta1_t,</div>
<div class="disabled">	class _RanItHaystack&gt; inline</div>
<div class="disabled">	pair&lt;_RanItHaystack, _RanItHaystack&gt; _Boyer_moore_search(</div>
<div class="disabled">		const _Delta1_t&amp; _Delta1, typename _Delta1_t::_Diff * _Delta2,</div>
<div class="disabled">		_RanItHaystack _First, _RanItHaystack _Last)</div>
<div class="disabled">	{	// run the loop of the Boyer-Moore string search algorithm</div>
<div class="disabled">	static_assert(is_same_v&lt;typename _Delta1_t::_Value_t, _Iter_value_t&lt;_RanItHaystack&gt;&gt;,</div>
<div class="disabled">		&quot;boyer_moore_searcher requires matching iterator value types&quot;);</div>
<div class="disabled">	using _Diff = typename _Delta1_t::_Diff;</div>
<div class="disabled">	_Adl_verify_range(_First, _Last);</div>
<div class="disabled">	auto _UFirst = _Get_unwrapped(_First);</div>
<div class="disabled">	const auto _ULast = _Get_unwrapped(_Last);</div>
<div class="disabled">	const auto _Pat_size = _Delta1._Pat_size;</div>
<div class="disabled">	if (_Pat_size == 0)</div>
<div class="disabled">		{</div>
<div class="disabled">		return {_First, _First};</div>
<div class="disabled">		}</div>

<div class="disabled">	const auto _UPat_first = _Get_unwrapped_n(_Delta1._Pat_first, _Pat_size);</div>
<div class="disabled">	const auto _Eq = _Delta1._Get_eq();</div>
<div class="disabled">	_Diff _Shift = _Pat_size - 1;</div>
<div class="disabled">	while (_Shift &lt; _ULast - _UFirst)</div>
<div class="disabled">		{</div>
<div class="disabled">		_UFirst += _Shift;</div>
<div class="disabled">		_Shift = _Delta1._Lookup(*_UFirst);</div>
<div class="disabled">		if (_Shift == 0)</div>
<div class="disabled">			{	// that is, *_UFirst == &quot;_Pat.back()&quot;</div>
<div class="disabled">			_Diff _Idx = _Pat_size - 1;</div>
<div class="disabled">			do</div>
<div class="disabled">				{</div>
<div class="disabled">				if (_Idx == 0)</div>
<div class="disabled">					{</div>
<div class="disabled">					_Seek_wrapped(_Last, _UFirst + _Pat_size);</div>
<div class="disabled">					_Seek_wrapped(_First, _UFirst);</div>
<div class="disabled">					return {_First, _Last};</div>
<div class="disabled">					}</div>

<div class="disabled">				--_Idx;</div>
<div class="disabled">				--_UFirst;</div>
<div class="disabled">				}</div>
<div class="disabled">			while (_Eq(*_UFirst, _UPat_first[_Idx]));</div>
<div class="disabled">			_Shift = _Max_value(_Delta1._Lookup(*_UFirst), _Delta2[_Idx]);</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	_Seek_wrapped(_Last, _ULast);</div>
<div class="disabled">	_Seek_wrapped(_First, _ULast);</div>
<div class="disabled">	return {_First, _Last};</div>
<div class="disabled">	}</div>


<div class="disabled">		// FUNCTION TEMPLATE _Boyer_moore_horspool_search</div>
<div class="disabled">template&lt;class _Delta1_t,</div>
<div class="disabled">	class _RanItHaystack&gt; inline</div>
<div class="disabled">	pair&lt;_RanItHaystack, _RanItHaystack&gt; _Boyer_moore_horspool_search(</div>
<div class="disabled">		const _Delta1_t&amp; _Delta1,</div>
<div class="disabled">		_RanItHaystack _First, _RanItHaystack _Last)</div>
<div class="disabled">	{	// run the loop of the Boyer-Moore-Horspool string search algorithm</div>
<div class="disabled">	static_assert(is_same_v&lt;typename _Delta1_t::_Value_t, _Iter_value_t&lt;_RanItHaystack&gt;&gt;,</div>
<div class="disabled">		&quot;boyer_moore_horspool_searcher requires matching iterator value types&quot;);</div>
<div class="disabled">	using _Diff = typename _Delta1_t::_Diff;</div>
<div class="disabled">	_Adl_verify_range(_First, _Last);</div>
<div class="disabled">	const auto _Pat_size = _Delta1._Pat_size;</div>
<div class="disabled">	if (_Pat_size == 0)</div>
<div class="disabled">		{</div>
<div class="disabled">		return {_First, _First};</div>
<div class="disabled">		}</div>

<div class="disabled">	auto _UFirst = _Get_unwrapped(_First);</div>
<div class="disabled">	const auto _ULast = _Get_unwrapped(_Last);</div>
<div class="disabled">	const auto _UPat_first = _Get_unwrapped_n(_Delta1._Pat_first, _Pat_size);</div>
<div class="disabled">	const auto _Eq = _Delta1._Get_eq();</div>
<div class="disabled">	_Diff _Shift = _Pat_size - 1;</div>
<div class="disabled">	while (_Shift &lt; _ULast - _UFirst)</div>
<div class="disabled">		{</div>
<div class="disabled">		_UFirst += _Shift;</div>
<div class="disabled">		_Shift = _Delta1._Lookup(*_UFirst);</div>
<div class="disabled">		if (_Shift == 0)</div>
<div class="disabled">			{	// that is, *_UFirst == &quot;_Pat.back()&quot;</div>
<div class="disabled">			const auto _Candidate = _UFirst - (_Pat_size - 1);</div>
<div class="disabled">			if (_Equal_unchecked(_UPat_first, _UPat_first + (_Pat_size - 1), _Candidate, _Pass_fn(_Eq)))</div>
<div class="disabled">				{</div>
<div class="disabled">				_Seek_wrapped(_Last, _Candidate + _Pat_size);</div>
<div class="disabled">				_Seek_wrapped(_First, _Candidate);</div>
<div class="disabled">				return {_First, _Last};</div>
<div class="disabled">				}</div>

<div class="disabled">			_Shift = 1;</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	_Seek_wrapped(_Last, _ULast);</div>
<div class="disabled">	_Seek_wrapped(_First, _ULast);</div>
<div class="disabled">	return {_First, _Last};</div>
<div class="disabled">	}</div>


<div class="disabled">		// STRUCT AND ALIAS TEMPLATES _Boyer_moore_traits</div>
<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	class _Hash_ty,</div>
<div class="disabled">	class _Pred_eq,</div>
<div class="disabled">	class _Delta1_t&gt;</div>
<div class="disabled">	struct _Single_delta1_type_boyer_moore_traits</div>
<div class="disabled">	{</div>
<div class="disabled">	using _Diff = _Iter_diff_t&lt;_RanItPat&gt;;</div>

<div class="disabled">	// uses buffers of the form {</div>
<div class="disabled">	// _Atomic_counter_t _Ref_count</div>
<div class="disabled">	// _Delta1_t _Delta1</div>
<div class="disabled">	// _Diff _Delta2[_Pattern_size] // not used for Boyer-Moore-Horspool</div>
<div class="disabled">	// }</div>

<div class="disabled">	template&lt;bool _Build_delta2&gt;</div>
<div class="disabled">		static void * _Build_boyer_moore(_RanItPat _First, _RanItPat _Last,</div>
<div class="disabled">			_Hash_ty _Hash_fn, _Pred_eq _Eq)</div>
<div class="disabled">		{	// builds data tables for the Boyer-Moore string search algorithm</div>
<div class="disabled">		_Adl_verify_range(_First, _Last);</div>
<div class="disabled">		const auto _UFirst = _Get_unwrapped(_First);</div>
<div class="disabled">		const auto _Pat_size_raw = _Get_unwrapped(_Last) - _UFirst;</div>
<div class="disabled">		using _CT = common_type_t&lt;_Iter_diff_t&lt;_RanItPat&gt;, size_t&gt;;</div>
<div class="disabled">		if (static_cast&lt;_CT&gt;(_Pat_size_raw) &gt; static_cast&lt;_CT&gt;(SIZE_MAX))</div>
<div class="disabled">			{</div>
<div class="disabled">			_Xbad_alloc();</div>
<div class="disabled">			}</div>

<div class="disabled">		const auto _Pat_size = static_cast&lt;size_t&gt;(_Pat_size_raw);</div>
<div class="disabled">		size_t _Buf_size = 0;</div>
<div class="disabled">		_Add_alloc_size&lt;_Atomic_counter_t&gt;(_Buf_size);</div>
<div class="disabled">		_Add_alloc_size&lt;_Delta1_t&gt;(_Buf_size);</div>
<div class="disabled">		if (_Build_delta2)</div>
<div class="disabled">			{</div>
<div class="disabled">			_Add_alloc_size&lt;_Diff&gt;(_Buf_size, _Pat_size);</div>
<div class="disabled">			}</div>

<div class="disabled">		unique_ptr&lt;void, _Global_delete&gt; _Buf_bytes(::operator new(_Buf_size));</div>
<div class="disabled">		void * _Buf = _Buf_bytes.get();</div>
<div class="disabled">		*_Decode_aligned_block&lt;_Atomic_counter_t&gt;(_Buf) = 1;</div>
<div class="disabled">		void * const _Delta1 = _Decode_aligned_block&lt;_Delta1_t&gt;(_Buf);</div>
<div class="disabled">		if (_Build_delta2)</div>
<div class="disabled">			{</div>
<div class="disabled">			_Build_boyer_moore_delta_2_table(_Decode_aligned_block&lt;_Diff&gt;(_Buf, _Pat_size),</div>
<div class="disabled">				_UFirst, _Pat_size_raw, _Eq);</div>
<div class="disabled">			}</div>

<div class="disabled">		::new (_Delta1) _Delta1_t(_First, _UFirst, _Pat_size_raw, _STD move(_Hash_fn), _STD move(_Eq));</div>
<div class="disabled">		return (_Buf_bytes.release());</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class _RanItHaystack&gt;</div>
<div class="disabled">		static pair&lt;_RanItHaystack, _RanItHaystack&gt; _Use_boyer_moore(void * _Data,</div>
<div class="disabled">			_RanItHaystack _First, _RanItHaystack _Last)</div>
<div class="disabled">		{	// decodes data tables for the Boyer-Moore string search algorithm</div>
<div class="disabled">		(void)_Decode_aligned_block&lt;_Atomic_counter_t&gt;(_Data);</div>
<div class="disabled">		const auto _Delta1 = _Decode_aligned_block&lt;_Delta1_t&gt;(_Data);</div>
<div class="disabled">		const auto _Delta2 = _Decode_aligned_block&lt;_Diff&gt;(_Data, static_cast&lt;size_t&gt;(_Delta1-&gt;_Pat_size));</div>
<div class="disabled">		return (_Boyer_moore_search(*_Delta1, _Delta2, _First, _Last));</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class _RanItHaystack&gt;</div>
<div class="disabled">		static pair&lt;_RanItHaystack, _RanItHaystack&gt; _Use_boyer_moore_horspool(void * _Data,</div>
<div class="disabled">			_RanItHaystack _First, _RanItHaystack _Last)</div>
<div class="disabled">		{	// decodes data tables for the Boyer-Moore string search algorithm</div>
<div class="disabled">		(void)_Decode_aligned_block&lt;_Atomic_counter_t&gt;(_Data);</div>
<div class="disabled">		const auto _Delta1 = _Decode_aligned_block&lt;_Delta1_t&gt;(_Data);</div>
<div class="disabled">		return (_Boyer_moore_horspool_search(*_Delta1, _First, _Last));</div>
<div class="disabled">		}</div>

<div class="disabled">	static void _Destroy(void * const _Base) noexcept</div>
<div class="disabled">		{	// destroys data tables for either the Boyer-Moore or Boyer-Moore-Horspool</div>
<div class="disabled">			// string search algorithms</div>
<div class="disabled">		void * _Data = _Base;</div>
<div class="disabled">		(void)_Decode_aligned_block&lt;_Atomic_counter_t&gt;(_Data);</div>
<div class="disabled">		_Decode_aligned_block&lt;_Delta1_t&gt;(_Data)-&gt;~_Delta1_t();</div>
<div class="disabled">		::operator delete(_Base);</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	class _Hash_ty,</div>
<div class="disabled">	class _Pred_eq&gt;</div>
<div class="disabled">	using _Boyer_moore_traits_char_mode = _Single_delta1_type_boyer_moore_traits&lt;_RanItPat, _Hash_ty, _Pred_eq,</div>
<div class="disabled">			_Boyer_moore_flat_delta_1_table&lt;_RanItPat, 256&gt;&gt;;</div>

<div class="disabled">template&lt;class _RanItPat&gt;</div>
<div class="disabled">	struct _Boyer_moore_traits_wchar_t_mode</div>
<div class="disabled">	{</div>
<div class="disabled">	using _Value_t = _Iter_value_t&lt;_RanItPat&gt;;</div>
<div class="disabled">	using _Diff = _Iter_diff_t&lt;_RanItPat&gt;;</div>
<div class="disabled">	using _Big_table_t = _Boyer_moore_flat_delta_1_table&lt;_RanItPat, 65536&gt;;</div>
<div class="disabled">	using _Small_table_t = _Boyer_moore_flat_delta_1_table&lt;_RanItPat, 256&gt;;</div>

<div class="disabled">	// uses buffers of the form {</div>
<div class="disabled">	// _Atomic_counter_t _Ref_count</div>
<div class="disabled">	// bool _Use_large_table // true if anything in the pattern is &gt; 255</div>
<div class="disabled">	// conditional_t&lt;_Use_large_table, _Big_table_t, _Small_table_t&gt; _Delta1</div>
<div class="disabled">	// _Diff _Delta2[_Pattern_size] // not used for Boyer-Moore-Horspool</div>
<div class="disabled">	// }</div>

<div class="disabled">	template&lt;bool _Build_delta2&gt;</div>
<div class="disabled">		static void * _Build_boyer_moore(_RanItPat _First, _RanItPat _Last,</div>
<div class="disabled">			_Unused_parameter, _Unused_parameter)</div>
<div class="disabled">		{	// builds data tables for the Boyer-Moore string search algorithm</div>
<div class="disabled">		_Adl_verify_range(_First, _Last);</div>
<div class="disabled">		const auto _UFirst = _Get_unwrapped(_First);</div>
<div class="disabled">		const auto _ULast = _Get_unwrapped(_Last);</div>
<div class="disabled">		const auto _Pat_size_raw = _ULast - _UFirst;</div>
<div class="disabled">		using _CT = common_type_t&lt;_Iter_diff_t&lt;_RanItPat&gt;, size_t&gt;;</div>
<div class="disabled">		if (static_cast&lt;_CT&gt;(_Pat_size_raw) &gt; static_cast&lt;_CT&gt;(SIZE_MAX))</div>
<div class="disabled">			{</div>
<div class="disabled">			_Xbad_alloc();</div>
<div class="disabled">			}</div>

<div class="disabled">		const auto _Pat_size = static_cast&lt;size_t&gt;(_Pat_size_raw);</div>
<div class="disabled">		size_t _Buf_size = 0;</div>
<div class="disabled">		_Add_alloc_size&lt;_Atomic_counter_t&gt;(_Buf_size);</div>
<div class="disabled">		bool _Use_large_table = false;</div>

<div class="disabled">		for (auto _Temp = _UFirst; _Temp != _ULast; ++_Temp)</div>
<div class="disabled">			{</div>
<div class="disabled">			if (_Unsigned_value(*_Temp) &gt; 255)</div>
<div class="disabled">				{</div>
<div class="disabled">				_Use_large_table = true;</div>
<div class="disabled">				break;</div>
<div class="disabled">				}</div>
<div class="disabled">			}</div>

<div class="disabled">		_Add_alloc_size&lt;bool&gt;(_Buf_size);</div>
<div class="disabled">		if (_Use_large_table)</div>
<div class="disabled">			{</div>
<div class="disabled">			_Add_alloc_size&lt;_Big_table_t&gt;(_Buf_size);</div>
<div class="disabled">			}</div>
<div class="disabled">		else</div>
<div class="disabled">			{</div>
<div class="disabled">			_Add_alloc_size&lt;_Small_table_t&gt;(_Buf_size);</div>
<div class="disabled">			}</div>

<div class="disabled">		if (_Build_delta2)</div>
<div class="disabled">			{</div>
<div class="disabled">			_Add_alloc_size&lt;_Diff&gt;(_Buf_size, _Pat_size);</div>
<div class="disabled">			}</div>

<div class="disabled">		unique_ptr&lt;void, _Global_delete&gt; _Buf_bytes(::operator new(_Buf_size));</div>
<div class="disabled">		void * _Buf = _Buf_bytes.get();</div>
<div class="disabled">		*_Decode_aligned_block&lt;_Atomic_counter_t&gt;(_Buf) = 1;</div>
<div class="disabled">		*_Decode_aligned_block&lt;bool&gt;(_Buf) = _Use_large_table;</div>
<div class="disabled">		if (_Use_large_table)</div>
<div class="disabled">			{</div>
<div class="disabled">			using _Delta1_t = _Big_table_t;</div>
<div class="disabled">			::new (static_cast&lt;void *&gt;(_Decode_aligned_block&lt;_Delta1_t&gt;(_Buf)))</div>
<div class="disabled">				_Delta1_t(_First, _UFirst, _Pat_size_raw, {}, {});</div>
<div class="disabled">			}</div>
<div class="disabled">		else</div>
<div class="disabled">			{</div>
<div class="disabled">			using _Delta1_t = _Small_table_t;</div>
<div class="disabled">			::new (static_cast&lt;void *&gt;(_Decode_aligned_block&lt;_Delta1_t&gt;(_Buf)))</div>
<div class="disabled">				_Delta1_t(_First, _UFirst, _Pat_size_raw, {}, {});</div>
<div class="disabled">			}</div>

<div class="disabled">		if (_Build_delta2)</div>
<div class="disabled">			{</div>
<div class="disabled">			equal_to&lt;&gt; _Eq;</div>
<div class="disabled">			_Build_boyer_moore_delta_2_table(_Decode_aligned_block&lt;_Diff&gt;(_Buf, _Pat_size),</div>
<div class="disabled">				_UFirst, _Pat_size_raw, _Eq);</div>
<div class="disabled">			}</div>

<div class="disabled">		return (_Buf_bytes.release());</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class _RanItHaystack&gt;</div>
<div class="disabled">		static pair&lt;_RanItHaystack, _RanItHaystack&gt; _Use_boyer_moore(void * _Data,</div>
<div class="disabled">			_RanItHaystack _First, _RanItHaystack _Last)</div>
<div class="disabled">		{	// decodes data tables for the Boyer-Moore string search algorithm</div>
<div class="disabled">		(void)_Decode_aligned_block&lt;_Atomic_counter_t&gt;(_Data);</div>
<div class="disabled">		if (*_Decode_aligned_block&lt;bool&gt;(_Data))</div>
<div class="disabled">			{</div>
<div class="disabled">			const auto _Delta1 = _Decode_aligned_block&lt;_Big_table_t&gt;(_Data);</div>
<div class="disabled">			const auto _Delta2 = _Decode_aligned_block&lt;_Diff&gt;(_Data, static_cast&lt;size_t&gt;(_Delta1-&gt;_Pat_size));</div>
<div class="disabled">			return (_Boyer_moore_search(*_Delta1, _Delta2, _First, _Last));</div>
<div class="disabled">			}</div>
<div class="disabled">		else</div>
<div class="disabled">			{</div>
<div class="disabled">			const auto _Delta1 = _Decode_aligned_block&lt;_Small_table_t&gt;(_Data);</div>
<div class="disabled">			const auto _Delta2 = _Decode_aligned_block&lt;_Diff&gt;(_Data, static_cast&lt;size_t&gt;(_Delta1-&gt;_Pat_size));</div>
<div class="disabled">			return (_Boyer_moore_search(*_Delta1, _Delta2, _First, _Last));</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class _RanItHaystack&gt;</div>
<div class="disabled">		static pair&lt;_RanItHaystack, _RanItHaystack&gt; _Use_boyer_moore_horspool(void * _Data,</div>
<div class="disabled">			_RanItHaystack _First, _RanItHaystack _Last)</div>
<div class="disabled">		{	// decodes data tables for the Boyer-Moore string search algorithm</div>
<div class="disabled">		(void)_Decode_aligned_block&lt;_Atomic_counter_t&gt;(_Data);</div>
<div class="disabled">		if (*_Decode_aligned_block&lt;bool&gt;(_Data))</div>
<div class="disabled">			{</div>
<div class="disabled">			const auto _Delta1 = _Decode_aligned_block&lt;_Big_table_t&gt;(_Data);</div>
<div class="disabled">			return (_Boyer_moore_horspool_search(*_Delta1, _First, _Last));</div>
<div class="disabled">			}</div>
<div class="disabled">		else</div>
<div class="disabled">			{</div>
<div class="disabled">			const auto _Delta1 = _Decode_aligned_block&lt;_Small_table_t&gt;(_Data);</div>
<div class="disabled">			return (_Boyer_moore_horspool_search(*_Delta1, _First, _Last));</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	static void _Destroy(void * const _Base) noexcept</div>
<div class="disabled">		{	// destroys data tables for either the Boyer-Moore or Boyer-Moore-Horspool</div>
<div class="disabled">			// string search algorithms</div>
<div class="disabled">		void * _Data = _Base;</div>
<div class="disabled">		(void)_Decode_aligned_block&lt;_Atomic_counter_t&gt;(_Data);</div>
<div class="disabled">		if (*_Decode_aligned_block&lt;bool&gt;(_Data))</div>
<div class="disabled">			{</div>
<div class="disabled">			const auto _Delta1 = _Decode_aligned_block&lt;_Big_table_t&gt;(_Data);</div>
<div class="disabled">			_Delta1-&gt;~_Big_table_t();</div>
<div class="disabled">			}</div>
<div class="disabled">		else</div>
<div class="disabled">			{</div>
<div class="disabled">			const auto _Delta1 = _Decode_aligned_block&lt;_Small_table_t&gt;(_Data);</div>
<div class="disabled">			_Delta1-&gt;~_Small_table_t();</div>
<div class="disabled">			}</div>
<div class="disabled">		static_assert(is_trivially_destructible_v&lt;_Diff&gt;, &quot;allows Boyer-Moore and Boyer-Moore-Horspool to &quot;</div>
<div class="disabled">			&quot;share cleanup functions&quot;);</div>
<div class="disabled">		::operator delete(_Base);</div>
<div class="disabled">		}</div>
<div class="disabled">	};</div>

<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	class _Hash_ty,</div>
<div class="disabled">	class _Pred_eq&gt;</div>
<div class="disabled">	using _Boyer_moore_traits_general_mode = _Single_delta1_type_boyer_moore_traits&lt;_RanItPat, _Hash_ty, _Pred_eq,</div>
<div class="disabled">			_Boyer_moore_hash_delta_1_table&lt;_RanItPat, _Hash_ty, _Pred_eq&gt;&gt;;</div>

<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	class _Hash_ty,</div>
<div class="disabled">	class _Pred_eq,</div>
<div class="disabled">	class _Value_t = _Iter_value_t&lt;_RanItPat&gt;&gt;</div>
<div class="disabled">	using _Boyer_moore_traits = conditional_t&lt;is_integral_v&lt;_Value_t&gt; &amp;&amp; sizeof(_Value_t) &lt;= 2</div>
<div class="disabled">		&amp;&amp; (is_same_v&lt;equal_to&lt;&gt;, _Pred_eq&gt; || is_same_v&lt;equal_to&lt;_Value_t&gt;, _Pred_eq&gt;),</div>
<div class="disabled">			conditional_t&lt;sizeof(_Value_t) == 1, _Boyer_moore_traits_char_mode&lt;_RanItPat, _Hash_ty, _Pred_eq&gt;,</div>
<div class="disabled">			_Boyer_moore_traits_wchar_t_mode&lt;_RanItPat&gt;&gt;,</div>
<div class="disabled">		_Boyer_moore_traits_general_mode&lt;_RanItPat, _Hash_ty, _Pred_eq&gt;&gt;;</div>


<div class="disabled">		// CLASS TEMPLATE boyer_moore_searcher</div>
<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	class _Hash_ty = hash&lt;_Iter_value_t&lt;_RanItPat&gt;&gt;,</div>
<div class="disabled">	class _Pred_eq = equal_to&lt;&gt;&gt;</div>
<div class="disabled">	class boyer_moore_searcher</div>
<div class="disabled">	{	// an implementation of the Boyer-Moore string search algorithm</div>
<div class="disabled">public:</div>
<div class="disabled">	boyer_moore_searcher(const _RanItPat _First, const _RanItPat _Last,</div>
<div class="disabled">			_Hash_ty _Hash_fn = _Hash_ty(), _Pred_eq _Eq = _Pred_eq())</div>
<div class="disabled">		: _Data(_Traits::template _Build_boyer_moore&lt;true&gt;(_First, _Last,</div>
<div class="disabled">			_STD move(_Hash_fn), _STD move(_Eq)))</div>
<div class="disabled">		{	// preprocess a pattern for use with the Boyer-Moore string search algorithm</div>
<div class="disabled">		}</div>

<div class="disabled">	boyer_moore_searcher(const boyer_moore_searcher&amp; _Other) noexcept // strengthened</div>
<div class="disabled">		: _Data(_Other)</div>
<div class="disabled">		{	// copy an instance of the Boyer-Moore string search algorithm</div>
<div class="disabled">		_MT_INCR(*static_cast&lt;_Atomic_counter_t *&gt;(_Data));</div>
<div class="disabled">		}</div>

<div class="disabled">	~boyer_moore_searcher() noexcept</div>
<div class="disabled">		{	// destroy this instance</div>
<div class="disabled">		if (_MT_DECR(*static_cast&lt;_Atomic_counter_t *&gt;(_Data)) == 0)</div>
<div class="disabled">			{</div>
<div class="disabled">			_Traits::_Destroy(_Data);</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	boyer_moore_searcher&amp; operator=(const boyer_moore_searcher&amp; _Other) noexcept // strengthened</div>
<div class="disabled">		{	// assign over this instance</div>
<div class="disabled">		boyer_moore_searcher _Cpy(_Other);</div>
<div class="disabled">		swap(_Data, _Other._Data);</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class _RanItHaystack&gt;</div>
<div class="disabled">		_NODISCARD pair&lt;_RanItHaystack, _RanItHaystack&gt; operator()(</div>
<div class="disabled">			const _RanItHaystack _First, const _RanItHaystack _Last) const</div>
<div class="disabled">		{	// search for the preprocessed pattern in [_First, _Last)</div>
<div class="disabled">		return (_Traits::_Use_boyer_moore(_Data, _First, _Last));</div>
<div class="disabled">		}</div>
<div class="disabled">private:</div>
<div class="disabled">	using _Traits = _Boyer_moore_traits&lt;_RanItPat, _Hash_ty, _Pred_eq&gt;;</div>
<div class="disabled">	void * _Data;</div>
<div class="disabled">	};</div>


<div class="disabled">		// CLASS TEMPLATE boyer_moore_horspool_searcher</div>
<div class="disabled">template&lt;class _RanItPat,</div>
<div class="disabled">	class _Hash_ty = hash&lt;_Iter_value_t&lt;_RanItPat&gt;&gt;,</div>
<div class="disabled">	class _Pred_eq = equal_to&lt;&gt;&gt;</div>
<div class="disabled">	class boyer_moore_horspool_searcher</div>
<div class="disabled">	{	// an implementation of the Boyer-Moore-Horspool string search algorithm</div>
<div class="disabled">		// (equivalent to Boyer-Moore without the second table)</div>
<div class="disabled">public:</div>
<div class="disabled">	boyer_moore_horspool_searcher(const _RanItPat _First, const _RanItPat _Last,</div>
<div class="disabled">			_Hash_ty _Hash_fn = _Hash_ty(), _Pred_eq _Eq = _Pred_eq())</div>
<div class="disabled">		: _Data(_Traits::template _Build_boyer_moore&lt;false&gt;(_First, _Last,</div>
<div class="disabled">			_STD move(_Hash_fn), _STD move(_Eq)))</div>
<div class="disabled">		{	// preprocess a pattern for use with the Boyer-Moore-Horspool string search algorithm</div>
<div class="disabled">		}</div>

<div class="disabled">	boyer_moore_horspool_searcher(</div>
<div class="disabled">			const boyer_moore_horspool_searcher&amp; _Other) noexcept // strengthened</div>
<div class="disabled">		: _Data(_Other)</div>
<div class="disabled">		{	// copy an instance of the Boyer-Moore-Horspool string search algorithm</div>
<div class="disabled">		_MT_INCR(*static_cast&lt;_Atomic_counter_t *&gt;(_Data));</div>
<div class="disabled">		}</div>

<div class="disabled">	~boyer_moore_horspool_searcher() noexcept</div>
<div class="disabled">		{</div>
<div class="disabled">		if (_MT_DECR(*static_cast&lt;_Atomic_counter_t *&gt;(_Data)) == 0)</div>
<div class="disabled">			{</div>
<div class="disabled">			_Traits::_Destroy(_Data);</div>
<div class="disabled">			}</div>
<div class="disabled">		}</div>

<div class="disabled">	boyer_moore_horspool_searcher&amp; operator=(</div>
<div class="disabled">			const boyer_moore_horspool_searcher&amp; _Other) noexcept // strengthened</div>
<div class="disabled">		{	// assign over this instance</div>
<div class="disabled">		boyer_moore_horspool_searcher _Cpy(_Other);</div>
<div class="disabled">		swap(_Data, _Other._Data);</div>
<div class="disabled">		}</div>

<div class="disabled">	template&lt;class _RanItHaystack&gt;</div>
<div class="disabled">		_NODISCARD pair&lt;_RanItHaystack, _RanItHaystack&gt; operator()(</div>
<div class="disabled">			const _RanItHaystack _First, const _RanItHaystack _Last) const</div>
<div class="disabled">		{	// search for the preprocessed pattern in [_First, _Last)</div>
<div class="disabled">		return (_Traits::_Use_boyer_moore_horspool(_Data, _First, _Last));</div>
<div class="disabled">		}</div>
<div class="disabled">private:</div>
<div class="disabled">	using _Traits = _Boyer_moore_traits&lt;_RanItPat, _Hash_ty, _Pred_eq&gt;;</div>
<div class="disabled">	void * _Data;</div>
<div class="disabled">	};
#endif /* _HAS_CXX17 */</div>

<div class="disabled">#if _HAS_TR1_NAMESPACE</div>
<div class="expandable"><div class="disabled">namespace _DEPRECATE_TR1_NAMESPACE tr1 {</div>
<div class="expanded"><div class="token cpp_keyword ">namespace</div> [[deprecated(<div class="token cpp_string ">&quot;warning STL4002: &quot;</div> <div class="token cpp_string ">&quot;The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can &quot;</div> <div class="token cpp_string ">&quot;define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.&quot;</div>)]] <div class="def" id="NF[6]$std::tr1"><div class="ref" onclick="jumpToSymbol([], ['std::tr1'], [], [])">tr1</div></div> {</div></div>
<div class="expandable"><div class="disabled">using _STD bad_function_call;</div>
<div class="expanded"><div class="token cpp_keyword ">using</div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::bad_function_call'], [], [])"><div class="token cpp_type">bad_function_call</div></div>;</div></div>
<div class="expandable"><div class="disabled">using _STD bind;</div>
<div class="expanded"><div class="token cpp_keyword ">using</div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)', 'std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)'], [], [])"><div class="token cpp_function">bind</div></div>;</div></div>
<div class="expandable"><div class="disabled">using _STD function;</div>
<div class="expanded"><div class="token cpp_keyword ">using</div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::function'], [], [])"><div class="token cpp_type">function</div></div>;</div></div>
<div class="expandable"><div class="disabled">using _STD is_bind_expression;</div>
<div class="expanded"><div class="token cpp_keyword ">using</div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::is_bind_expression'], [], [])"><div class="token cpp_type">is_bind_expression</div></div>;</div></div>
<div class="expandable"><div class="disabled">using _STD is_placeholder;</div>
<div class="expanded"><div class="token cpp_keyword ">using</div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::is_placeholder'], [], [])"><div class="token cpp_type">is_placeholder</div></div>;</div></div>
<div class="expandable"><div class="disabled">using _STD mem_fn;</div>
<div class="expanded"><div class="token cpp_keyword ">using</div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)'], [], [])"><div class="token cpp_function">mem_fn</div></div>;</div></div>
<div class="expandable"><div class="disabled">using _STD swap;</div>
<div class="expanded"><div class="token cpp_keyword ">using</div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::swap@void(::std::_Vb_reference<[_Alvbase_wrapped]>, ::std::_Vb_reference<[_Alvbase_wrapped]>)', 'std::swap@void(::std::basic_string<[_Elem], [_Traits], [_Alloc]> &, ::std::basic_string<[_Elem], [_Traits], [_Alloc]> &)', 'std::swap@void(::std::exception_ptr &, ::std::exception_ptr &)', 'std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)', 'std::swap@void(::std::map<[_Kty], [_Ty], [_Pr], [_Alloc]> &, ::std::map<[_Kty], [_Ty], [_Pr], [_Alloc]> &)', 'std::swap@void(::std::multimap<[_Kty], [_Ty], [_Pr], [_Alloc]> &, ::std::multimap<[_Kty], [_Ty], [_Pr], [_Alloc]> &)', 'std::swap@void(::std::multiset<[_Kty], [_Pr], [_Alloc]> &, ::std::multiset<[_Kty], [_Pr], [_Alloc]> &)', 'std::swap@void(::std::pair<[_Ty1], [_Ty2]> &, ::std::pair<[_Ty1], [_Ty2]> &)', 'std::swap@void(::std::set<[_Kty], [_Pr], [_Alloc]> &, ::std::set<[_Kty], [_Pr], [_Alloc]> &)', 'std::swap@void(::std::shared_ptr<[_Ty]> &, ::std::shared_ptr<[_Ty]> &)', 'std::swap@void(::std::tuple<[_Types]...> &, ::std::tuple<[_Types]...> &)', 'std::swap@void(::std::unique_ptr<[_Ty], [_Dx]> &, ::std::unique_ptr<[_Ty], [_Dx]> &)', 'std::swap@void(::std::vector<[_Ty], [_Alloc]> &, ::std::vector<[_Ty], [_Alloc]> &)', 'std::swap@void(::std::weak_ptr<[_Ty]> &, ::std::weak_ptr<[_Ty]> &)', 'std::swap@void([_Ty] &, [_Ty] &)', 'std::swap@void([_Ty] [*] &, [_Ty] [*] &)'], [], [])"><div class="token cpp_function">swap</div></div>;</div></div>
<div class="token cpp_keyword ">namespace</div> <div class="def" id="NF[0]$std::tr1::placeholders"><div>placeholders</div></div> {
<div class="expandable"><div class="disabled">	using namespace _STD placeholders;</div>
<div class="expanded">	<div class="token cpp_keyword ">using</div> <div class="token cpp_keyword ">namespace</div> ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::placeholders'], [], [])">placeholders</div>;</div></div>
}
}
<div class="disabled">#endif /* _HAS_TR1_NAMESPACE */</div>


<div class="token cpp_comment ">// EVERYTHING BELOW WILL HAVE STRANGE LINE NUMBERS</div>

<div class="disabled">#if _HAS_FUNCTION_ALLOCATOR_SUPPORT</div>
<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable"><div><div class="token cpp_type">_Callable</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Alloc"><div><div class="token cpp_type">_Alloc</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx"><div><div class="token cpp_type">_Rx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_comment ">/* virtual */</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl'], [], [])"><div class="token cpp_type">_Func_impl</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Alloc'], [], [])"><div class="token cpp_type">_Alloc</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;::<div class="def" id="FB$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]"><div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)'], [], [])"><div class="token cpp_function">_Do_call</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;... <div class="def" id="NI$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args"><div><div class="token cpp_argument">_Args</div></div></div>) <div class="token cpp_comment ">/* override */</div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		{	<div class="token cpp_comment ">// call wrapped function</div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		<div class="token cpp_keyword ">auto</div>&amp; <div class="def" id="NI$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_The_callee"><div>_The_callee</div></div> = <div class="ref" onclick="jumpToSymbol(['std::_Func_impl::_Callee@[_Callable] &()'], ['std::_Func_impl::_Callee@[_Callable] &()', 'std::_Func_impl::_Callee@[_Callable] const &()'], [], [])"><div class="token cpp_function">_Callee</div></div>();
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_INTO</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
<div class="expandable"><div class="disabled">		return (_Invoker_ret&lt;_Rx&gt;::_Call(_The_callee, _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)', 'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)'], ['std::_Invoker_ret@<::std::_Unforced, *>::_Call@decltype(*)([_Valtys] &&...)', 'std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)', 'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)'], [], [])"><div class="token cpp_function">_Call</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_The_callee'], [], [])">_The_callee</div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...));</div></div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		}
<div class="disabled">#endif /* _HAS_FUNCTION_ALLOCATOR_SUPPORT */</div>

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable"><div><div class="token cpp_type">_Callable</div></div></div>,
	<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx"><div><div class="token cpp_type">_Rx</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="token cpp_comment ">/* virtual */</div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc'], [], [])"><div class="token cpp_type">_Func_impl_no_alloc</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable'], [], [])"><div class="token cpp_type">_Callable</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;::<div class="def" id="FB$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]"><div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)'], [], [])"><div class="token cpp_function">_Do_call</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&amp;&amp;... <div class="def" id="NI$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args"><div><div class="token cpp_argument">_Args</div></div></div>) <div class="token cpp_comment ">/* override */</div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		{	<div class="token cpp_comment ">// call wrapped function</div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_INTO</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
<div class="expandable"><div class="disabled">		return (_Invoker_ret&lt;_Rx&gt;::_Call(_Callee, _STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret', 'std::_Invoker_ret@<::std::_Unforced, *>', 'std::_Invoker_ret@<[_Cv_void], *>', 'std::_Invoker_ret@<[_Rx], *>'], ['std::_Invoker_ret'], [], [])"><div class="token cpp_type">_Invoker_ret</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx'], [], [])"><div class="token cpp_type">_Rx</div></div>&gt;::<div class="ref" onclick="jumpToSymbol(['std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)', 'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)'], ['std::_Invoker_ret@<::std::_Unforced, *>::_Call@decltype(*)([_Valtys] &&...)', 'std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)', 'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)'], [], [])"><div class="token cpp_function">_Call</div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Callee'], [], [])"><div class="token cpp_field">_Callee</div></div>, ::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...));</div></div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		}

<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">class</div> <div class="def" id="TA$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Ret"><div><div class="token cpp_type">_Ret</div></div></div>,
	<div class="token cpp_keyword ">class</div>... <div class="def" id="TA$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Types"><div><div class="token cpp_type">_Types</div></div></div>&gt; <div class="token cpp_keyword ">inline</div>
	<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div> <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class'], [], [])"><div class="token cpp_type">_Func_class</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Ret'], [], [])"><div class="token cpp_type">_Ret</div></div>, <div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>...&gt;::<div class="def" id="FB$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]"><div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)'], [], [])"><div class="token cpp_keyword ">operator</div><div class="token cpp_function">(</div><div class="token cpp_function">)</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>... <div class="def" id="NI$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Args"><div><div class="token cpp_argument">_Args</div></div></div>) <div class="token cpp_keyword ">const</div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		{	<div class="token cpp_comment ">// call through stored object</div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		<div class="token cpp_keyword ">if</div> (<div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Empty@bool()'], ['std::_Func_class::_Empty@bool()'], [], [])"><div class="token cpp_function">_Empty</div></div>())
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
			{
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
			<div class="ref" onclick="jumpToSymbol(['std::_Xbad_function_call@void()'], ['std::_Xbad_function_call@void()'], [], [])"><div class="token cpp_function">_Xbad_function_call</div></div>();
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
			}
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		<div class="token cpp_keyword ">const</div> <div class="token cpp_keyword ">auto</div> <div class="def" id="NI$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Impl"><div>_Impl</div></div> = <div class="ref" onclick="jumpToSymbol(['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], ['std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()'], [], [])"><div class="token cpp_function">_Getimpl</div></div>();
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_INTO</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
<div class="expandable"><div class="disabled">		return (_Impl-&gt;_Do_call(_STD forward&lt;_Types&gt;(_Args)...));</div>
<div class="expanded">		<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Impl'], [], [])">_Impl</div>-&gt;<div class="ref" onclick="jumpToSymbol(['std::_Func_base::_Do_call@[_Rx]([_Types] &&...)'], ['std::_Func_base::_Do_call@[_Rx]([_Types] &&...)'], [], [])"><div class="token cpp_function">_Do_call</div></div>(::<div class="ref" onclick="jumpToSymbol([], ['std'], [], [])">std</div>:: <div class="ref" onclick="jumpToSymbol([], ['std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)', 'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)'], [], [])"><div class="token cpp_function">forward</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Types'], [], [])"><div class="token cpp_type">_Types</div></div>&gt;(<div class="ref" onclick="jumpToSymbol([], ['std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Args'], [], [])"><div class="token cpp_argument">_Args</div></div>)...));</div></div>
<div class="disabled">#ifndef _DEBUG_FUNCTIONAL_MACHINERY</div>
<div class="disabled">#line _DEBUGGER_STEP_OVER</div>
<div class="disabled">#endif /* _DEBUG_FUNCTIONAL_MACHINERY */</div>
		}

<div class="expandable"><div class="disabled">_STD_END</div>
<div class="expanded">}</div></div>

<div class="disabled"> #pragma pop_macro(&quot;new&quot;)</div>
<div class="disabled"> _STL_RESTORE_CLANG_WARNINGS</div>
<div class="expandable"><div class="disabled"> #pragma warning(pop)</div>
<div class="expanded">#pragma warning(pop)</div></div>
<div class="expandable"><div class="disabled"> #pragma pack(pop)
#endif /* RC_INVOKED */
#endif /* _FUNCTIONAL_ */</div>
<div class="expanded">#pragma pack(pop)</div></div>

<div class="token cpp_comment ">/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */</div>
<div class="disabled"></div>
</div></div>
<script type="text/javascript">
referencedSymbols = {
    'size_t': {
        'displayNameInHtml': '<span class="cpp_type">size_t</span>',
        'impls': [
            'NI$size_t'
        ],
        'decls': []
    },
    'std': {
        'displayNameInHtml': 'std',
        'impls': [],
        'decls': [
            'NF[0]$std',
            'NF[1]$std',
            'NF[2]$std',
            'NF[3]$std',
            'NF[4]$std',
            'NF[5]$std',
            'NF[6]$std',
            'NF[7]$std',
            'NF[8]$std',
            'NF[9]$std',
            'NF[10]$std',
            'NF[11]$std',
            'NF[12]$std',
            'NF[13]$std',
            'NF[14]$std',
            'NF[15]$std',
            'NF[16]$std',
            'NF[17]$std',
            'NF[18]$std',
            'NF[19]$std',
            'NF[20]$std',
            'NF[21]$std',
            'NF[22]$std',
            'NF[23]$std',
            'NF[24]$std',
            'NF[25]$std',
            'NF[26]$std',
            'NF[27]$std',
            'NF[28]$std',
            'NF[29]$std',
            'NF[30]$std',
            'NF[31]$std',
            'NF[32]$std',
            'NF[33]$std',
            'NF[34]$std',
            'NF[35]$std',
            'NF[36]$std',
            'NF[37]$std',
            'NF[38]$std',
            'NF[39]$std',
            'NF[40]$std',
            'NF[41]$std',
            'NF[42]$std',
            'NF[43]$std',
            'NF[44]$std',
            'NF[45]$std',
            'NF[46]$std',
            'NF[47]$std',
            'NF[48]$std',
            'NF[49]$std',
            'NF[50]$std',
            'NF[51]$std',
            'NF[52]$std',
            'NF[53]$std',
            'NF[54]$std',
            'NF[55]$std',
            'NF[56]$std',
            'NF[57]$std',
            'NF[58]$std',
            'NF[59]$std',
            'NF[60]$std',
            'NF[61]$std'
        ]
    },
    'std::_Arg_types': {
        'displayNameInHtml': '<span class="cpp_type">_Arg_types</span>&lt;<span class="cpp_type">_Types</span> ...&gt;',
        'impls': [
            'NI$std::_Arg_types'
        ],
        'decls': []
    },
    'std::_Arg_types@<[_Ty1], [_Ty2]>': {
        'displayNameInHtml': '<span class="cpp_type">_Arg_types</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;',
        'impls': [
            'NI$std::_Arg_types@<[_Ty1], [_Ty2]>'
        ],
        'decls': []
    },
    'std::_Arg_types@<[_Ty1]>': {
        'displayNameInHtml': '<span class="cpp_type">_Arg_types</span>&lt;<span class="cpp_type">_Ty1</span>&gt;',
        'impls': [
            'NI$std::_Arg_types@<[_Ty1]>'
        ],
        'decls': []
    },
    'std::_Binder': {
        'displayNameInHtml': '<span class="cpp_type">_Binder</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>, <span class="cpp_type">_Types</span> ...&gt;',
        'impls': [
            'NI$std::_Binder'
        ],
        'decls': [
            'NF[0]$std::_Binder'
        ]
    },
    'std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Args': {
        'displayNameInHtml': '_Args',
        'impls': [
            'NI$std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Args'
        ],
        'decls': []
    },
    'std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::_Binder::_First': {
        'displayNameInHtml': '<span class="cpp_type">_Binder</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_First</span>',
        'impls': [
            'NI$std::_Binder::_First'
        ],
        'decls': []
    },
    'std::_Binder::_Fx2': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Binder::_Fx2'
        ],
        'decls': []
    },
    'std::_Binder::_Mypair': {
        'displayNameInHtml': '<span class="cpp_type">_Binder</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_field">_Mypair</span>',
        'impls': [
            'NI$std::_Binder::_Mypair'
        ],
        'decls': []
    },
    'std::_Binder::_Ret2': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Binder::_Ret2'
        ],
        'decls': []
    },
    'std::_Binder::_Second': {
        'displayNameInHtml': '<span class="cpp_type">_Binder</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Second</span>',
        'impls': [
            'NI$std::_Binder::_Second'
        ],
        'decls': []
    },
    'std::_Binder::_Seq': {
        'displayNameInHtml': '<span class="cpp_type">_Binder</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Seq</span>',
        'impls': [
            'NI$std::_Binder::_Seq'
        ],
        'decls': []
    },
    'std::_Binder::_Types2': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Binder::_Types2'
        ],
        'decls': []
    },
    'std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbargs': {
        'displayNameInHtml': '_Unbargs',
        'impls': [
            'NI$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbargs'
        ],
        'decls': []
    },
    'std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbound': {
        'displayNameInHtml': '<span class="cpp_type">_Unbound</span>',
        'impls': [
            'TA$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbound'
        ],
        'decls': []
    },
    'std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbargs': {
        'displayNameInHtml': '_Unbargs',
        'impls': [
            'NI$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbargs'
        ],
        'decls': []
    },
    'std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbound': {
        'displayNameInHtml': '<span class="cpp_type">_Unbound</span>',
        'impls': [
            'TA$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbound'
        ],
        'decls': []
    },
    'std::_Binder_result_type': {
        'displayNameInHtml': '<span class="cpp_type">_Binder_result_type</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>&gt;',
        'impls': [
            'NI$std::_Binder_result_type'
        ],
        'decls': []
    },
    'std::_Binder_result_type::_All_weak_types': {
        'displayNameInHtml': '<span class="cpp_type">_Binder_result_type</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>&gt;::<span class="cpp_type">_All_weak_types</span>',
        'impls': [
            'NI$std::_Binder_result_type::_All_weak_types'
        ],
        'decls': []
    },
    'std::_Binder_result_type::_Decayed': {
        'displayNameInHtml': '<span class="cpp_type">_Binder_result_type</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>&gt;::<span class="cpp_type">_Decayed</span>',
        'impls': [
            'NI$std::_Binder_result_type::_Decayed'
        ],
        'decls': []
    },
    'std::_Binder_result_type::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Binder_result_type::_Fx'
        ],
        'decls': []
    },
    'std::_Binder_result_type::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Binder_result_type::_Ret'
        ],
        'decls': []
    },
    'std::_Binder_result_type::type': {
        'displayNameInHtml': '<span class="cpp_type">_Binder_result_type</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>&gt;::<span class="cpp_type">type</span>',
        'impls': [
            'NI$std::_Binder_result_type::type'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)': {
        'displayNameInHtml': '<span class="cpp_function">_Call_binder</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_keyword">(expr)</span> ..., <span class="cpp_type">_Cv_FD</span>, <span class="cpp_type">_Cv_tuple_TiD</span>, <span class="cpp_type">_Untuple</span>&gt;(<span class="cpp_type">_Invoker_ret</span>&lt;<span class="cpp_type">_Ret</span>&gt;, <span class="cpp_type">index_sequence</span>&lt;<span class="cpp_keyword">(expr)</span> ...&gt;, <span class="cpp_type">_Cv_FD</span> &, <span class="cpp_type">_Cv_tuple_TiD</span> &, <span class="cpp_type">_Untuple</span> &&)',
        'impls': [
            'FB$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_FD': {
        'displayNameInHtml': '<span class="cpp_type">_Cv_FD</span>',
        'impls': [
            'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_FD'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_tuple_TiD': {
        'displayNameInHtml': '<span class="cpp_type">_Cv_tuple_TiD</span>',
        'impls': [
            'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_tuple_TiD'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ix': {
        'displayNameInHtml': '_Ix',
        'impls': [
            'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ix'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Obj': {
        'displayNameInHtml': '_Obj',
        'impls': [
            'NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Obj'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ret'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Tpl': {
        'displayNameInHtml': '_Tpl',
        'impls': [
            'NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Tpl'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Untuple': {
        'displayNameInHtml': '<span class="cpp_type">_Untuple</span>',
        'impls': [
            'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Untuple'
        ],
        'decls': []
    },
    'std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ut': {
        'displayNameInHtml': '_Ut',
        'impls': [
            'NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ut'
        ],
        'decls': []
    },
    'std::_Compressed_pair': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Compressed_pair'
        ],
        'decls': []
    },
    'std::_Compressed_pair::_Get_first@[_Ty1] &()': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Get_first</span>()',
        'impls': [
            'FB$std::_Compressed_pair::_Get_first@[_Ty1] &()[impl0]'
        ],
        'decls': []
    },
    'std::_Compressed_pair::_Get_first@[_Ty1] const &()': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Get_first</span>()',
        'impls': [
            'FB$std::_Compressed_pair::_Get_first@[_Ty1] const &()[impl0]'
        ],
        'decls': []
    },
    'std::_Compressed_pair::_Get_second@[_Ty2] &()': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Get_second</span>()',
        'impls': [
            'FB$std::_Compressed_pair::_Get_second@[_Ty2] &()[impl0]'
        ],
        'decls': []
    },
    'std::_Compressed_pair::_Get_second@[_Ty2] const &()': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Get_second</span>()',
        'impls': [
            'FB$std::_Compressed_pair::_Get_second@[_Ty2] const &()[impl0]'
        ],
        'decls': []
    },
    'std::_Compressed_pair@<[_Ty1], [_Ty2], *>': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Compressed_pair@<[_Ty1], [_Ty2], *>'
        ],
        'decls': []
    },
    'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Get_first</span>()',
        'impls': [
            'FB$std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()[impl0]'
        ],
        'decls': []
    },
    'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Get_first</span>()',
        'impls': [
            'FB$std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()[impl0]'
        ],
        'decls': []
    },
    'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Get_second</span>()',
        'impls': [
            'FB$std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()[impl0]'
        ],
        'decls': []
    },
    'std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()': {
        'displayNameInHtml': '<span class="cpp_type">_Compressed_pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Get_second</span>()',
        'impls': [
            'FB$std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()[impl0]'
        ],
        'decls': []
    },
    'std::_Deallocate@void(void *, ::size_t)': {
        'displayNameInHtml': '<span class="cpp_function">_Deallocate</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;(<span class="cpp_keyword">void</span> *, <span class="cpp_type">size_t</span>)',
        'impls': [
            'FB$std::_Deallocate@void(void *, ::size_t)[impl0]'
        ],
        'decls': []
    },
    'std::_Deallocate_plain@void([_Alloc] &, value_type * const)': {
        'displayNameInHtml': '<span class="cpp_function">_Deallocate_plain</span>&lt;<span class="cpp_type">_Alloc</span>, <span class="cpp_keyword">(expr)</span>&gt;(<span class="cpp_type">_Alloc</span> &, <span class="cpp_type">_Alloc</span>::value_type *<span class="cpp_keyword"> const</span>)',
        'impls': [
            'FB$std::_Deallocate_plain@void([_Alloc] &, value_type * const)[impl0]',
            'FB$std::_Deallocate_plain@void([_Alloc] &, value_type * const)[impl1]'
        ],
        'decls': []
    },
    'std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const)': {
        'displayNameInHtml': '<span class="cpp_type">_Default_allocator_traits</span>&lt;<span class="cpp_type">_Alloc</span>&gt;::<span class="cpp_function">allocate</span>(<span class="cpp_type">_Alloc</span> &, <span class="cpp_type">size_type</span><span class="cpp_keyword"> const</span>)',
        'impls': [
            'FB$std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const)[impl0]'
        ],
        'decls': []
    },
    'std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const, ::std::_Default_allocator_traits::const_void_pointer)': {
        'displayNameInHtml': '<span class="cpp_type">_Default_allocator_traits</span>&lt;<span class="cpp_type">_Alloc</span>&gt;::<span class="cpp_function">allocate</span>(<span class="cpp_type">_Alloc</span> &, <span class="cpp_type">size_type</span><span class="cpp_keyword"> const</span>, <span class="cpp_type">const_void_pointer</span>)',
        'impls': [
            'FB$std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const, ::std::_Default_allocator_traits::const_void_pointer)[impl0]'
        ],
        'decls': []
    },
    'std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_type">_Default_allocator_traits</span>&lt;<span class="cpp_type">_Alloc</span>&gt;::<span class="cpp_function">construct</span>&lt;<span class="cpp_type">_Objty</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">_Alloc</span> &, <span class="cpp_type">_Objty</span> *<span class="cpp_keyword"> const</span>, <span class="cpp_type">_Types</span> &&...)',
        'impls': [
            'FB$std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)[impl0]'
        ],
        'decls': []
    },
    'std::_Default_allocator_traits::deallocate@void([_Alloc] &, ::std::_Default_allocator_traits::pointer const, ::std::_Default_allocator_traits::size_type const)': {
        'displayNameInHtml': '<span class="cpp_type">_Default_allocator_traits</span>&lt;<span class="cpp_type">_Alloc</span>&gt;::<span class="cpp_function">deallocate</span>(<span class="cpp_type">_Alloc</span> &, <span class="cpp_type">pointer</span><span class="cpp_keyword"> const</span>, <span class="cpp_type">size_type</span><span class="cpp_keyword"> const</span>)',
        'impls': [
            'FB$std::_Default_allocator_traits::deallocate@void([_Alloc] &, ::std::_Default_allocator_traits::pointer const, ::std::_Default_allocator_traits::size_type const)[impl0]'
        ],
        'decls': []
    },
    'std::_Default_allocator_traits::destroy@void([_Alloc] &, [_Uty] * const)': {
        'displayNameInHtml': '<span class="cpp_type">_Default_allocator_traits</span>&lt;<span class="cpp_type">_Alloc</span>&gt;::<span class="cpp_function">destroy</span>&lt;<span class="cpp_type">_Uty</span>&gt;(<span class="cpp_type">_Alloc</span> &, <span class="cpp_type">_Uty</span> *<span class="cpp_keyword"> const</span>)',
        'impls': [
            'FB$std::_Default_allocator_traits::destroy@void([_Alloc] &, [_Uty] * const)[impl0]'
        ],
        'decls': []
    },
    'std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)': {
        'displayNameInHtml': '<span class="cpp_function">_Fix_arg</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_type">_Untuple</span>&gt;(<span class="cpp_type">_Cv_TiD</span> &, <span class="cpp_type">_Untuple</span> &&)',
        'impls': [
            'FB$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]'
        ],
        'decls': []
    },
    'std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Cv_TiD': {
        'displayNameInHtml': '<span class="cpp_type">_Cv_TiD</span>',
        'impls': [
            'TA$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Cv_TiD'
        ],
        'decls': []
    },
    'std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid': {
        'displayNameInHtml': '_Tid',
        'impls': [
            'NI$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'
        ],
        'decls': []
    },
    'std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': {
        'displayNameInHtml': '<span class="cpp_type">_Untuple</span>',
        'impls': [
            'TA$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'
        ],
        'decls': []
    },
    'std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut': {
        'displayNameInHtml': '_Ut',
        'impls': [
            'NI$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'
        ],
        'decls': []
    },
    'std::_Forced_result_type': {
        'displayNameInHtml': '<span class="cpp_type">_Forced_result_type</span>&lt;<span class="cpp_type">_Ret</span>&gt;',
        'impls': [
            'NI$std::_Forced_result_type'
        ],
        'decls': []
    },
    'std::_Forced_result_type::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Forced_result_type::_Ret'
        ],
        'decls': []
    },
    'std::_Func_base': {
        'displayNameInHtml': '<span class="cpp_type">_Func_base</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;',
        'impls': [
            'NI$std::_Func_base'
        ],
        'decls': []
    },
    'std::_Func_base::_Copy@::std::_Func_base *(void *)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_base</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Copy</span>(<span class="cpp_keyword">void</span> *)',
        'impls': [],
        'decls': [
            'FB$std::_Func_base::_Copy@::std::_Func_base *(void *)[decl0]'
        ]
    },
    'std::_Func_base::_Delete_this@void(bool)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_base</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Delete_this</span>(<span class="cpp_keyword">bool</span>)',
        'impls': [],
        'decls': [
            'FB$std::_Func_base::_Delete_this@void(bool)[decl0]'
        ]
    },
    'std::_Func_base::_Do_call@[_Rx]([_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_base</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Do_call</span>(<span class="cpp_type">_Types</span> &&...)',
        'impls': [],
        'decls': [
            'FB$std::_Func_base::_Do_call@[_Rx]([_Types] &&...)[decl0]'
        ]
    },
    'std::_Func_base::_Get@void const *()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_base</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Get</span>()',
        'impls': [],
        'decls': [
            'FB$std::_Func_base::_Get@void const *()[decl0]'
        ]
    },
    'std::_Func_base::_Move@::std::_Func_base *(void *)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_base</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Move</span>(<span class="cpp_keyword">void</span> *)',
        'impls': [],
        'decls': [
            'FB$std::_Func_base::_Move@::std::_Func_base *(void *)[decl0]'
        ]
    },
    'std::_Func_base::_Rx': {
        'displayNameInHtml': '<span class="cpp_type">_Rx</span>',
        'impls': [
            'TA$std::_Func_base::_Rx'
        ],
        'decls': []
    },
    'std::_Func_base::_Target@void const *(::type_info const &)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_base</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Target</span>(<span class="cpp_type">type_info</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::_Func_base::_Target@void const *(::type_info const &)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_base::_Target@void const *(::type_info const &)[impl0]::_Info': {
        'displayNameInHtml': '_Info',
        'impls': [
            'NI$std::_Func_base::_Target@void const *(::type_info const &)[impl0]::_Info'
        ],
        'decls': []
    },
    'std::_Func_base::_Target_type@::type_info const &()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_base</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Target_type</span>()',
        'impls': [],
        'decls': [
            'FB$std::_Func_base::_Target_type@::type_info const &()[decl0]'
        ]
    },
    'std::_Func_base::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Func_base::_Types'
        ],
        'decls': []
    },
    'std::_Func_class': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;',
        'impls': [
            'NI$std::_Func_class'
        ],
        'decls': []
    },
    'std::_Func_class::_Empty@bool()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Empty</span>()',
        'impls': [
            'FB$std::_Func_class::_Empty@bool()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Enable_if_callable_t': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Enable_if_callable_t</span>&lt;<span class="cpp_type">_Fx</span>, <span class="cpp_type">_Function</span>&gt;',
        'impls': [
            'NI$std::_Func_class::_Enable_if_callable_t'
        ],
        'decls': []
    },
    'std::_Func_class::_Enable_if_callable_t::_Function': {
        'displayNameInHtml': '<span class="cpp_type">_Function</span>',
        'impls': [
            'TA$std::_Func_class::_Enable_if_callable_t::_Function'
        ],
        'decls': []
    },
    'std::_Func_class::_Enable_if_callable_t::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Func_class::_Enable_if_callable_t::_Fx'
        ],
        'decls': []
    },
    'std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Getimpl</span>()',
        'impls': [
            'FB$std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Getspace@void *()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Getspace</span>()',
        'impls': [
            'FB$std::_Func_class::_Getspace@void *()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Getspace@void const *()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Getspace</span>()',
        'impls': [
            'FB$std::_Func_class::_Getspace@void const *()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Local@bool()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Local</span>()',
        'impls': [
            'FB$std::_Func_class::_Local@bool()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Mystorage': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_field">_Mystorage</span>',
        'impls': [
            'NI$std::_Func_class::_Mystorage'
        ],
        'decls': []
    },
    'std::_Func_class::_Ptrt': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Ptrt</span>',
        'impls': [
            'NI$std::_Func_class::_Ptrt'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset@void([_Fx] &&)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset</span>&lt;<span class="cpp_type">_Fx</span>&gt;(<span class="cpp_type">_Fx</span> &&)',
        'impls': [
            'FB$std::_Func_class::_Reset@void([_Fx] &&)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Impl': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset</span>&lt;<span class="cpp_type">_Fx</span>&gt;::$::<span class="cpp_type">_Impl</span>',
        'impls': [
            'NI$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Impl'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_alloc</span>&lt;<span class="cpp_type">_Fx</span>, <span class="cpp_type">_Alloc</span>&gt;(<span class="cpp_type">_Fx</span> &&, <span class="cpp_type">_Alloc</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Al': {
        'displayNameInHtml': '_Al',
        'impls': [
            'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Al'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax': {
        'displayNameInHtml': '_Ax',
        'impls': [
            'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Myimpl': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_alloc</span>&lt;<span class="cpp_type">_Fx</span>, <span class="cpp_type">_Alloc</span>&gt;::$::<span class="cpp_type">_Myimpl</span>',
        'impls': [
            'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Myimpl'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_copy@void(::std::_Func_class const &)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_copy</span>(<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;<span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_impl</span>&lt;<span class="cpp_type">_Myimpl</span>, <span class="cpp_type">_Fx</span>&gt;(<span class="cpp_type">_Fx</span> &&, <span class="cpp_type">false_type</span>)',
        'impls': [
            'FB$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Myimpl': {
        'displayNameInHtml': '<span class="cpp_type">_Myimpl</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Myimpl'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_impl</span>&lt;<span class="cpp_type">_Myimpl</span>, <span class="cpp_type">_Fx</span>&gt;(<span class="cpp_type">_Fx</span> &&, <span class="cpp_type">true_type</span>)',
        'impls': [
            'FB$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Myimpl': {
        'displayNameInHtml': '<span class="cpp_type">_Myimpl</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Myimpl'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_impl_alloc</span>&lt;<span class="cpp_type">_Fx</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Myimpl</span>, <span class="cpp_type">_Alimpl</span>&gt;(<span class="cpp_type">_Fx</span> &&, <span class="cpp_type">_Alloc</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">_Myimpl</span> *, <span class="cpp_type">_Alimpl</span> &, <span class="cpp_type">false_type</span>)',
        'impls': [
            'FB$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Al': {
        'displayNameInHtml': '_Al',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Al'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alimpl': {
        'displayNameInHtml': '<span class="cpp_type">_Alimpl</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alimpl'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ax': {
        'displayNameInHtml': '_Ax',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ax'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Myimpl': {
        'displayNameInHtml': '<span class="cpp_type">_Myimpl</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Myimpl'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_impl_alloc</span>&lt;<span class="cpp_type">_Fx</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Myimpl</span>, <span class="cpp_type">_Alimpl</span>&gt;(<span class="cpp_type">_Fx</span> &&, <span class="cpp_type">_Alloc</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">_Myimpl</span> *, <span class="cpp_type">_Alimpl</span> &, <span class="cpp_type">true_type</span>)',
        'impls': [
            'FB$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Al': {
        'displayNameInHtml': '_Al',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Al'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl': {
        'displayNameInHtml': '<span class="cpp_type">_Alimpl</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl_traits': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_impl_alloc</span>&lt;<span class="cpp_type">_Fx</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Myimpl</span>, <span class="cpp_type">_Alimpl</span>&gt;::$::<span class="cpp_type">_Alimpl_traits</span>',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl_traits'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ax': {
        'displayNameInHtml': '_Ax',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ax'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Myimpl': {
        'displayNameInHtml': '<span class="cpp_type">_Myimpl</span>',
        'impls': [
            'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Myimpl'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_move@void(::std::_Func_class &&)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Reset_move</span>(<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt; &&)',
        'impls': [
            'FB$std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::_Func_class::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Func_class::_Ret'
        ],
        'decls': []
    },
    'std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Set</span>(<span class="cpp_type">_Ptrt</span> *)',
        'impls': [
            'FB$std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Func_class::_Storage': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Storage</span>',
        'impls': [
            'NI$std::_Func_class::_Storage'
        ],
        'decls': []
    },
    'std::_Func_class::_Storage::_Ptrs': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Storage</span>::<span class="cpp_field">_Ptrs</span>',
        'impls': [
            'NI$std::_Func_class::_Storage::_Ptrs'
        ],
        'decls': []
    },
    'std::_Func_class::_Swap@void(::std::_Func_class &)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Swap</span>(<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt; &)',
        'impls': [
            'FB$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp': {
        'displayNameInHtml': '_Temp',
        'impls': [
            'NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp'
        ],
        'decls': []
    },
    'std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp2': {
        'displayNameInHtml': '_Temp',
        'impls': [
            'NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp2'
        ],
        'decls': []
    },
    'std::_Func_class::_Target@void const *(::type_info const &)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Target</span>(<span class="cpp_type">type_info</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::_Func_class::_Target@void const *(::type_info const &)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Target@void const *(::type_info const &)[impl0]::_Info': {
        'displayNameInHtml': '_Info',
        'impls': [
            'NI$std::_Func_class::_Target@void const *(::type_info const &)[impl0]::_Info'
        ],
        'decls': []
    },
    'std::_Func_class::_Target_type@::type_info const &()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Target_type</span>()',
        'impls': [
            'FB$std::_Func_class::_Target_type@::type_info const &()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Tidy@void()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Tidy</span>()',
        'impls': [
            'FB$std::_Func_class::_Tidy@void()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_class::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Func_class::_Types'
        ],
        'decls': []
    },
    'std::_Func_class::operator ()@[_Ret]([_Types]...)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_class</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">operator ()</span>(<span class="cpp_type">_Types</span>...)',
        'impls': [
            'FB$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]'
        ],
        'decls': [
            'FB$std::_Func_class::operator ()@[_Ret]([_Types]...)[decl0]'
        ]
    },
    'std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Args': {
        'displayNameInHtml': '_Args',
        'impls': [
            'NI$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Args'
        ],
        'decls': []
    },
    'std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Impl': {
        'displayNameInHtml': '_Impl',
        'impls': [
            'NI$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Impl'
        ],
        'decls': []
    },
    'std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Ret'
        ],
        'decls': []
    },
    'std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Types'
        ],
        'decls': []
    },
    'std::_Func_impl': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;',
        'impls': [
            'NI$std::_Func_impl'
        ],
        'decls': []
    },
    'std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Ax': {
        'displayNameInHtml': '_Ax',
        'impls': [
            'NI$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Ax'
        ],
        'decls': []
    },
    'std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other1': {
        'displayNameInHtml': '<span class="cpp_type">_Other1</span>',
        'impls': [
            'TA$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other1'
        ],
        'decls': []
    },
    'std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other2': {
        'displayNameInHtml': '<span class="cpp_type">_Other2</span>',
        'impls': [
            'TA$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other2'
        ],
        'decls': []
    },
    'std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Func_impl::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::_Func_impl::_Alloc'
        ],
        'decls': []
    },
    'std::_Func_impl::_Callable': {
        'displayNameInHtml': '<span class="cpp_type">_Callable</span>',
        'impls': [
            'TA$std::_Func_impl::_Callable'
        ],
        'decls': []
    },
    'std::_Func_impl::_Callee@[_Callable] &()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Callee</span>()',
        'impls': [
            'FB$std::_Func_impl::_Callee@[_Callable] &()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_impl::_Callee@[_Callable] const &()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Callee</span>()',
        'impls': [
            'FB$std::_Func_impl::_Callee@[_Callable] const &()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Clone</span>(<span class="cpp_keyword">void</span> *, <span class="cpp_type">false_type</span>)',
        'impls': [
            'FB$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Al': {
        'displayNameInHtml': '_Al',
        'impls': [
            'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Al'
        ],
        'decls': []
    },
    'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Where': {
        'displayNameInHtml': '_Where',
        'impls': [
            'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Where'
        ],
        'decls': []
    },
    'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Clone</span>(<span class="cpp_keyword">void</span> *, <span class="cpp_type">true_type</span>)',
        'impls': [
            'FB$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Al': {
        'displayNameInHtml': '_Al',
        'impls': [
            'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Al'
        ],
        'decls': []
    },
    'std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Func_impl::_Copy@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where': {
        'displayNameInHtml': '_Where',
        'impls': [
            'NI$std::_Func_impl::_Copy@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where'
        ],
        'decls': []
    },
    'std::_Func_impl::_Delete_this@void(bool)[impl0]::_Al': {
        'displayNameInHtml': '_Al',
        'impls': [
            'NI$std::_Func_impl::_Delete_this@void(bool)[impl0]::_Al'
        ],
        'decls': []
    },
    'std::_Func_impl::_Delete_this@void(bool)[impl0]::_Deallocate': {
        'displayNameInHtml': '_Deallocate',
        'impls': [
            'NI$std::_Func_impl::_Delete_this@void(bool)[impl0]::_Deallocate'
        ],
        'decls': []
    },
    'std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Do_call</span>(<span class="cpp_type">_Types</span> &&...)',
        'impls': [
            'FB$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]'
        ],
        'decls': [
            'FB$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[decl0]'
        ]
    },
    'std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args': {
        'displayNameInHtml': '_Args',
        'impls': [
            'NI$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args'
        ],
        'decls': []
    },
    'std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable': {
        'displayNameInHtml': '<span class="cpp_type">_Callable</span>',
        'impls': [
            'TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable'
        ],
        'decls': []
    },
    'std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx': {
        'displayNameInHtml': '<span class="cpp_type">_Rx</span>',
        'impls': [
            'TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx'
        ],
        'decls': []
    },
    'std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_The_callee': {
        'displayNameInHtml': '_The_callee',
        'impls': [
            'NI$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_The_callee'
        ],
        'decls': []
    },
    'std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types'
        ],
        'decls': []
    },
    'std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Al': {
        'displayNameInHtml': '_Al',
        'impls': [
            'NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Al'
        ],
        'decls': []
    },
    'std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Ptr': {
        'displayNameInHtml': '_Ptr',
        'impls': [
            'NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Ptr'
        ],
        'decls': []
    },
    'std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where': {
        'displayNameInHtml': '_Where',
        'impls': [
            'NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where'
        ],
        'decls': []
    },
    'std::_Func_impl::_Myalty': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Myalty</span>',
        'impls': [
            'NI$std::_Func_impl::_Myalty'
        ],
        'decls': []
    },
    'std::_Func_impl::_Myalty_traits': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Myalty_traits</span>',
        'impls': [
            'NI$std::_Func_impl::_Myalty_traits'
        ],
        'decls': []
    },
    'std::_Func_impl::_Myax@[_Alloc] &()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Myax</span>()',
        'impls': [
            'FB$std::_Func_impl::_Myax@[_Alloc] &()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_impl::_Myax@[_Alloc] const &()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Myax</span>()',
        'impls': [
            'FB$std::_Func_impl::_Myax@[_Alloc] const &()[impl0]'
        ],
        'decls': []
    },
    'std::_Func_impl::_Mybase': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Mybase</span>',
        'impls': [
            'NI$std::_Func_impl::_Mybase'
        ],
        'decls': []
    },
    'std::_Func_impl::_Mypair': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_field">_Mypair</span>',
        'impls': [
            'NI$std::_Func_impl::_Mypair'
        ],
        'decls': []
    },
    'std::_Func_impl::_Rx': {
        'displayNameInHtml': '<span class="cpp_type">_Rx</span>',
        'impls': [
            'TA$std::_Func_impl::_Rx'
        ],
        'decls': []
    },
    'std::_Func_impl::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Func_impl::_Types'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl_no_alloc</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;',
        'impls': [
            'NI$std::_Func_impl_no_alloc'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Other': {
        'displayNameInHtml': '<span class="cpp_type">_Other</span>',
        'impls': [
            'TA$std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Other'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Callable': {
        'displayNameInHtml': '<span class="cpp_type">_Callable</span>',
        'impls': [
            'TA$std::_Func_impl_no_alloc::_Callable'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Callee': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl_no_alloc</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_field">_Callee</span>',
        'impls': [
            'NI$std::_Func_impl_no_alloc::_Callee'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl_no_alloc</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Clone</span>(<span class="cpp_keyword">void</span> *, <span class="cpp_type">false_type</span>)',
        'impls': [
            'FB$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)[impl0]::_Where': {
        'displayNameInHtml': '_Where',
        'impls': [
            'NI$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)[impl0]::_Where'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::true_type)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl_no_alloc</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Clone</span>(<span class="cpp_keyword">void</span> *, <span class="cpp_type">true_type</span>)',
        'impls': [
            'FB$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::true_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Copy@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where': {
        'displayNameInHtml': '_Where',
        'impls': [
            'NI$std::_Func_impl_no_alloc::_Copy@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Delete_this@void(bool)[impl0]::_Dealloc': {
        'displayNameInHtml': '_Dealloc',
        'impls': [
            'NI$std::_Func_impl_no_alloc::_Delete_this@void(bool)[impl0]::_Dealloc'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl_no_alloc</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">_Do_call</span>(<span class="cpp_type">_Types</span> &&...)',
        'impls': [
            'FB$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]'
        ],
        'decls': [
            'FB$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[decl0]'
        ]
    },
    'std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args': {
        'displayNameInHtml': '_Args',
        'impls': [
            'NI$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable': {
        'displayNameInHtml': '<span class="cpp_type">_Callable</span>',
        'impls': [
            'TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx': {
        'displayNameInHtml': '<span class="cpp_type">_Rx</span>',
        'impls': [
            'TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Move@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where': {
        'displayNameInHtml': '_Where',
        'impls': [
            'NI$std::_Func_impl_no_alloc::_Move@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Mybase': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl_no_alloc</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_type">_Mybase</span>',
        'impls': [
            'NI$std::_Func_impl_no_alloc::_Mybase'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Rx': {
        'displayNameInHtml': '<span class="cpp_type">_Rx</span>',
        'impls': [
            'TA$std::_Func_impl_no_alloc::_Rx'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Func_impl_no_alloc::_Types'
        ],
        'decls': []
    },
    'std::_Func_impl_no_alloc::~_Func_impl_no_alloc@()': {
        'displayNameInHtml': '<span class="cpp_type">_Func_impl_no_alloc</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Rx</span>, <span class="cpp_type">_Types</span> ...&gt;::<span class="cpp_function">~_Func_impl_no_alloc</span>()',
        'impls': [],
        'decls': [
            'FB$std::_Func_impl_no_alloc::~_Func_impl_no_alloc@()[decl0]'
        ]
    },
    'std::_Get_function_impl': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Tx</span>&gt;',
        'impls': [],
        'decls': [
            'NF[0]$std::_Get_function_impl'
        ]
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Ret</span>( <span class="cpp_keyword">__cdecl</span>)(<span class="cpp_type">_Types</span>...)&gt;',
        'impls': [
            'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>2': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Ret</span>( <span class="cpp_keyword">__fastcall</span>)(<span class="cpp_type">_Types</span>...)&gt;',
        'impls': [
            'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>2'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Ret'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Types'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>2::type': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Ret</span>( <span class="cpp_keyword">__fastcall</span>)(<span class="cpp_type">_Types</span>...)&gt;::<span class="cpp_type">type</span>',
        'impls': [
            'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>2::type'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>3': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Ret</span>( <span class="cpp_keyword">__stdcall</span>)(<span class="cpp_type">_Types</span>...)&gt;',
        'impls': [
            'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>3'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Ret'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Types'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>3::type': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Ret</span>( <span class="cpp_keyword">__stdcall</span>)(<span class="cpp_type">_Types</span>...)&gt;::<span class="cpp_type">type</span>',
        'impls': [
            'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>3::type'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>4': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Ret</span>( <span class="cpp_keyword">__vectorcall</span>)(<span class="cpp_type">_Types</span>...)&gt;',
        'impls': [
            'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>4'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Ret'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Types'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>4::type': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Ret</span>( <span class="cpp_keyword">__vectorcall</span>)(<span class="cpp_type">_Types</span>...)&gt;::<span class="cpp_type">type</span>',
        'impls': [
            'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>4::type'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>::_Ret'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>::_Types'
        ],
        'decls': []
    },
    'std::_Get_function_impl@<[_Ret]([_Types]...)>::type': {
        'displayNameInHtml': '<span class="cpp_type">_Get_function_impl</span>&lt;<span class="cpp_type">_Ret</span>( <span class="cpp_keyword">__cdecl</span>)(<span class="cpp_type">_Types</span>...)&gt;::<span class="cpp_type">type</span>',
        'impls': [
            'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>::type'
        ],
        'decls': []
    },
    'std::_Global_new@[_Ty] *([_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_function">_Global_new</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">_Types</span> &&...)',
        'impls': [
            'FB$std::_Global_new@[_Ty] *([_Types] &&...)[impl0]'
        ],
        'decls': []
    },
    'std::_Invoker_ret': {
        'displayNameInHtml': '<span class="cpp_type">_Invoker_ret</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Invoker_ret'
        ],
        'decls': []
    },
    'std::_Invoker_ret@<::std::_Unforced, *>': {
        'displayNameInHtml': '<span class="cpp_type">_Invoker_ret</span>&lt;<span class="cpp_type">_Unforced</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Invoker_ret@<::std::_Unforced, *>'
        ],
        'decls': []
    },
    'std::_Invoker_ret@<::std::_Unforced, *>::_Call@decltype(*)([_Valtys] &&...)': {
        'displayNameInHtml': '<span class="cpp_type">_Invoker_ret</span>&lt;<span class="cpp_type">_Unforced</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Call</span>&lt;<span class="cpp_type">_Valtys</span> ...&gt;(<span class="cpp_type">_Valtys</span> &&...)',
        'impls': [
            'FB$std::_Invoker_ret@<::std::_Unforced, *>::_Call@decltype(*)([_Valtys] &&...)[impl0]'
        ],
        'decls': []
    },
    'std::_Invoker_ret@<[_Cv_void], *>': {
        'displayNameInHtml': '<span class="cpp_type">_Invoker_ret</span>&lt;<span class="cpp_type">_Cv_void</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Invoker_ret@<[_Cv_void], *>'
        ],
        'decls': []
    },
    'std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)': {
        'displayNameInHtml': '<span class="cpp_type">_Invoker_ret</span>&lt;<span class="cpp_type">_Cv_void</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Call</span>&lt;<span class="cpp_type">_Valtys</span> ...&gt;(<span class="cpp_type">_Valtys</span> &&...)',
        'impls': [
            'FB$std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)[impl0]'
        ],
        'decls': []
    },
    'std::_Invoker_ret@<[_Rx], *>': {
        'displayNameInHtml': '<span class="cpp_type">_Invoker_ret</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Invoker_ret@<[_Rx], *>'
        ],
        'decls': []
    },
    'std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)': {
        'displayNameInHtml': '<span class="cpp_type">_Invoker_ret</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Call</span>&lt;<span class="cpp_type">_Valtys</span> ...&gt;(<span class="cpp_type">_Valtys</span> &&...)',
        'impls': [
            'FB$std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)[impl0]'
        ],
        'decls': []
    },
    'std::_Is_invocable_r': {
        'displayNameInHtml': '<span class="cpp_type">_Is_invocable_r</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Callable</span>, <span class="cpp_type">_Args</span> ...&gt;',
        'impls': [
            'NI$std::_Is_invocable_r'
        ],
        'decls': []
    },
    'std::_Is_large': {
        'displayNameInHtml': '<span class="cpp_type">_Is_large</span>&lt;<span class="cpp_type">_Impl</span>&gt;',
        'impls': [
            'NI$std::_Is_large'
        ],
        'decls': []
    },
    'std::_Is_large::_Impl': {
        'displayNameInHtml': '<span class="cpp_type">_Impl</span>',
        'impls': [
            'TA$std::_Is_large::_Impl'
        ],
        'decls': []
    },
    'std::_Is_specialization_v': {
        'displayNameInHtml': '<span class="cpp_enum">_Is_specialization_v</span>&lt;<span class="cpp_type">_Type</span>, <span class="cpp_type">_Template</span>&gt;',
        'impls': [
            'NI$std::_Is_specialization_v'
        ],
        'decls': []
    },
    'std::_Mem_fn': {
        'displayNameInHtml': '<span class="cpp_type">_Mem_fn</span>&lt;<span class="cpp_type">_Memptr</span>&gt;',
        'impls': [
            'NI$std::_Mem_fn'
        ],
        'decls': []
    },
    'std::_Mem_fn::$__ctor@([_Memptr])[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::_Mem_fn::$__ctor@([_Memptr])[impl0]::_Val'
        ],
        'decls': []
    },
    'std::_Mem_fn::_Memptr': {
        'displayNameInHtml': '<span class="cpp_type">_Memptr</span>',
        'impls': [
            'TA$std::_Mem_fn::_Memptr'
        ],
        'decls': []
    },
    'std::_Mem_fn::_Pm': {
        'displayNameInHtml': '<span class="cpp_type">_Mem_fn</span>&lt;<span class="cpp_type">_Memptr</span>&gt;::<span class="cpp_field">_Pm</span>',
        'impls': [
            'NI$std::_Mem_fn::_Pm'
        ],
        'decls': []
    },
    'std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Args': {
        'displayNameInHtml': '_Args',
        'impls': [
            'NI$std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Args'
        ],
        'decls': []
    },
    'std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Types'
        ],
        'decls': []
    },
    'std::_One_then_variadic_args_t': {
        'displayNameInHtml': '<span class="cpp_type">_One_then_variadic_args_t</span>',
        'impls': [
            'NI$std::_One_then_variadic_args_t'
        ],
        'decls': []
    },
    'std::_Ph': {
        'displayNameInHtml': '<span class="cpp_type">_Ph</span>&lt;<span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Ph'
        ],
        'decls': []
    },
    'std::_Rebind_alloc_t': {
        'displayNameInHtml': '<span class="cpp_type">_Rebind_alloc_t</span>&lt;<span class="cpp_type">_Alloc</span>, <span class="cpp_type">_Value_type</span>&gt;',
        'impls': [
            'NI$std::_Rebind_alloc_t'
        ],
        'decls': []
    },
    'std::_Select_fixer': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [],
        'decls': [
            'NF[0]$std::_Select_fixer'
        ]
    },
    'std::_Select_fixer::_Cv_TiD': {
        'displayNameInHtml': '<span class="cpp_type">_Cv_TiD</span>',
        'impls': [
            'TA$std::_Select_fixer::_Cv_TiD'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Apply</span>&lt;<span class="cpp_type">_Untuple</span>, <span class="cpp_keyword">(expr)</span> ...&gt;(<span class="cpp_type">_Cv_TiD</span> &, <span class="cpp_type">_Untuple</span> &&, <span class="cpp_type">index_sequence</span>&lt;<span class="cpp_keyword">(expr)</span> ...&gt;)',
        'impls': [
            'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Jx': {
        'displayNameInHtml': '_Jx',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Jx'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Tid': {
        'displayNameInHtml': '_Tid',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Tid'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Untuple': {
        'displayNameInHtml': '<span class="cpp_type">_Untuple</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Untuple'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Ut': {
        'displayNameInHtml': '_Ut',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Ut'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Cv_TiD': {
        'displayNameInHtml': '<span class="cpp_type">_Cv_TiD</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Cv_TiD'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Fix</span>&lt;<span class="cpp_type">_Untuple</span>&gt;(<span class="cpp_type">_Cv_TiD</span> &, <span class="cpp_type">_Untuple</span> &&)',
        'impls': [
            'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid': {
        'displayNameInHtml': '_Tid',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': {
        'displayNameInHtml': '<span class="cpp_type">_Untuple</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut': {
        'displayNameInHtml': '_Ut',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>3': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>3'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Cv_TiD': {
        'displayNameInHtml': '<span class="cpp_type">_Cv_TiD</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Cv_TiD'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Fix</span>&lt;<span class="cpp_type">_Untuple</span>&gt;(<span class="cpp_type">_Cv_TiD</span> &, <span class="cpp_type">_Untuple</span> &&)',
        'impls': [
            'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid': {
        'displayNameInHtml': '_Tid',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': {
        'displayNameInHtml': '<span class="cpp_type">_Untuple</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>4': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>4'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Cv_TiD': {
        'displayNameInHtml': '<span class="cpp_type">_Cv_TiD</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Cv_TiD'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Fix</span>&lt;<span class="cpp_type">_Untuple</span>&gt;(<span class="cpp_type">_Cv_TiD</span> &, <span class="cpp_type">_Untuple</span> &&)',
        'impls': [
            'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': {
        'displayNameInHtml': '<span class="cpp_type">_Untuple</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut': {
        'displayNameInHtml': '_Ut',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Jx': {
        'displayNameInHtml': '_Jx',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Jx'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Cv_TiD': {
        'displayNameInHtml': '<span class="cpp_type">_Cv_TiD</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Cv_TiD'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)': {
        'displayNameInHtml': '<span class="cpp_type">_Select_fixer</span>&lt;<span class="cpp_type">_Cv_TiD</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_function">_Fix</span>&lt;<span class="cpp_type">_Untuple</span>&gt;(<span class="cpp_type">_Cv_TiD</span> &, <span class="cpp_type">_Untuple</span> &&)',
        'impls': [
            'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid': {
        'displayNameInHtml': '_Tid',
        'impls': [
            'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid'
        ],
        'decls': []
    },
    'std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': {
        'displayNameInHtml': '<span class="cpp_type">_Untuple</span>',
        'impls': [
            'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple'
        ],
        'decls': []
    },
    'std::_Small_object_num_ptrs': {
        'displayNameInHtml': '_Small_object_num_ptrs',
        'impls': [
            'NI$std::_Small_object_num_ptrs'
        ],
        'decls': []
    },
    'std::_Space_size': {
        'displayNameInHtml': '_Space_size',
        'impls': [
            'NI$std::_Space_size'
        ],
        'decls': []
    },
    'std::_Test_callable@bool(::std::function<[_Fty]> const &)': {
        'displayNameInHtml': '<span class="cpp_function">_Test_callable</span>&lt;<span class="cpp_type">_Fty</span>&gt;(<span class="cpp_type">function</span>&lt;<span class="cpp_type">_Fty</span>&gt;<span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]'
        ],
        'decls': []
    },
    'std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Arg': {
        'displayNameInHtml': '_Arg',
        'impls': [
            'NI$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Fty': {
        'displayNameInHtml': '<span class="cpp_type">_Fty</span>',
        'impls': [
            'TA$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Fty'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &)': {
        'displayNameInHtml': '<span class="cpp_function">_Test_callable</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::_Test_callable@bool([_Ty] const &)[impl0]'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &)[impl0]::_Arg': {
        'displayNameInHtml': '_Arg',
        'impls': [
            'NI$std::_Test_callable@bool([_Ty] const &)[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &)[impl0]::_Testable': {
        'displayNameInHtml': '_Testable',
        'impls': [
            'NI$std::_Test_callable@bool([_Ty] const &)[impl0]::_Testable'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::_Test_callable@bool([_Ty] const &)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &, ::std::false_type)': {
        'displayNameInHtml': '<span class="cpp_function">_Test_callable</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">false_type</span>)',
        'impls': [
            'FB$std::_Test_callable@bool([_Ty] const &, ::std::false_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &, ::std::false_type)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::_Test_callable@bool([_Ty] const &, ::std::false_type)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &, ::std::true_type)': {
        'displayNameInHtml': '<span class="cpp_function">_Test_callable</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">true_type</span>)',
        'impls': [
            'FB$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Arg': {
        'displayNameInHtml': '_Arg',
        'impls': [
            'NI$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::_Unfancy@[_Ty] *([_Ty] *)': {
        'displayNameInHtml': '<span class="cpp_function">_Unfancy</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span> *)',
        'impls': [
            'FB$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]'
        ],
        'decls': []
    },
    'std::_Unfancy@auto([_Ptrty])': {
        'displayNameInHtml': '<span class="cpp_function">_Unfancy</span>&lt;<span class="cpp_type">_Ptrty</span>&gt;(<span class="cpp_type">_Ptrty</span>)',
        'impls': [
            'FB$std::_Unfancy@auto([_Ptrty])[impl0]'
        ],
        'decls': []
    },
    'std::_Unforced': {
        'displayNameInHtml': '<span class="cpp_type">_Unforced</span>',
        'impls': [
            'NI$std::_Unforced'
        ],
        'decls': []
    },
    'std::_Weak_result_type': {
        'displayNameInHtml': '<span class="cpp_type">_Weak_result_type</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type"></span>&gt;',
        'impls': [
            'NI$std::_Weak_result_type'
        ],
        'decls': []
    },
    'std::_Weak_result_type@<[_Ty], ::std::void_t<result_type>>': {
        'displayNameInHtml': '<span class="cpp_type">_Weak_result_type</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">void_t</span>&lt;<span class="cpp_type">_Ty</span>::result_type&gt;&gt;',
        'impls': [
            'NI$std::_Weak_result_type@<[_Ty], ::std::void_t<result_type>>'
        ],
        'decls': []
    },
    'std::_Weak_types': {
        'displayNameInHtml': '<span class="cpp_type">_Weak_types</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::_Weak_types'
        ],
        'decls': []
    },
    'std::_Weak_types::type': {
        'displayNameInHtml': '<span class="cpp_type">_Weak_types</span>&lt;<span class="cpp_type">_Ty</span>&gt;::<span class="cpp_type">type</span>',
        'impls': [
            'NI$std::_Weak_types::type'
        ],
        'decls': []
    },
    'std::_Xbad_function_call@void()': {
        'displayNameInHtml': '<span class="cpp_function">_Xbad_function_call</span>()',
        'impls': [],
        'decls': [
            'FB$std::_Xbad_function_call@void()[decl0]'
        ]
    },
    'std::addressof@[_Ty] *([_Ty] &)': {
        'displayNameInHtml': '<span class="cpp_function">addressof</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span> &)',
        'impls': [
            'FB$std::addressof@[_Ty] *([_Ty] &)[impl0]'
        ],
        'decls': []
    },
    'std::addressof@[_Ty] const *([_Ty] const &&)': {
        'displayNameInHtml': '<span class="cpp_function">addressof</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span><span class="cpp_keyword"> const</span> &&)',
        'impls': [],
        'decls': [
            'FB$std::addressof@[_Ty] const *([_Ty] const &&)[decl0]'
        ]
    },
    'std::allocator_arg': {
        'displayNameInHtml': 'allocator_arg',
        'impls': [
            'NI$std::allocator_arg'
        ],
        'decls': []
    },
    'std::allocator_arg_t': {
        'displayNameInHtml': '<span class="cpp_type">allocator_arg_t</span>',
        'impls': [
            'NI$std::allocator_arg_t'
        ],
        'decls': []
    },
    'std::allocator_traits': {
        'displayNameInHtml': '<span class="cpp_type">allocator_traits</span>&lt;<span class="cpp_type">_Alloc</span>&gt;',
        'impls': [
            'NI$std::allocator_traits'
        ],
        'decls': [
            'NF[0]$std::allocator_traits'
        ]
    },
    'std::bad_function_call': {
        'displayNameInHtml': '<span class="cpp_type">bad_function_call</span>',
        'impls': [
            'NI$std::bad_function_call'
        ],
        'decls': []
    },
    'std::binary_function': {
        'displayNameInHtml': '<span class="cpp_type">binary_function</span>&lt;<span class="cpp_type">_Arg1</span>, <span class="cpp_type">_Arg2</span>, <span class="cpp_type">_Result</span>&gt;',
        'impls': [
            'NI$std::binary_function'
        ],
        'decls': []
    },
    'std::binary_negate': {
        'displayNameInHtml': '<span class="cpp_type">binary_negate</span>&lt;<span class="cpp_type">_Fn</span>&gt;',
        'impls': [
            'NI$std::binary_negate'
        ],
        'decls': []
    },
    'std::binary_negate::$__ctor@([_Fn] const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::binary_negate::$__ctor@([_Fn] const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::binary_negate::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::binary_negate::_Fn'
        ],
        'decls': []
    },
    'std::binary_negate::_Functor': {
        'displayNameInHtml': '<span class="cpp_type">binary_negate</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_field">_Functor</span>',
        'impls': [
            'NI$std::binary_negate::_Functor'
        ],
        'decls': []
    },
    'std::binary_negate::first_argument_type': {
        'displayNameInHtml': '<span class="cpp_type">binary_negate</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">first_argument_type</span>',
        'impls': [
            'NI$std::binary_negate::first_argument_type'
        ],
        'decls': []
    },
    'std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::binary_negate::second_argument_type': {
        'displayNameInHtml': '<span class="cpp_type">binary_negate</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">second_argument_type</span>',
        'impls': [
            'NI$std::binary_negate::second_argument_type'
        ],
        'decls': []
    },
    'std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'
        ],
        'decls': []
    },
    'std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn'
        ],
        'decls': []
    },
    'std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val': {
        'displayNameInHtml': '_Val',
        'impls': [
            'NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_function">bind</span>&lt;<span class="cpp_type">_Fx</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">_Fx</span> &&, <span class="cpp_type">_Types</span> &&...)',
        'impls': [
            'FB$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args': {
        'displayNameInHtml': '_Args',
        'impls': [
            'NI$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_function">bind</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">_Fx</span> &&, <span class="cpp_type">_Types</span> &&...)',
        'impls': [
            'FB$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args': {
        'displayNameInHtml': '_Args',
        'impls': [
            'NI$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Ret'
        ],
        'decls': []
    },
    'std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types'
        ],
        'decls': []
    },
    'std::binder1st': {
        'displayNameInHtml': '<span class="cpp_type">binder1st</span>&lt;<span class="cpp_type">_Fn</span>&gt;',
        'impls': [
            'NI$std::binder1st'
        ],
        'decls': []
    },
    'std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::binder1st::_Base': {
        'displayNameInHtml': '<span class="cpp_type">binder1st</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">_Base</span>',
        'impls': [
            'NI$std::binder1st::_Base'
        ],
        'decls': []
    },
    'std::binder1st::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::binder1st::_Fn'
        ],
        'decls': []
    },
    'std::binder1st::argument_type': {
        'displayNameInHtml': '<span class="cpp_type">binder1st</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">argument_type</span>',
        'impls': [
            'NI$std::binder1st::argument_type'
        ],
        'decls': []
    },
    'std::binder1st::op': {
        'displayNameInHtml': '<span class="cpp_type">binder1st</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_field">op</span>',
        'impls': [
            'NI$std::binder1st::op'
        ],
        'decls': []
    },
    'std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::binder1st::result_type': {
        'displayNameInHtml': '<span class="cpp_type">binder1st</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">result_type</span>',
        'impls': [
            'NI$std::binder1st::result_type'
        ],
        'decls': []
    },
    'std::binder1st::value': {
        'displayNameInHtml': '<span class="cpp_type">binder1st</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_field">value</span>',
        'impls': [
            'NI$std::binder1st::value'
        ],
        'decls': []
    },
    'std::binder2nd': {
        'displayNameInHtml': '<span class="cpp_type">binder2nd</span>&lt;<span class="cpp_type">_Fn</span>&gt;',
        'impls': [
            'NI$std::binder2nd'
        ],
        'decls': []
    },
    'std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::binder2nd::_Base': {
        'displayNameInHtml': '<span class="cpp_type">binder2nd</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">_Base</span>',
        'impls': [
            'NI$std::binder2nd::_Base'
        ],
        'decls': []
    },
    'std::binder2nd::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::binder2nd::_Fn'
        ],
        'decls': []
    },
    'std::binder2nd::argument_type': {
        'displayNameInHtml': '<span class="cpp_type">binder2nd</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">argument_type</span>',
        'impls': [
            'NI$std::binder2nd::argument_type'
        ],
        'decls': []
    },
    'std::binder2nd::op': {
        'displayNameInHtml': '<span class="cpp_type">binder2nd</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_field">op</span>',
        'impls': [
            'NI$std::binder2nd::op'
        ],
        'decls': []
    },
    'std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::binder2nd::result_type': {
        'displayNameInHtml': '<span class="cpp_type">binder2nd</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">result_type</span>',
        'impls': [
            'NI$std::binder2nd::result_type'
        ],
        'decls': []
    },
    'std::binder2nd::value': {
        'displayNameInHtml': '<span class="cpp_type">binder2nd</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_field">value</span>',
        'impls': [
            'NI$std::binder2nd::value'
        ],
        'decls': []
    },
    'std::bit_and': {
        'displayNameInHtml': '<span class="cpp_type">bit_and</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::bit_and'
        ],
        'decls': []
    },
    'std::bit_and::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::bit_and::_Ty'
        ],
        'decls': []
    },
    'std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::bit_and@<void>': {
        'displayNameInHtml': '<span class="cpp_type">bit_and</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::bit_and@<void>'
        ],
        'decls': []
    },
    'std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::bit_not': {
        'displayNameInHtml': '<span class="cpp_type">bit_not</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::bit_not'
        ],
        'decls': []
    },
    'std::bit_not::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::bit_not::_Ty'
        ],
        'decls': []
    },
    'std::bit_not::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bit_not::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bit_not@<void>': {
        'displayNameInHtml': '<span class="cpp_type">bit_not</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::bit_not@<void>'
        ],
        'decls': []
    },
    'std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::bit_or': {
        'displayNameInHtml': '<span class="cpp_type">bit_or</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::bit_or'
        ],
        'decls': []
    },
    'std::bit_or::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::bit_or::_Ty'
        ],
        'decls': []
    },
    'std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::bit_or@<void>': {
        'displayNameInHtml': '<span class="cpp_type">bit_or</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::bit_or@<void>'
        ],
        'decls': []
    },
    'std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::bit_xor': {
        'displayNameInHtml': '<span class="cpp_type">bit_xor</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::bit_xor'
        ],
        'decls': []
    },
    'std::bit_xor::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::bit_xor::_Ty'
        ],
        'decls': []
    },
    'std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::bit_xor@<void>': {
        'displayNameInHtml': '<span class="cpp_type">bit_xor</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::bit_xor@<void>'
        ],
        'decls': []
    },
    'std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::bool_constant': {
        'displayNameInHtml': '<span class="cpp_type">bool_constant</span>&lt;<span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::bool_constant'
        ],
        'decls': []
    },
    'std::conditional_t': {
        'displayNameInHtml': '<span class="cpp_type">conditional_t</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;',
        'impls': [
            'NI$std::conditional_t'
        ],
        'decls': []
    },
    'std::conjunction_v': {
        'displayNameInHtml': '<span class="cpp_enum">conjunction_v</span>&lt;<span class="cpp_type">_Traits</span> ...&gt;',
        'impls': [
            'NI$std::conjunction_v'
        ],
        'decls': []
    },
    'std::const_mem_fun1_ref_t': {
        'displayNameInHtml': '<span class="cpp_type">const_mem_fun1_ref_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Arg</span>&gt;',
        'impls': [
            'NI$std::const_mem_fun1_ref_t'
        ],
        'decls': []
    },
    'std::const_mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::const_mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::const_mem_fun1_ref_t::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::const_mem_fun1_ref_t::_Arg'
        ],
        'decls': []
    },
    'std::const_mem_fun1_ref_t::_Pmemfun': {
        'displayNameInHtml': '<span class="cpp_type">const_mem_fun1_ref_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Arg</span>&gt;::<span class="cpp_field">_Pmemfun</span>',
        'impls': [
            'NI$std::const_mem_fun1_ref_t::_Pmemfun'
        ],
        'decls': []
    },
    'std::const_mem_fun1_ref_t::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::const_mem_fun1_ref_t::_Result'
        ],
        'decls': []
    },
    'std::const_mem_fun1_ref_t::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::const_mem_fun1_ref_t::_Ty'
        ],
        'decls': []
    },
    'std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Left'
        ],
        'decls': []
    },
    'std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Right'
        ],
        'decls': []
    },
    'std::const_mem_fun1_t': {
        'displayNameInHtml': '<span class="cpp_type">const_mem_fun1_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Arg</span>&gt;',
        'impls': [
            'NI$std::const_mem_fun1_t'
        ],
        'decls': []
    },
    'std::const_mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::const_mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::const_mem_fun1_t::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::const_mem_fun1_t::_Arg'
        ],
        'decls': []
    },
    'std::const_mem_fun1_t::_Pmemfun': {
        'displayNameInHtml': '<span class="cpp_type">const_mem_fun1_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Arg</span>&gt;::<span class="cpp_field">_Pmemfun</span>',
        'impls': [
            'NI$std::const_mem_fun1_t::_Pmemfun'
        ],
        'decls': []
    },
    'std::const_mem_fun1_t::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::const_mem_fun1_t::_Result'
        ],
        'decls': []
    },
    'std::const_mem_fun1_t::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::const_mem_fun1_t::_Ty'
        ],
        'decls': []
    },
    'std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Pleft': {
        'displayNameInHtml': '_Pleft',
        'impls': [
            'NI$std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Pleft'
        ],
        'decls': []
    },
    'std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Right'
        ],
        'decls': []
    },
    'std::const_mem_fun_ref_t': {
        'displayNameInHtml': '<span class="cpp_type">const_mem_fun_ref_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::const_mem_fun_ref_t'
        ],
        'decls': []
    },
    'std::const_mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::const_mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::const_mem_fun_ref_t::_Pmemfun': {
        'displayNameInHtml': '<span class="cpp_type">const_mem_fun_ref_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>&gt;::<span class="cpp_field">_Pmemfun</span>',
        'impls': [
            'NI$std::const_mem_fun_ref_t::_Pmemfun'
        ],
        'decls': []
    },
    'std::const_mem_fun_ref_t::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::const_mem_fun_ref_t::_Result'
        ],
        'decls': []
    },
    'std::const_mem_fun_ref_t::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::const_mem_fun_ref_t::_Ty'
        ],
        'decls': []
    },
    'std::const_mem_fun_ref_t::operator ()@[_Result]([_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::const_mem_fun_ref_t::operator ()@[_Result]([_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::const_mem_fun_t': {
        'displayNameInHtml': '<span class="cpp_type">const_mem_fun_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::const_mem_fun_t'
        ],
        'decls': []
    },
    'std::const_mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::const_mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::const_mem_fun_t::_Pmemfun': {
        'displayNameInHtml': '<span class="cpp_type">const_mem_fun_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>&gt;::<span class="cpp_field">_Pmemfun</span>',
        'impls': [
            'NI$std::const_mem_fun_t::_Pmemfun'
        ],
        'decls': []
    },
    'std::const_mem_fun_t::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::const_mem_fun_t::_Result'
        ],
        'decls': []
    },
    'std::const_mem_fun_t::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::const_mem_fun_t::_Ty'
        ],
        'decls': []
    },
    'std::const_mem_fun_t::operator ()@[_Result]([_Ty] const *)[impl0]::_Pleft': {
        'displayNameInHtml': '_Pleft',
        'impls': [
            'NI$std::const_mem_fun_t::operator ()@[_Result]([_Ty] const *)[impl0]::_Pleft'
        ],
        'decls': []
    },
    'std::decay_t': {
        'displayNameInHtml': '<span class="cpp_type">decay_t</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::decay_t'
        ],
        'decls': []
    },
    'std::divides': {
        'displayNameInHtml': '<span class="cpp_type">divides</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::divides'
        ],
        'decls': []
    },
    'std::divides::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::divides::_Ty'
        ],
        'decls': []
    },
    'std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::divides@<void>': {
        'displayNameInHtml': '<span class="cpp_type">divides</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::divides@<void>'
        ],
        'decls': []
    },
    'std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::enable_if_t': {
        'displayNameInHtml': '<span class="cpp_type">enable_if_t</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::enable_if_t'
        ],
        'decls': []
    },
    'std::exception': {
        'displayNameInHtml': '<span class="cpp_type">exception</span>',
        'impls': [
            'NI$std::exception'
        ],
        'decls': []
    },
    'std::false_type': {
        'displayNameInHtml': '<span class="cpp_type">false_type</span>',
        'impls': [
            'NI$std::false_type'
        ],
        'decls': []
    },
    'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)': {
        'displayNameInHtml': '<span class="cpp_function">forward</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">remove_reference_t</span>&lt;<span class="cpp_type">_Ty</span>&gt; &&)',
        'impls': [
            'FB$std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)[impl0]'
        ],
        'decls': []
    },
    'std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)': {
        'displayNameInHtml': '<span class="cpp_function">forward</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">remove_reference_t</span>&lt;<span class="cpp_type">_Ty</span>&gt; &)',
        'impls': [
            'FB$std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)[impl0]'
        ],
        'decls': []
    },
    'std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_function">forward_as_tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">_Types</span> &&...)',
        'impls': [
            'FB$std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)[impl0]'
        ],
        'decls': []
    },
    'std::function': {
        'displayNameInHtml': '<span class="cpp_type">function</span>&lt;<span class="cpp_type">_Fty</span>&gt;',
        'impls': [
            'NI$std::function'
        ],
        'decls': [
            'NF[0]$std::function'
        ]
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Al': {
        'displayNameInHtml': '_Al',
        'impls': [
            'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Al'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Ax': {
        'displayNameInHtml': '_Ax',
        'impls': [
            'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Ax'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::nullptr_t)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::nullptr_t)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Ax': {
        'displayNameInHtml': '_Ax',
        'impls': [
            'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Ax'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Func'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::function &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::function::$__ctor@(::std::function &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::function::$__ctor@(::std::function const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::function::$__ctor@(::std::function const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::function::$__ctor@([_Fx])[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::function::$__ctor@([_Fx])[impl0]::_Func'
        ],
        'decls': []
    },
    'std::function::$__ctor@([_Fx])[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::function::$__ctor@([_Fx])[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::function::_Fty2': {
        'displayNameInHtml': '<span class="cpp_type">_Fty</span>',
        'impls': [
            'TA$std::function::_Fty2'
        ],
        'decls': []
    },
    'std::function::_Mybase': {
        'displayNameInHtml': '<span class="cpp_type">function</span>&lt;<span class="cpp_type">_Fty</span>&gt;::<span class="cpp_type">_Mybase</span>',
        'impls': [
            'NI$std::function::_Mybase'
        ],
        'decls': []
    },
    'std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc'
        ],
        'decls': []
    },
    'std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax': {
        'displayNameInHtml': '_Ax',
        'impls': [
            'NI$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax'
        ],
        'decls': []
    },
    'std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::function::operator =@::std::function &(::std::function &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::function::operator =@::std::function &(::std::function &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::function::operator =@::std::function &(::std::function const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::function::operator =@::std::function &(::std::function const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::function::swap@void(::std::function &)': {
        'displayNameInHtml': '<span class="cpp_type">function</span>&lt;<span class="cpp_type">_Fty</span>&gt;::<span class="cpp_function">swap</span>(<span class="cpp_type">function</span>&lt;<span class="cpp_type">_Fty</span>&gt; &)',
        'impls': [
            'FB$std::function::swap@void(::std::function &)[impl0]'
        ],
        'decls': []
    },
    'std::function::swap@void(::std::function &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::function::swap@void(::std::function &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::function::target@[_Fx] *()[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::function::target@[_Fx] *()[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::function::target@[_Fx] const *()[impl0]::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::function::target@[_Fx] const *()[impl0]::_Fx'
        ],
        'decls': []
    },
    'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt; &&)',
        'impls': [
            'FB$std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt; &)',
        'impls': [
            'FB$std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)[impl0]'
        ],
        'decls': []
    },
    'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;<span class="cpp_keyword"> const</span> &&)',
        'impls': [
            'FB$std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;<span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)[impl0]'
        ],
        'decls': []
    },
    'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt; &&)',
        'impls': [
            'FB$std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt; &)',
        'impls': [
            'FB$std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)[impl0]'
        ],
        'decls': []
    },
    'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt;<span class="cpp_keyword"> const</span> &&)',
        'impls': [
            'FB$std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt;<span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt; &&)',
        'impls': [
            'FB$std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt; &)',
        'impls': [
            'FB$std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;<span class="cpp_keyword"> const</span> &&)',
        'impls': [
            'FB$std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;<span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty2</span>, <span class="cpp_type">_Ty1</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt; &&)',
        'impls': [
            'FB$std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty2</span>, <span class="cpp_type">_Ty1</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt; &)',
        'impls': [
            'FB$std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty2</span>, <span class="cpp_type">_Ty1</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;<span class="cpp_keyword"> const</span> &&)',
        'impls': [
            'FB$std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty2</span>, <span class="cpp_type">_Ty1</span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;<span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty] &&(::std::array<[_Ty], *> &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;(<span class="cpp_type">array</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt; &&)',
        'impls': [],
        'decls': [
            'FB$std::get@[_Ty] &&(::std::array<[_Ty], *> &&)[decl0]'
        ]
    },
    'std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt; &&)',
        'impls': [
            'FB$std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty] &(::std::array<[_Ty], *> &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;(<span class="cpp_type">array</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt; &)',
        'impls': [],
        'decls': [
            'FB$std::get@[_Ty] &(::std::array<[_Ty], *> &)[decl0]'
        ]
    },
    'std::get@[_Ty] &(::std::tuple<[_Types]...> &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt; &)',
        'impls': [
            'FB$std::get@[_Ty] &(::std::tuple<[_Types]...> &)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;(<span class="cpp_type">array</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;<span class="cpp_keyword"> const</span> &&)',
        'impls': [],
        'decls': [
            'FB$std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)[decl0]'
        ]
    },
    'std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt;<span class="cpp_keyword"> const</span> &&)',
        'impls': [
            'FB$std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)[impl0]'
        ],
        'decls': []
    },
    'std::get@[_Ty] const &(::std::array<[_Ty], *> const &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_keyword">(expr)</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;(<span class="cpp_type">array</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;<span class="cpp_keyword"> const</span> &)',
        'impls': [],
        'decls': [
            'FB$std::get@[_Ty] const &(::std::array<[_Ty], *> const &)[decl0]'
        ]
    },
    'std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)': {
        'displayNameInHtml': '<span class="cpp_function">get</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt;<span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)[impl0]'
        ],
        'decls': []
    },
    'std::index_sequence': {
        'displayNameInHtml': '<span class="cpp_type">index_sequence</span>&lt;<span class="cpp_keyword">(expr)</span> ...&gt;',
        'impls': [
            'NI$std::index_sequence'
        ],
        'decls': []
    },
    'std::index_sequence_for': {
        'displayNameInHtml': '<span class="cpp_type">index_sequence_for</span>&lt;<span class="cpp_type">_Types</span> ...&gt;',
        'impls': [
            'NI$std::index_sequence_for'
        ],
        'decls': []
    },
    'std::integral_constant': {
        'displayNameInHtml': '<span class="cpp_type">integral_constant</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::integral_constant'
        ],
        'decls': []
    },
    'std::integral_constant::type': {
        'displayNameInHtml': '<span class="cpp_type">integral_constant</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_type">type</span>',
        'impls': [
            'NI$std::integral_constant::type'
        ],
        'decls': []
    },
    'std::integral_constant::value': {
        'displayNameInHtml': '<span class="cpp_type">integral_constant</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>&gt;::<span class="cpp_field">value</span>',
        'impls': [
            'NI$std::integral_constant::value'
        ],
        'decls': []
    },
    'std::invoke@decltype(*)([_Callable] &&, [_Types] &&...)': {
        'displayNameInHtml': '<span class="cpp_function">invoke</span>&lt;<span class="cpp_type">_Callable</span>, <span class="cpp_type">_Types</span> ...&gt;(<span class="cpp_type">_Callable</span> &&, <span class="cpp_type">_Types</span> &&...)',
        'impls': [
            'FB$std::invoke@decltype(*)([_Callable] &&, [_Types] &&...)[impl0]'
        ],
        'decls': [
            'FB$std::invoke@decltype(*)([_Callable] &&, [_Types] &&...)[decl0]'
        ]
    },
    'std::is_bind_expression': {
        'displayNameInHtml': '<span class="cpp_type">is_bind_expression</span>&lt;<span class="cpp_type">_Tx</span>&gt;',
        'impls': [
            'NI$std::is_bind_expression'
        ],
        'decls': []
    },
    'std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>': {
        'displayNameInHtml': '<span class="cpp_type">is_bind_expression</span>&lt;<span class="cpp_type">_Binder</span>&lt;<span class="cpp_type">_Ret</span>, <span class="cpp_type">_Fx</span>, <span class="cpp_type">_Types</span> ...&gt;&gt;',
        'impls': [
            'NI$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>'
        ],
        'decls': []
    },
    'std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Fx': {
        'displayNameInHtml': '<span class="cpp_type">_Fx</span>',
        'impls': [
            'TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Fx'
        ],
        'decls': []
    },
    'std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Ret': {
        'displayNameInHtml': '<span class="cpp_type">_Ret</span>',
        'impls': [
            'TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Ret'
        ],
        'decls': []
    },
    'std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Types': {
        'displayNameInHtml': '<span class="cpp_type">_Types</span>',
        'impls': [
            'TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Types'
        ],
        'decls': []
    },
    'std::is_bind_expression@<[_Tx] const volatile>': {
        'displayNameInHtml': '<span class="cpp_type">is_bind_expression</span>&lt;<span class="cpp_type">_Tx</span><span class="cpp_keyword"> const</span><span class="cpp_keyword"> volatile</span>&gt;',
        'impls': [
            'NI$std::is_bind_expression@<[_Tx] const volatile>'
        ],
        'decls': []
    },
    'std::is_bind_expression@<[_Tx] const volatile>::_Tx': {
        'displayNameInHtml': '<span class="cpp_type">_Tx</span>',
        'impls': [
            'TA$std::is_bind_expression@<[_Tx] const volatile>::_Tx'
        ],
        'decls': []
    },
    'std::is_bind_expression@<[_Tx] const>': {
        'displayNameInHtml': '<span class="cpp_type">is_bind_expression</span>&lt;<span class="cpp_type">_Tx</span><span class="cpp_keyword"> const</span>&gt;',
        'impls': [
            'NI$std::is_bind_expression@<[_Tx] const>'
        ],
        'decls': []
    },
    'std::is_bind_expression@<[_Tx] const>::_Tx': {
        'displayNameInHtml': '<span class="cpp_type">_Tx</span>',
        'impls': [
            'TA$std::is_bind_expression@<[_Tx] const>::_Tx'
        ],
        'decls': []
    },
    'std::is_bind_expression@<[_Tx] volatile>': {
        'displayNameInHtml': '<span class="cpp_type">is_bind_expression</span>&lt;<span class="cpp_type">_Tx</span><span class="cpp_keyword"> volatile</span>&gt;',
        'impls': [
            'NI$std::is_bind_expression@<[_Tx] volatile>'
        ],
        'decls': []
    },
    'std::is_bind_expression@<[_Tx] volatile>::_Tx': {
        'displayNameInHtml': '<span class="cpp_type">_Tx</span>',
        'impls': [
            'TA$std::is_bind_expression@<[_Tx] volatile>::_Tx'
        ],
        'decls': []
    },
    'std::is_bind_expression_v': {
        'displayNameInHtml': '<span class="cpp_enum">is_bind_expression_v</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::is_bind_expression_v'
        ],
        'decls': []
    },
    'std::is_bind_expression_v::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::is_bind_expression_v::_Ty'
        ],
        'decls': []
    },
    'std::is_function_v': {
        'displayNameInHtml': '<span class="cpp_enum">is_function_v</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::is_function_v'
        ],
        'decls': []
    },
    'std::is_member_pointer_v': {
        'displayNameInHtml': '<span class="cpp_enum">is_member_pointer_v</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::is_member_pointer_v'
        ],
        'decls': []
    },
    'std::is_nothrow_move_constructible': {
        'displayNameInHtml': '<span class="cpp_type">is_nothrow_move_constructible</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::is_nothrow_move_constructible'
        ],
        'decls': []
    },
    'std::is_placeholder': {
        'displayNameInHtml': '<span class="cpp_type">is_placeholder</span>&lt;<span class="cpp_type">_Tx</span>&gt;',
        'impls': [
            'NI$std::is_placeholder'
        ],
        'decls': []
    },
    'std::is_placeholder@<::std::_Ph<*>>': {
        'displayNameInHtml': '<span class="cpp_type">is_placeholder</span>&lt;<span class="cpp_type">_Ph</span>&lt;<span class="cpp_keyword">(expr)</span>&gt;&gt;',
        'impls': [
            'NI$std::is_placeholder@<::std::_Ph<*>>'
        ],
        'decls': []
    },
    'std::is_placeholder@<::std::_Ph<*>>::_Nx': {
        'displayNameInHtml': '_Nx',
        'impls': [
            'TA$std::is_placeholder@<::std::_Ph<*>>::_Nx'
        ],
        'decls': []
    },
    'std::is_placeholder@<[_Tx] const volatile>': {
        'displayNameInHtml': '<span class="cpp_type">is_placeholder</span>&lt;<span class="cpp_type">_Tx</span><span class="cpp_keyword"> const</span><span class="cpp_keyword"> volatile</span>&gt;',
        'impls': [
            'NI$std::is_placeholder@<[_Tx] const volatile>'
        ],
        'decls': []
    },
    'std::is_placeholder@<[_Tx] const volatile>::_Tx': {
        'displayNameInHtml': '<span class="cpp_type">_Tx</span>',
        'impls': [
            'TA$std::is_placeholder@<[_Tx] const volatile>::_Tx'
        ],
        'decls': []
    },
    'std::is_placeholder@<[_Tx] const>': {
        'displayNameInHtml': '<span class="cpp_type">is_placeholder</span>&lt;<span class="cpp_type">_Tx</span><span class="cpp_keyword"> const</span>&gt;',
        'impls': [
            'NI$std::is_placeholder@<[_Tx] const>'
        ],
        'decls': []
    },
    'std::is_placeholder@<[_Tx] const>::_Tx': {
        'displayNameInHtml': '<span class="cpp_type">_Tx</span>',
        'impls': [
            'TA$std::is_placeholder@<[_Tx] const>::_Tx'
        ],
        'decls': []
    },
    'std::is_placeholder@<[_Tx] volatile>': {
        'displayNameInHtml': '<span class="cpp_type">is_placeholder</span>&lt;<span class="cpp_type">_Tx</span><span class="cpp_keyword"> volatile</span>&gt;',
        'impls': [
            'NI$std::is_placeholder@<[_Tx] volatile>'
        ],
        'decls': []
    },
    'std::is_placeholder@<[_Tx] volatile>::_Tx': {
        'displayNameInHtml': '<span class="cpp_type">_Tx</span>',
        'impls': [
            'TA$std::is_placeholder@<[_Tx] volatile>::_Tx'
        ],
        'decls': []
    },
    'std::is_placeholder_v': {
        'displayNameInHtml': '<span class="cpp_enum">is_placeholder_v</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::is_placeholder_v'
        ],
        'decls': []
    },
    'std::is_placeholder_v::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::is_placeholder_v::_Ty'
        ],
        'decls': []
    },
    'std::is_pointer_v': {
        'displayNameInHtml': '<span class="cpp_enum">is_pointer_v</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::is_pointer_v'
        ],
        'decls': []
    },
    'std::is_same': {
        'displayNameInHtml': '<span class="cpp_type">is_same</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt;',
        'impls': [
            'NI$std::is_same'
        ],
        'decls': []
    },
    'std::is_same@<[_Ty1], [_Ty1]>': {
        'displayNameInHtml': '<span class="cpp_type">is_same</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty1</span>&gt;',
        'impls': [
            'NI$std::is_same@<[_Ty1], [_Ty1]>'
        ],
        'decls': []
    },
    'std::is_same_v': {
        'displayNameInHtml': '<span class="cpp_enum">is_same_v</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Uty</span>&gt;',
        'impls': [
            'NI$std::is_same_v'
        ],
        'decls': []
    },
    'std::logical_and': {
        'displayNameInHtml': '<span class="cpp_type">logical_and</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::logical_and'
        ],
        'decls': []
    },
    'std::logical_and::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::logical_and::_Ty'
        ],
        'decls': []
    },
    'std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::logical_and@<void>': {
        'displayNameInHtml': '<span class="cpp_type">logical_and</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::logical_and@<void>'
        ],
        'decls': []
    },
    'std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::logical_not': {
        'displayNameInHtml': '<span class="cpp_type">logical_not</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::logical_not'
        ],
        'decls': []
    },
    'std::logical_not::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::logical_not::_Ty'
        ],
        'decls': []
    },
    'std::logical_not::operator ()@bool([_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::logical_not::operator ()@bool([_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::logical_not@<void>': {
        'displayNameInHtml': '<span class="cpp_type">logical_not</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::logical_not@<void>'
        ],
        'decls': []
    },
    'std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::logical_or': {
        'displayNameInHtml': '<span class="cpp_type">logical_or</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::logical_or'
        ],
        'decls': []
    },
    'std::logical_or::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::logical_or::_Ty'
        ],
        'decls': []
    },
    'std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::logical_or@<void>': {
        'displayNameInHtml': '<span class="cpp_type">logical_or</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::logical_or@<void>'
        ],
        'decls': []
    },
    'std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::make_index_sequence': {
        'displayNameInHtml': '<span class="cpp_type">make_index_sequence</span>&lt;<span class="cpp_keyword">(expr)</span>&gt;',
        'impls': [
            'NI$std::make_index_sequence'
        ],
        'decls': []
    },
    'std::max_align_t': {
        'displayNameInHtml': '<span class="cpp_type">max_align_t</span>',
        'impls': [
            'NI$std::max_align_t'
        ],
        'decls': []
    },
    'std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)': {
        'displayNameInHtml': '<span class="cpp_function">mem_fn</span>&lt;<span class="cpp_type">_Rx</span>, <span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Rx</span> <span class="cpp_type">_Ty</span>:: *)',
        'impls': [
            'FB$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]'
        ],
        'decls': []
    },
    'std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Rx': {
        'displayNameInHtml': '<span class="cpp_type">_Rx</span>',
        'impls': [
            'TA$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Rx'
        ],
        'decls': []
    },
    'std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun1_ref_t': {
        'displayNameInHtml': '<span class="cpp_type">mem_fun1_ref_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Arg</span>&gt;',
        'impls': [
            'NI$std::mem_fun1_ref_t'
        ],
        'decls': []
    },
    'std::mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun1_ref_t::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::mem_fun1_ref_t::_Arg'
        ],
        'decls': []
    },
    'std::mem_fun1_ref_t::_Pmemfun': {
        'displayNameInHtml': '<span class="cpp_type">mem_fun1_ref_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Arg</span>&gt;::<span class="cpp_field">_Pmemfun</span>',
        'impls': [
            'NI$std::mem_fun1_ref_t::_Pmemfun'
        ],
        'decls': []
    },
    'std::mem_fun1_ref_t::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun1_ref_t::_Result'
        ],
        'decls': []
    },
    'std::mem_fun1_ref_t::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun1_ref_t::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Left'
        ],
        'decls': []
    },
    'std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Right'
        ],
        'decls': []
    },
    'std::mem_fun1_t': {
        'displayNameInHtml': '<span class="cpp_type">mem_fun1_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Arg</span>&gt;',
        'impls': [
            'NI$std::mem_fun1_t'
        ],
        'decls': []
    },
    'std::mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun1_t::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::mem_fun1_t::_Arg'
        ],
        'decls': []
    },
    'std::mem_fun1_t::_Pmemfun': {
        'displayNameInHtml': '<span class="cpp_type">mem_fun1_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Arg</span>&gt;::<span class="cpp_field">_Pmemfun</span>',
        'impls': [
            'NI$std::mem_fun1_t::_Pmemfun'
        ],
        'decls': []
    },
    'std::mem_fun1_t::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun1_t::_Result'
        ],
        'decls': []
    },
    'std::mem_fun1_t::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun1_t::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Pleft': {
        'displayNameInHtml': '_Pleft',
        'impls': [
            'NI$std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Pleft'
        ],
        'decls': []
    },
    'std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Right'
        ],
        'decls': []
    },
    'std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun_ref_t': {
        'displayNameInHtml': '<span class="cpp_type">mem_fun_ref_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::mem_fun_ref_t'
        ],
        'decls': []
    },
    'std::mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun_ref_t::_Pmemfun': {
        'displayNameInHtml': '<span class="cpp_type">mem_fun_ref_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>&gt;::<span class="cpp_field">_Pmemfun</span>',
        'impls': [
            'NI$std::mem_fun_ref_t::_Pmemfun'
        ],
        'decls': []
    },
    'std::mem_fun_ref_t::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun_ref_t::_Result'
        ],
        'decls': []
    },
    'std::mem_fun_ref_t::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun_ref_t::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun_ref_t::operator ()@[_Result]([_Ty] &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::mem_fun_ref_t::operator ()@[_Result]([_Ty] &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::mem_fun_t': {
        'displayNameInHtml': '<span class="cpp_type">mem_fun_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::mem_fun_t'
        ],
        'decls': []
    },
    'std::mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm': {
        'displayNameInHtml': '_Pm',
        'impls': [
            'NI$std::mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm'
        ],
        'decls': []
    },
    'std::mem_fun_t::_Pmemfun': {
        'displayNameInHtml': '<span class="cpp_type">mem_fun_t</span>&lt;<span class="cpp_type">_Result</span>, <span class="cpp_type">_Ty</span>&gt;::<span class="cpp_field">_Pmemfun</span>',
        'impls': [
            'NI$std::mem_fun_t::_Pmemfun'
        ],
        'decls': []
    },
    'std::mem_fun_t::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::mem_fun_t::_Result'
        ],
        'decls': []
    },
    'std::mem_fun_t::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::mem_fun_t::_Ty'
        ],
        'decls': []
    },
    'std::mem_fun_t::operator ()@[_Result]([_Ty] *)[impl0]::_Pleft': {
        'displayNameInHtml': '_Pleft',
        'impls': [
            'NI$std::mem_fun_t::operator ()@[_Result]([_Ty] *)[impl0]::_Pleft'
        ],
        'decls': []
    },
    'std::modulus': {
        'displayNameInHtml': '<span class="cpp_type">modulus</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::modulus'
        ],
        'decls': []
    },
    'std::modulus::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::modulus::_Ty'
        ],
        'decls': []
    },
    'std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::modulus@<void>': {
        'displayNameInHtml': '<span class="cpp_type">modulus</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::modulus@<void>'
        ],
        'decls': []
    },
    'std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': {
        'displayNameInHtml': '<span class="cpp_type">_Ty1</span>',
        'impls': [
            'TA$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1'
        ],
        'decls': []
    },
    'std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': {
        'displayNameInHtml': '<span class="cpp_type">_Ty2</span>',
        'impls': [
            'TA$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2'
        ],
        'decls': []
    },
    'std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)': {
        'displayNameInHtml': '<span class="cpp_function">move</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">_Ty</span> &&)',
        'impls': [
            'FB$std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)[impl0]'
        ],
        'decls': []
    },
    'std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])': {
        'displayNameInHtml': '<span class="cpp_function">move</span>&lt;<span class="cpp_type">_InIt</span>, <span class="cpp_type">_OutIt</span>&gt;(<span class="cpp_type">_InIt</span>, <span class="cpp_type">_InIt</span>, <span class="cpp_type">_OutIt</span>)',
        'impls': [
            'FB$std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])[impl0]'
        ],
        'decls': []
    },
    'std::negate': {
        'displayNameInHtml': '<span class="cpp_type">negate</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::negate'
        ],
        'decls': []
    },
    'std::negate::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::negate::_Ty'
        ],
        'decls': []
    },
    'std::negate::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::negate::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::negate@<void>': {
        'displayNameInHtml': '<span class="cpp_type">negate</span>&lt;<span class="cpp_keyword">void</span>&gt;',
        'impls': [
            'NI$std::negate@<void>'
        ],
        'decls': []
    },
    'std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty': {
        'displayNameInHtml': '<span class="cpp_type">_Ty</span>',
        'impls': [
            'TA$std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty'
        ],
        'decls': []
    },
    'std::negation': {
        'displayNameInHtml': '<span class="cpp_type">negation</span>&lt;<span class="cpp_type">_Trait</span>&gt;',
        'impls': [
            'NI$std::negation'
        ],
        'decls': []
    },
    'std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn'
        ],
        'decls': []
    },
    'std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn'
        ],
        'decls': []
    },
    'std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::nullptr_t': {
        'displayNameInHtml': '<span class="cpp_type">nullptr_t</span>',
        'impls': [
            'NI$std::nullptr_t'
        ],
        'decls': []
    },
    'std::operator !=@bool(::std::error_code const &, ::std::error_code const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator !=</span>(<span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator !=@bool(::std::error_code const &, ::std::error_code const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator !=@bool(::std::error_code const &, ::std::error_condition const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator !=</span>(<span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator !=@bool(::std::error_code const &, ::std::error_condition const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator !=@bool(::std::error_condition const &, ::std::error_code const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator !=</span>(<span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator !=@bool(::std::error_condition const &, ::std::error_code const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator !=@bool(::std::error_condition const &, ::std::error_condition const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator !=</span>(<span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator !=@bool(::std::error_condition const &, ::std::error_condition const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty': {
        'displayNameInHtml': '<span class="cpp_type">_Fty</span>',
        'impls': [
            'TA$std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty'
        ],
        'decls': []
    },
    'std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other': {
        'displayNameInHtml': '_Other',
        'impls': [
            'NI$std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other'
        ],
        'decls': []
    },
    'std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty': {
        'displayNameInHtml': '<span class="cpp_type">_Fty</span>',
        'impls': [
            'TA$std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty'
        ],
        'decls': []
    },
    'std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other': {
        'displayNameInHtml': '_Other',
        'impls': [
            'NI$std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other'
        ],
        'decls': []
    },
    'std::operator <@bool(::std::error_code const &, ::std::error_code const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator &lt;</span>(<span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator <@bool(::std::error_code const &, ::std::error_code const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator <@bool(::std::error_condition const &, ::std::error_condition const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator &lt;</span>(<span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator <@bool(::std::error_condition const &, ::std::error_condition const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator ==@bool(::std::error_code const &, ::std::error_code const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator ==</span>(<span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator ==@bool(::std::error_code const &, ::std::error_code const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator ==@bool(::std::error_code const &, ::std::error_condition const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator ==</span>(<span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator ==@bool(::std::error_code const &, ::std::error_condition const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator ==@bool(::std::error_condition const &, ::std::error_code const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator ==</span>(<span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_code</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator ==@bool(::std::error_condition const &, ::std::error_code const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator ==@bool(::std::error_condition const &, ::std::error_condition const &)': {
        'displayNameInHtml': '<span class="cpp_function">operator ==</span>(<span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &, <span class="cpp_type">error_condition</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$std::operator ==@bool(::std::error_condition const &, ::std::error_condition const &)[impl0]'
        ],
        'decls': []
    },
    'std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty': {
        'displayNameInHtml': '<span class="cpp_type">_Fty</span>',
        'impls': [
            'TA$std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty'
        ],
        'decls': []
    },
    'std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other': {
        'displayNameInHtml': '_Other',
        'impls': [
            'NI$std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other'
        ],
        'decls': []
    },
    'std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty': {
        'displayNameInHtml': '<span class="cpp_type">_Fty</span>',
        'impls': [
            'TA$std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty'
        ],
        'decls': []
    },
    'std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other': {
        'displayNameInHtml': '_Other',
        'impls': [
            'NI$std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other'
        ],
        'decls': []
    },
    'std::placeholders': {
        'displayNameInHtml': 'std::placeholders',
        'impls': [],
        'decls': [
            'NF[0]$std::placeholders'
        ]
    },
    'std::pointer_to_binary_function': {
        'displayNameInHtml': '<span class="cpp_type">pointer_to_binary_function</span>&lt;<span class="cpp_type">_Arg1</span>, <span class="cpp_type">_Arg2</span>, <span class="cpp_type">_Result</span>, <span class="cpp_type">_Fn</span>&gt;',
        'impls': [
            'NI$std::pointer_to_binary_function'
        ],
        'decls': []
    },
    'std::pointer_to_binary_function::$__ctor@([_Fn])[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::pointer_to_binary_function::$__ctor@([_Fn])[impl0]::_Left'
        ],
        'decls': []
    },
    'std::pointer_to_binary_function::_Arg1': {
        'displayNameInHtml': '<span class="cpp_type">_Arg1</span>',
        'impls': [
            'TA$std::pointer_to_binary_function::_Arg1'
        ],
        'decls': []
    },
    'std::pointer_to_binary_function::_Arg2': {
        'displayNameInHtml': '<span class="cpp_type">_Arg2</span>',
        'impls': [
            'TA$std::pointer_to_binary_function::_Arg2'
        ],
        'decls': []
    },
    'std::pointer_to_binary_function::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::pointer_to_binary_function::_Fn'
        ],
        'decls': []
    },
    'std::pointer_to_binary_function::_Pfun': {
        'displayNameInHtml': '<span class="cpp_type">pointer_to_binary_function</span>&lt;<span class="cpp_type">_Arg1</span>, <span class="cpp_type">_Arg2</span>, <span class="cpp_type">_Result</span>, <span class="cpp_type">_Fn</span>&gt;::<span class="cpp_field">_Pfun</span>',
        'impls': [
            'NI$std::pointer_to_binary_function::_Pfun'
        ],
        'decls': []
    },
    'std::pointer_to_binary_function::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::pointer_to_binary_function::_Result'
        ],
        'decls': []
    },
    'std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Left'
        ],
        'decls': []
    },
    'std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Right'
        ],
        'decls': []
    },
    'std::pointer_to_unary_function': {
        'displayNameInHtml': '<span class="cpp_type">pointer_to_unary_function</span>&lt;<span class="cpp_type">_Arg</span>, <span class="cpp_type">_Result</span>, <span class="cpp_type">_Fn</span>&gt;',
        'impls': [
            'NI$std::pointer_to_unary_function'
        ],
        'decls': []
    },
    'std::pointer_to_unary_function::$__ctor@([_Fn])[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::pointer_to_unary_function::$__ctor@([_Fn])[impl0]::_Left'
        ],
        'decls': []
    },
    'std::pointer_to_unary_function::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::pointer_to_unary_function::_Arg'
        ],
        'decls': []
    },
    'std::pointer_to_unary_function::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::pointer_to_unary_function::_Fn'
        ],
        'decls': []
    },
    'std::pointer_to_unary_function::_Pfun': {
        'displayNameInHtml': '<span class="cpp_type">pointer_to_unary_function</span>&lt;<span class="cpp_type">_Arg</span>, <span class="cpp_type">_Result</span>, <span class="cpp_type">_Fn</span>&gt;::<span class="cpp_field">_Pfun</span>',
        'impls': [
            'NI$std::pointer_to_unary_function::_Pfun'
        ],
        'decls': []
    },
    'std::pointer_to_unary_function::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::pointer_to_unary_function::_Result'
        ],
        'decls': []
    },
    'std::pointer_to_unary_function::operator ()@[_Result]([_Arg])[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::pointer_to_unary_function::operator ()@[_Result]([_Arg])[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1': {
        'displayNameInHtml': '<span class="cpp_type">_Arg1</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2': {
        'displayNameInHtml': '<span class="cpp_type">_Arg2</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1': {
        'displayNameInHtml': '<span class="cpp_type">_Arg1</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2': {
        'displayNameInHtml': '<span class="cpp_type">_Arg2</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1': {
        'displayNameInHtml': '<span class="cpp_type">_Arg1</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2': {
        'displayNameInHtml': '<span class="cpp_type">_Arg2</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1': {
        'displayNameInHtml': '<span class="cpp_type">_Arg1</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2': {
        'displayNameInHtml': '<span class="cpp_type">_Arg2</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg': {
        'displayNameInHtml': '<span class="cpp_type">_Arg</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result': {
        'displayNameInHtml': '<span class="cpp_type">_Result</span>',
        'impls': [
            'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result'
        ],
        'decls': []
    },
    'std::reference_wrapper': {
        'displayNameInHtml': '<span class="cpp_type">reference_wrapper</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::reference_wrapper'
        ],
        'decls': [
            'NF[0]$std::reference_wrapper'
        ]
    },
    'std::remove_cv_t': {
        'displayNameInHtml': '<span class="cpp_type">remove_cv_t</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::remove_cv_t'
        ],
        'decls': []
    },
    'std::remove_pointer_t': {
        'displayNameInHtml': '<span class="cpp_type">remove_pointer_t</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::remove_pointer_t'
        ],
        'decls': []
    },
    'std::swap@void(::std::_Vb_reference<[_Alvbase_wrapped]>, ::std::_Vb_reference<[_Alvbase_wrapped]>)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Alvbase_wrapped</span>&gt;(<span class="cpp_type">_Vb_reference</span>&lt;<span class="cpp_type">_Alvbase_wrapped</span>&gt;, <span class="cpp_type">_Vb_reference</span>&lt;<span class="cpp_type">_Alvbase_wrapped</span>&gt;)',
        'impls': [
            'FB$std::swap@void(::std::_Vb_reference<[_Alvbase_wrapped]>, ::std::_Vb_reference<[_Alvbase_wrapped]>)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::basic_string<[_Elem], [_Traits], [_Alloc]> &, ::std::basic_string<[_Elem], [_Traits], [_Alloc]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Elem</span>, <span class="cpp_type">_Traits</span>, <span class="cpp_type">_Alloc</span>&gt;(<span class="cpp_type">basic_string</span>&lt;<span class="cpp_type">_Elem</span>, <span class="cpp_type">_Traits</span>, <span class="cpp_type">_Alloc</span>&gt; &, <span class="cpp_type">basic_string</span>&lt;<span class="cpp_type">_Elem</span>, <span class="cpp_type">_Traits</span>, <span class="cpp_type">_Alloc</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::basic_string<[_Elem], [_Traits], [_Alloc]> &, ::std::basic_string<[_Elem], [_Traits], [_Alloc]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::exception_ptr &, ::std::exception_ptr &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>(<span class="cpp_type">exception_ptr</span> &, <span class="cpp_type">exception_ptr</span> &)',
        'impls': [
            'FB$std::swap@void(::std::exception_ptr &, ::std::exception_ptr &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Fty</span>&gt;(<span class="cpp_type">function</span>&lt;<span class="cpp_type">_Fty</span>&gt; &, <span class="cpp_type">function</span>&lt;<span class="cpp_type">_Fty</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Fty': {
        'displayNameInHtml': '<span class="cpp_type">_Fty</span>',
        'impls': [
            'TA$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Fty'
        ],
        'decls': []
    },
    'std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Right': {
        'displayNameInHtml': '_Right',
        'impls': [
            'NI$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Right'
        ],
        'decls': []
    },
    'std::swap@void(::std::map<[_Kty], [_Ty], [_Pr], [_Alloc]> &, ::std::map<[_Kty], [_Ty], [_Pr], [_Alloc]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt;(<span class="cpp_type">map</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt; &, <span class="cpp_type">map</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::map<[_Kty], [_Ty], [_Pr], [_Alloc]> &, ::std::map<[_Kty], [_Ty], [_Pr], [_Alloc]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::multimap<[_Kty], [_Ty], [_Pr], [_Alloc]> &, ::std::multimap<[_Kty], [_Ty], [_Pr], [_Alloc]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt;(<span class="cpp_type">multimap</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt; &, <span class="cpp_type">multimap</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Ty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::multimap<[_Kty], [_Ty], [_Pr], [_Alloc]> &, ::std::multimap<[_Kty], [_Ty], [_Pr], [_Alloc]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::multiset<[_Kty], [_Pr], [_Alloc]> &, ::std::multiset<[_Kty], [_Pr], [_Alloc]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt;(<span class="cpp_type">multiset</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt; &, <span class="cpp_type">multiset</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::multiset<[_Kty], [_Pr], [_Alloc]> &, ::std::multiset<[_Kty], [_Pr], [_Alloc]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::pair<[_Ty1], [_Ty2]> &, ::std::pair<[_Ty1], [_Ty2]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>, <span class="cpp_type"></span>&gt;(<span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt; &, <span class="cpp_type">pair</span>&lt;<span class="cpp_type">_Ty1</span>, <span class="cpp_type">_Ty2</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::pair<[_Ty1], [_Ty2]> &, ::std::pair<[_Ty1], [_Ty2]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::set<[_Kty], [_Pr], [_Alloc]> &, ::std::set<[_Kty], [_Pr], [_Alloc]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt;(<span class="cpp_type">set</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt; &, <span class="cpp_type">set</span>&lt;<span class="cpp_type">_Kty</span>, <span class="cpp_type">_Pr</span>, <span class="cpp_type">_Alloc</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::set<[_Kty], [_Pr], [_Alloc]> &, ::std::set<[_Kty], [_Pr], [_Alloc]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::shared_ptr<[_Ty]> &, ::std::shared_ptr<[_Ty]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">shared_ptr</span>&lt;<span class="cpp_type">_Ty</span>&gt; &, <span class="cpp_type">shared_ptr</span>&lt;<span class="cpp_type">_Ty</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::shared_ptr<[_Ty]> &, ::std::shared_ptr<[_Ty]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::tuple<[_Types]...> &, ::std::tuple<[_Types]...> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Types</span> ..., <span class="cpp_keyword">(expr)</span>&gt;(<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt; &, <span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_Types</span> ...&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::tuple<[_Types]...> &, ::std::tuple<[_Types]...> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::unique_ptr<[_Ty], [_Dx]> &, ::std::unique_ptr<[_Ty], [_Dx]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Dx</span>, <span class="cpp_keyword">(expr)</span>&gt;(<span class="cpp_type">unique_ptr</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Dx</span>&gt; &, <span class="cpp_type">unique_ptr</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Dx</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::unique_ptr<[_Ty], [_Dx]> &, ::std::unique_ptr<[_Ty], [_Dx]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::vector<[_Ty], [_Alloc]> &, ::std::vector<[_Ty], [_Alloc]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Alloc</span>&gt;(<span class="cpp_type">vector</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Alloc</span>&gt; &, <span class="cpp_type">vector</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Alloc</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::vector<[_Ty], [_Alloc]> &, ::std::vector<[_Ty], [_Alloc]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void(::std::weak_ptr<[_Ty]> &, ::std::weak_ptr<[_Ty]> &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Ty</span>&gt;(<span class="cpp_type">weak_ptr</span>&lt;<span class="cpp_type">_Ty</span>&gt; &, <span class="cpp_type">weak_ptr</span>&lt;<span class="cpp_type">_Ty</span>&gt; &)',
        'impls': [
            'FB$std::swap@void(::std::weak_ptr<[_Ty]> &, ::std::weak_ptr<[_Ty]> &)[impl0]'
        ],
        'decls': []
    },
    'std::swap@void([_Ty] &, [_Ty] &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type"></span>&gt;(<span class="cpp_type">_Ty</span> &, <span class="cpp_type">_Ty</span> &)',
        'impls': [
            'FB$std::swap@void([_Ty] &, [_Ty] &)[impl0]'
        ],
        'decls': [
            'FB$std::swap@void([_Ty] &, [_Ty] &)[decl0]'
        ]
    },
    'std::swap@void([_Ty] [*] &, [_Ty] [*] &)': {
        'displayNameInHtml': '<span class="cpp_function">swap</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_keyword">(expr)</span>, <span class="cpp_type"></span>&gt;(<span class="cpp_type">_Ty</span>( &)[<span class="cpp_keyword">(expr)</span>], <span class="cpp_type">_Ty</span>( &)[<span class="cpp_keyword">(expr)</span>])',
        'impls': [
            'FB$std::swap@void([_Ty] [*] &, [_Ty] [*] &)[impl0]'
        ],
        'decls': [
            'FB$std::swap@void([_Ty] [*] &, [_Ty] [*] &)[decl0]'
        ]
    },
    'std::tr1': {
        'displayNameInHtml': 'std::tr1',
        'impls': [],
        'decls': [
            'NF[0]$std::tr1',
            'NF[1]$std::tr1',
            'NF[2]$std::tr1',
            'NF[3]$std::tr1',
            'NF[4]$std::tr1',
            'NF[5]$std::tr1',
            'NF[6]$std::tr1'
        ]
    },
    'std::true_type': {
        'displayNameInHtml': '<span class="cpp_type">true_type</span>',
        'impls': [
            'NI$std::true_type'
        ],
        'decls': []
    },
    'std::tuple': {
        'displayNameInHtml': '<span class="cpp_type">tuple</span>&lt;<span class="cpp_type"></span> ...&gt;',
        'impls': [],
        'decls': [
            'NF[0]$std::tuple',
            'NF[1]$std::tuple'
        ]
    },
    'std::tuple@<>': {
        'displayNameInHtml': '<span class="cpp_type">tuple</span>&lt;&gt;',
        'impls': [
            'NI$std::tuple@<>'
        ],
        'decls': []
    },
    'std::tuple@<[_This], [_Rest]...>': {
        'displayNameInHtml': '<span class="cpp_type">tuple</span>&lt;<span class="cpp_type">_This</span>, <span class="cpp_type">_Rest</span> ...&gt;',
        'impls': [
            'NI$std::tuple@<[_This], [_Rest]...>'
        ],
        'decls': []
    },
    'std::tuple_size_v': {
        'displayNameInHtml': '<span class="cpp_enum">tuple_size_v</span>&lt;<span class="cpp_type">_Ty</span>&gt;',
        'impls': [
            'NI$std::tuple_size_v'
        ],
        'decls': []
    },
    'std::unary_function': {
        'displayNameInHtml': '<span class="cpp_type">unary_function</span>&lt;<span class="cpp_type">_Arg</span>, <span class="cpp_type">_Result</span>&gt;',
        'impls': [
            'NI$std::unary_function'
        ],
        'decls': []
    },
    'std::unary_function::argument_type': {
        'displayNameInHtml': '<span class="cpp_type">unary_function</span>&lt;<span class="cpp_type">_Arg</span>, <span class="cpp_type">_Result</span>&gt;::<span class="cpp_type">argument_type</span>',
        'impls': [
            'NI$std::unary_function::argument_type'
        ],
        'decls': []
    },
    'std::unary_function::result_type': {
        'displayNameInHtml': '<span class="cpp_type">unary_function</span>&lt;<span class="cpp_type">_Arg</span>, <span class="cpp_type">_Result</span>&gt;::<span class="cpp_type">result_type</span>',
        'impls': [
            'NI$std::unary_function::result_type'
        ],
        'decls': []
    },
    'std::unary_negate': {
        'displayNameInHtml': '<span class="cpp_type">unary_negate</span>&lt;<span class="cpp_type">_Fn</span>&gt;',
        'impls': [
            'NI$std::unary_negate'
        ],
        'decls': []
    },
    'std::unary_negate::$__ctor@([_Fn] const &)[impl0]::_Func': {
        'displayNameInHtml': '_Func',
        'impls': [
            'NI$std::unary_negate::$__ctor@([_Fn] const &)[impl0]::_Func'
        ],
        'decls': []
    },
    'std::unary_negate::_Fn': {
        'displayNameInHtml': '<span class="cpp_type">_Fn</span>',
        'impls': [
            'TA$std::unary_negate::_Fn'
        ],
        'decls': []
    },
    'std::unary_negate::_Functor': {
        'displayNameInHtml': '<span class="cpp_type">unary_negate</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_field">_Functor</span>',
        'impls': [
            'NI$std::unary_negate::_Functor'
        ],
        'decls': []
    },
    'std::unary_negate::argument_type': {
        'displayNameInHtml': '<span class="cpp_type">unary_negate</span>&lt;<span class="cpp_type">_Fn</span>&gt;::<span class="cpp_type">argument_type</span>',
        'impls': [
            'NI$std::unary_negate::argument_type'
        ],
        'decls': []
    },
    'std::unary_negate::operator ()@bool(::std::unary_negate::argument_type const &)[impl0]::_Left': {
        'displayNameInHtml': '_Left',
        'impls': [
            'NI$std::unary_negate::operator ()@bool(::std::unary_negate::argument_type const &)[impl0]::_Left'
        ],
        'decls': []
    },
    'std::uses_allocator': {
        'displayNameInHtml': '<span class="cpp_type">uses_allocator</span>&lt;<span class="cpp_type">_Ty</span>, <span class="cpp_type">_Alloc</span>&gt;',
        'impls': [
            'NI$std::uses_allocator'
        ],
        'decls': []
    },
    'std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Alloc': {
        'displayNameInHtml': '<span class="cpp_type">_Alloc</span>',
        'impls': [
            'TA$std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Alloc'
        ],
        'decls': []
    },
    'std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Fty': {
        'displayNameInHtml': '<span class="cpp_type">_Fty</span>',
        'impls': [
            'TA$std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Fty'
        ],
        'decls': []
    },
    'type_info': {
        'displayNameInHtml': '<span class="cpp_type">type_info</span>',
        'impls': [
            'NI$type_info'
        ],
        'decls': [
            'NF[0]$type_info'
        ]
    },
    'type_info::operator ==@bool(::type_info const &)': {
        'displayNameInHtml': '<span class="cpp_type">type_info</span>::<span class="cpp_function">operator ==</span>(<span class="cpp_type">type_info</span><span class="cpp_keyword"> const</span> &)',
        'impls': [
            'FB$type_info::operator ==@bool(::type_info const &)[impl0]'
        ],
        'decls': []
    }
};
symbolToFiles = {
    'FB$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]': null,
    'FB$std::_Compressed_pair::_Get_first@[_Ty1] &()[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::_Compressed_pair::_Get_first@[_Ty1] const &()[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::_Compressed_pair::_Get_second@[_Ty2] &()[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::_Compressed_pair::_Get_second@[_Ty2] const &()[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] &()[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_first@[_Ty1] const &()[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] &()[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::_Compressed_pair@<[_Ty1], [_Ty2], *>::_Get_second@[_Ty2] const &()[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::_Deallocate@void(void *, ::size_t)[impl0]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Deallocate_plain@void([_Alloc] &, value_type * const)[impl0]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Deallocate_plain@void([_Alloc] &, value_type * const)[impl1]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const)[impl0]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Default_allocator_traits::allocate@::std::_Default_allocator_traits::pointer([_Alloc] &, ::std::_Default_allocator_traits::size_type const, ::std::_Default_allocator_traits::const_void_pointer)[impl0]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Default_allocator_traits::construct@void([_Alloc] &, [_Objty] * const, [_Types] &&...)[impl0]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Default_allocator_traits::deallocate@void([_Alloc] &, ::std::_Default_allocator_traits::pointer const, ::std::_Default_allocator_traits::size_type const)[impl0]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Default_allocator_traits::destroy@void([_Alloc] &, [_Uty] * const)[impl0]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]': null,
    'FB$std::_Func_base::_Copy@::std::_Func_base *(void *)[decl0]': null,
    'FB$std::_Func_base::_Delete_this@void(bool)[decl0]': null,
    'FB$std::_Func_base::_Do_call@[_Rx]([_Types] &&...)[decl0]': null,
    'FB$std::_Func_base::_Get@void const *()[decl0]': null,
    'FB$std::_Func_base::_Move@::std::_Func_base *(void *)[decl0]': null,
    'FB$std::_Func_base::_Target@void const *(::type_info const &)[impl0]': null,
    'FB$std::_Func_base::_Target_type@::type_info const &()[decl0]': null,
    'FB$std::_Func_class::_Empty@bool()[impl0]': null,
    'FB$std::_Func_class::_Getimpl@::std::_Func_class::_Ptrt *()[impl0]': null,
    'FB$std::_Func_class::_Getspace@void *()[impl0]': null,
    'FB$std::_Func_class::_Getspace@void const *()[impl0]': null,
    'FB$std::_Func_class::_Local@bool()[impl0]': null,
    'FB$std::_Func_class::_Reset@void([_Fx] &&)[impl0]': null,
    'FB$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]': null,
    'FB$std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]': null,
    'FB$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]': null,
    'FB$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]': null,
    'FB$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]': null,
    'FB$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]': null,
    'FB$std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]': null,
    'FB$std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)[impl0]': null,
    'FB$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]': null,
    'FB$std::_Func_class::_Target@void const *(::type_info const &)[impl0]': null,
    'FB$std::_Func_class::_Target_type@::type_info const &()[impl0]': null,
    'FB$std::_Func_class::_Tidy@void()[impl0]': null,
    'FB$std::_Func_class::operator ()@[_Ret]([_Types]...)[decl0]': null,
    'FB$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]': null,
    'FB$std::_Func_impl::_Callee@[_Callable] &()[impl0]': null,
    'FB$std::_Func_impl::_Callee@[_Callable] const &()[impl0]': null,
    'FB$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]': null,
    'FB$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]': null,
    'FB$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[decl0]': null,
    'FB$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]': null,
    'FB$std::_Func_impl::_Myax@[_Alloc] &()[impl0]': null,
    'FB$std::_Func_impl::_Myax@[_Alloc] const &()[impl0]': null,
    'FB$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)[impl0]': null,
    'FB$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::true_type)[impl0]': null,
    'FB$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[decl0]': null,
    'FB$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]': null,
    'FB$std::_Global_new@[_Ty] *([_Types] &&...)[impl0]': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'FB$std::_Invoker_ret@<::std::_Unforced, *>::_Call@decltype(*)([_Valtys] &&...)[impl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::_Invoker_ret@<[_Cv_void], *>::_Call@void([_Valtys] &&...)[impl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::_Invoker_ret@<[_Rx], *>::_Call@[_Rx]([_Valtys] &&...)[impl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]': null,
    'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]': null,
    'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]': null,
    'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]': null,
    'FB$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]': null,
    'FB$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]': null,
    'FB$std::_Test_callable@bool([_Ty] const &)[impl0]': null,
    'FB$std::_Test_callable@bool([_Ty] const &, ::std::false_type)[impl0]': null,
    'FB$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]': null,
    'FB$std::_Unfancy@[_Ty] *([_Ty] *)[impl0]': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'FB$std::_Unfancy@auto([_Ptrty])[impl0]': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'FB$std::_Xbad_function_call@void()[decl0]': null,
    'FB$std::addressof@[_Ty] *([_Ty] &)[impl0]': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'FB$std::addressof@[_Ty] const *([_Ty] const &&)[decl0]': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'FB$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]': null,
    'FB$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]': null,
    'FB$std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &&)[impl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::forward@[_Ty] &&(::std::remove_reference_t<[_Ty]> &)[impl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::forward_as_tuple@::std::tuple<[_Types] &&...>([_Types] &&...)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::function::swap@void(::std::function &)[impl0]': null,
    'FB$std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &&(::std::pair<[_Ty1], [_Ty2]> &&)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> &(::std::pair<[_Ty1], [_Ty2]> &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &&(::std::pair<[_Ty1], [_Ty2]> const &&)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@::std::tuple_element_t<*, ::std::pair<[_Ty1], [_Ty2]>> const &(::std::pair<[_Ty1], [_Ty2]> const &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &&(::std::tuple<[_Types]...> &&)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> &(::std::tuple<[_Types]...> &)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &&(::std::tuple<[_Types]...> const &&)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@::std::tuple_element_t<*, ::std::tuple<[_Types]...>> const &(::std::tuple<[_Types]...> const &)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@[_Ty1] &&(::std::pair<[_Ty1], [_Ty2]> &&)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@[_Ty1] &(::std::pair<[_Ty1], [_Ty2]> &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@[_Ty1] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@[_Ty1] const &(::std::pair<[_Ty1], [_Ty2]> const &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@[_Ty2] &&(::std::pair<[_Ty1], [_Ty2]> &&)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@[_Ty2] &(::std::pair<[_Ty1], [_Ty2]> &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@[_Ty2] const &&(::std::pair<[_Ty1], [_Ty2]> const &&)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@[_Ty2] const &(::std::pair<[_Ty1], [_Ty2]> const &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::get@[_Ty] &&(::std::array<[_Ty], *> &&)[decl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@[_Ty] &&(::std::tuple<[_Types]...> &&)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@[_Ty] &(::std::array<[_Ty], *> &)[decl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@[_Ty] &(::std::tuple<[_Types]...> &)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@[_Ty] const &&(::std::array<[_Ty], *> const &&)[decl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@[_Ty] const &&(::std::tuple<[_Types]...> const &&)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@[_Ty] const &(::std::array<[_Ty], *> const &)[decl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::get@[_Ty] const &(::std::tuple<[_Types]...> const &)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::invoke@decltype(*)([_Callable] &&, [_Types] &&...)[decl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::invoke@decltype(*)([_Callable] &&, [_Types] &&...)[impl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]': null,
    'FB$std::move@::std::remove_reference_t<[_Ty]> &&([_Ty] &&)[impl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::move@[_OutIt]([_InIt], [_InIt], [_OutIt])[impl0]': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'FB$std::operator !=@bool(::std::error_code const &, ::std::error_code const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator !=@bool(::std::error_code const &, ::std::error_condition const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator !=@bool(::std::error_condition const &, ::std::error_code const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator !=@bool(::std::error_condition const &, ::std::error_condition const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator <@bool(::std::error_code const &, ::std::error_code const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator <@bool(::std::error_condition const &, ::std::error_condition const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator ==@bool(::std::error_code const &, ::std::error_code const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator ==@bool(::std::error_code const &, ::std::error_condition const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator ==@bool(::std::error_condition const &, ::std::error_code const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::operator ==@bool(::std::error_condition const &, ::std::error_condition const &)[impl0]': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'FB$std::swap@void(::std::_Vb_reference<[_Alvbase_wrapped]>, ::std::_Vb_reference<[_Alvbase_wrapped]>)[impl0]': { 'htmlFileName': 'vector', 'displayName': 'vector' },
    'FB$std::swap@void(::std::basic_string<[_Elem], [_Traits], [_Alloc]> &, ::std::basic_string<[_Elem], [_Traits], [_Alloc]> &)[impl0]': { 'htmlFileName': 'xstring', 'displayName': 'xstring' },
    'FB$std::swap@void(::std::exception_ptr &, ::std::exception_ptr &)[impl0]': { 'htmlFileName': 'exception', 'displayName': 'exception' },
    'FB$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]': null,
    'FB$std::swap@void(::std::map<[_Kty], [_Ty], [_Pr], [_Alloc]> &, ::std::map<[_Kty], [_Ty], [_Pr], [_Alloc]> &)[impl0]': { 'htmlFileName': 'map', 'displayName': 'map' },
    'FB$std::swap@void(::std::multimap<[_Kty], [_Ty], [_Pr], [_Alloc]> &, ::std::multimap<[_Kty], [_Ty], [_Pr], [_Alloc]> &)[impl0]': { 'htmlFileName': 'map', 'displayName': 'map' },
    'FB$std::swap@void(::std::multiset<[_Kty], [_Pr], [_Alloc]> &, ::std::multiset<[_Kty], [_Pr], [_Alloc]> &)[impl0]': { 'htmlFileName': 'set', 'displayName': 'set' },
    'FB$std::swap@void(::std::pair<[_Ty1], [_Ty2]> &, ::std::pair<[_Ty1], [_Ty2]> &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::swap@void(::std::set<[_Kty], [_Pr], [_Alloc]> &, ::std::set<[_Kty], [_Pr], [_Alloc]> &)[impl0]': { 'htmlFileName': 'set', 'displayName': 'set' },
    'FB$std::swap@void(::std::shared_ptr<[_Ty]> &, ::std::shared_ptr<[_Ty]> &)[impl0]': { 'htmlFileName': 'memory', 'displayName': 'memory' },
    'FB$std::swap@void(::std::tuple<[_Types]...> &, ::std::tuple<[_Types]...> &)[impl0]': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'FB$std::swap@void(::std::unique_ptr<[_Ty], [_Dx]> &, ::std::unique_ptr<[_Ty], [_Dx]> &)[impl0]': { 'htmlFileName': 'memory', 'displayName': 'memory' },
    'FB$std::swap@void(::std::vector<[_Ty], [_Alloc]> &, ::std::vector<[_Ty], [_Alloc]> &)[impl0]': { 'htmlFileName': 'vector', 'displayName': 'vector' },
    'FB$std::swap@void(::std::weak_ptr<[_Ty]> &, ::std::weak_ptr<[_Ty]> &)[impl0]': { 'htmlFileName': 'memory', 'displayName': 'memory' },
    'FB$std::swap@void([_Ty] &, [_Ty] &)[decl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::swap@void([_Ty] &, [_Ty] &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$std::swap@void([_Ty] [*] &, [_Ty] [*] &)[decl0]': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'FB$std::swap@void([_Ty] [*] &, [_Ty] [*] &)[impl0]': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'FB$type_info::operator ==@bool(::type_info const &)[impl0]': { 'htmlFileName': 'vcruntime_typeinfo.h', 'displayName': 'vcruntime_typeinfo.h' },
    'NF[0]$std': { 'htmlFileName': 'vcruntime_new.h', 'displayName': 'vcruntime_new.h' },
    'NF[0]$std::_Binder': null,
    'NF[0]$std::_Get_function_impl': null,
    'NF[0]$std::_Select_fixer': null,
    'NF[0]$std::allocator_traits': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'NF[0]$std::function': null,
    'NF[0]$std::placeholders': null,
    'NF[0]$std::reference_wrapper': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NF[0]$std::tr1': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NF[0]$std::tuple': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'NF[0]$type_info': { 'htmlFileName': 'eh.h', 'displayName': 'eh.h' },
    'NF[10]$std': { 'htmlFileName': 'vcruntime_exception.h', 'displayName': 'vcruntime_exception.h' },
    'NF[11]$std': { 'htmlFileName': 'exception', 'displayName': 'exception' },
    'NF[12]$std': { 'htmlFileName': 'exception', 'displayName': 'exception' },
    'NF[13]$std': { 'htmlFileName': 'new', 'displayName': 'new' },
    'NF[14]$std': { 'htmlFileName': 'cstdint', 'displayName': 'cstdint' },
    'NF[15]$std': { 'htmlFileName': 'xtgmath.h', 'displayName': 'xtgmath.h' },
    'NF[16]$std': { 'htmlFileName': 'cmath', 'displayName': 'cmath' },
    'NF[17]$std': { 'htmlFileName': 'cwchar', 'displayName': 'cwchar' },
    'NF[18]$std': { 'htmlFileName': 'limits', 'displayName': 'limits' },
    'NF[19]$std': { 'htmlFileName': 'cstdio', 'displayName': 'cstdio' },
    'NF[1]$std': { 'htmlFileName': 'yvals.h', 'displayName': 'yvals.h' },
    'NF[1]$std::tr1': { 'htmlFileName': 'cstdint', 'displayName': 'cstdint' },
    'NF[1]$std::tuple': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'NF[20]$std': { 'htmlFileName': 'cstring', 'displayName': 'cstring' },
    'NF[21]$std': { 'htmlFileName': 'iosfwd', 'displayName': 'iosfwd' },
    'NF[22]$std': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'NF[23]$std': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'NF[24]$std': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'NF[25]$std': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'NF[26]$std': { 'htmlFileName': 'xatomic0.h', 'displayName': 'xatomic0.h' },
    'NF[27]$std': { 'htmlFileName': 'xmemory', 'displayName': 'xmemory' },
    'NF[28]$std': { 'htmlFileName': 'xstring', 'displayName': 'xstring' },
    'NF[29]$std': { 'htmlFileName': 'stdexcept', 'displayName': 'stdexcept' },
    'NF[2]$std': { 'htmlFileName': 'stddef.h', 'displayName': 'stddef.h' },
    'NF[2]$std::tr1': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'NF[30]$std': { 'htmlFileName': 'vector', 'displayName': 'vector' },
    'NF[31]$std': { 'htmlFileName': 'xtree', 'displayName': 'xtree' },
    'NF[32]$std': { 'htmlFileName': 'set', 'displayName': 'set' },
    'NF[33]$std': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'NF[34]$std': { 'htmlFileName': 'map', 'displayName': 'map' },
    'NF[35]$std': { 'htmlFileName': 'vcruntime_typeinfo.h', 'displayName': 'vcruntime_typeinfo.h' },
    'NF[36]$std': { 'htmlFileName': 'vcruntime_typeinfo.h', 'displayName': 'vcruntime_typeinfo.h' },
    'NF[37]$std': { 'htmlFileName': 'typeinfo', 'displayName': 'typeinfo' },
    'NF[38]$std': { 'htmlFileName': 'xlocinfo', 'displayName': 'xlocinfo' },
    'NF[39]$std': { 'htmlFileName': 'memory', 'displayName': 'memory' },
    'NF[3]$std': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NF[3]$std::tr1': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'NF[40]$std': { 'htmlFileName': 'xfacet', 'displayName': 'xfacet' },
    'NF[41]$std': { 'htmlFileName': 'xlocale', 'displayName': 'xlocale' },
    'NF[42]$std': { 'htmlFileName': 'xcall_once.h', 'displayName': 'xcall_once.h' },
    'NF[43]$std': { 'htmlFileName': 'xerrc.h', 'displayName': 'xerrc.h' },
    'NF[44]$std': { 'htmlFileName': 'system_error', 'displayName': 'system_error' },
    'NF[45]$std': { 'htmlFileName': 'xiosbase', 'displayName': 'xiosbase' },
    'NF[46]$std': { 'htmlFileName': 'streambuf', 'displayName': 'streambuf' },
    'NF[47]$std': { 'htmlFileName': 'xlocnum', 'displayName': 'xlocnum' },
    'NF[48]$std': { 'htmlFileName': 'ios', 'displayName': 'ios' },
    'NF[49]$std': { 'htmlFileName': 'ostream', 'displayName': 'ostream' },
    'NF[4]$std': { 'htmlFileName': 'cstddef', 'displayName': 'cstddef' },
    'NF[4]$std::tr1': { 'htmlFileName': 'memory', 'displayName': 'memory' },
    'NF[50]$std': { 'htmlFileName': 'istream', 'displayName': 'istream' },
    'NF[51]$std': { 'htmlFileName': 'xstring_insert.h', 'displayName': 'xstring_insert.h' },
    'NF[52]$std': { 'htmlFileName': 'string', 'displayName': 'string' },
    'NF[53]$std': { 'htmlFileName': 'xlocbuf', 'displayName': 'xlocbuf' },
    'NF[54]$std': { 'htmlFileName': 'xlocmes', 'displayName': 'xlocmes' },
    'NF[55]$std': { 'htmlFileName': 'xlocmon', 'displayName': 'xlocmon' },
    'NF[56]$std': { 'htmlFileName': 'ctime', 'displayName': 'ctime' },
    'NF[57]$std': { 'htmlFileName': 'xloctime', 'displayName': 'xloctime' },
    'NF[58]$std': { 'htmlFileName': 'locale', 'displayName': 'locale' },
    'NF[59]$std': { 'htmlFileName': 'codecvt', 'displayName': 'codecvt' },
    'NF[5]$std': { 'htmlFileName': 'cstdlib', 'displayName': 'cstdlib' },
    'NF[5]$std::tr1': { 'htmlFileName': 'ios', 'displayName': 'ios' },
    'NF[60]$std': null,
    'NF[61]$std': { 'htmlFileName': 'iostream', 'displayName': 'iostream' },
    'NF[6]$std': { 'htmlFileName': 'initializer_list', 'displayName': 'initializer_list' },
    'NF[6]$std::tr1': null,
    'NF[7]$std': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'NF[8]$std': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NF[9]$std': { 'htmlFileName': 'exception', 'displayName': 'exception' },
    'NI$size_t': { 'htmlFileName': 'vcruntime.h', 'displayName': 'vcruntime.h' },
    'NI$std::_Arg_types': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Arg_types@<[_Ty1], [_Ty2]>': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Arg_types@<[_Ty1]>': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Binder': null,
    'NI$std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Args': null,
    'NI$std::_Binder::$__ctor@([_Fx] &&, [_Types] &&...)[impl0]::_Func': null,
    'NI$std::_Binder::_First': null,
    'NI$std::_Binder::_Mypair': null,
    'NI$std::_Binder::_Second': null,
    'NI$std::_Binder::_Seq': null,
    'NI$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbargs': null,
    'NI$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbargs': null,
    'NI$std::_Binder_result_type': null,
    'NI$std::_Binder_result_type::_All_weak_types': null,
    'NI$std::_Binder_result_type::_Decayed': null,
    'NI$std::_Binder_result_type::type': null,
    'NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Obj': null,
    'NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Tpl': null,
    'NI$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ut': null,
    'NI$std::_Compressed_pair': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'NI$std::_Compressed_pair@<[_Ty1], [_Ty2], *>': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'NI$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid': null,
    'NI$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut': null,
    'NI$std::_Forced_result_type': null,
    'NI$std::_Func_base': null,
    'NI$std::_Func_base::_Target@void const *(::type_info const &)[impl0]::_Info': null,
    'NI$std::_Func_class': null,
    'NI$std::_Func_class::_Enable_if_callable_t': null,
    'NI$std::_Func_class::_Mystorage': null,
    'NI$std::_Func_class::_Ptrt': null,
    'NI$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Impl': null,
    'NI$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Val': null,
    'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Al': null,
    'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax': null,
    'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Myimpl': null,
    'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ptr': null,
    'NI$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Val': null,
    'NI$std::_Func_class::_Reset_copy@void(::std::_Func_class const &)[impl0]::_Right': null,
    'NI$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Val': null,
    'NI$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Val': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Al': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ax': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Ptr': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Val': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Al': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl_traits': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ax': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Ptr': null,
    'NI$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Val': null,
    'NI$std::_Func_class::_Reset_move@void(::std::_Func_class &&)[impl0]::_Right': null,
    'NI$std::_Func_class::_Set@void(::std::_Func_class::_Ptrt *)[impl0]::_Ptr': null,
    'NI$std::_Func_class::_Storage': null,
    'NI$std::_Func_class::_Storage::_Ptrs': null,
    'NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Right': null,
    'NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp': null,
    'NI$std::_Func_class::_Swap@void(::std::_Func_class &)[impl0]::_Temp2': null,
    'NI$std::_Func_class::_Target@void const *(::type_info const &)[impl0]::_Info': null,
    'NI$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Args': null,
    'NI$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Impl': null,
    'NI$std::_Func_impl': null,
    'NI$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Ax': null,
    'NI$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Val': null,
    'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Al': null,
    'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Ptr': null,
    'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::false_type)[impl0]::_Where': null,
    'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Al': null,
    'NI$std::_Func_impl::_Clone@::std::_Func_impl::_Mybase *(void *, ::std::true_type)[impl0]::_Ptr': null,
    'NI$std::_Func_impl::_Copy@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where': null,
    'NI$std::_Func_impl::_Delete_this@void(bool)[impl0]::_Al': null,
    'NI$std::_Func_impl::_Delete_this@void(bool)[impl0]::_Deallocate': null,
    'NI$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args': null,
    'NI$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_The_callee': null,
    'NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Al': null,
    'NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Ptr': null,
    'NI$std::_Func_impl::_Move@::std::_Func_impl::_Mybase *(void *)[impl0]::_Where': null,
    'NI$std::_Func_impl::_Myalty': null,
    'NI$std::_Func_impl::_Myalty_traits': null,
    'NI$std::_Func_impl::_Mybase': null,
    'NI$std::_Func_impl::_Mypair': null,
    'NI$std::_Func_impl_no_alloc': null,
    'NI$std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Val': null,
    'NI$std::_Func_impl_no_alloc::_Callee': null,
    'NI$std::_Func_impl_no_alloc::_Clone@::std::_Func_impl_no_alloc::_Mybase *(void *, ::std::false_type)[impl0]::_Where': null,
    'NI$std::_Func_impl_no_alloc::_Copy@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where': null,
    'NI$std::_Func_impl_no_alloc::_Delete_this@void(bool)[impl0]::_Dealloc': null,
    'NI$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Args': null,
    'NI$std::_Func_impl_no_alloc::_Move@::std::_Func_impl_no_alloc::_Mybase *(void *)[impl0]::_Where': null,
    'NI$std::_Func_impl_no_alloc::_Mybase': null,
    'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>': null,
    'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>2': null,
    'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>2::type': null,
    'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>3': null,
    'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>3::type': null,
    'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>4': null,
    'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>4::type': null,
    'NI$std::_Get_function_impl@<[_Ret]([_Types]...)>::type': null,
    'NI$std::_Invoker_ret': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Invoker_ret@<::std::_Unforced, *>': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Invoker_ret@<[_Cv_void], *>': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Invoker_ret@<[_Rx], *>': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Is_invocable_r': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Is_large': null,
    'NI$std::_Is_specialization_v': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Mem_fn': null,
    'NI$std::_Mem_fn::$__ctor@([_Memptr])[impl0]::_Val': null,
    'NI$std::_Mem_fn::_Pm': null,
    'NI$std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Args': null,
    'NI$std::_One_then_variadic_args_t': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'NI$std::_Ph': null,
    'NI$std::_Rebind_alloc_t': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Tid': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Ut': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>3': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>4': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Ut': null,
    'NI$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Tid': null,
    'NI$std::_Small_object_num_ptrs': { 'htmlFileName': 'typeinfo', 'displayName': 'typeinfo' },
    'NI$std::_Space_size': null,
    'NI$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Arg': null,
    'NI$std::_Test_callable@bool([_Ty] const &)[impl0]::_Arg': null,
    'NI$std::_Test_callable@bool([_Ty] const &)[impl0]::_Testable': null,
    'NI$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Arg': null,
    'NI$std::_Unforced': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Weak_result_type': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Weak_result_type@<[_Ty], ::std::void_t<result_type>>': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Weak_types': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::_Weak_types::type': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::allocator_arg': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'NI$std::allocator_arg_t': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'NI$std::allocator_traits': { 'htmlFileName': 'xmemory0', 'displayName': 'xmemory0' },
    'NI$std::bad_function_call': null,
    'NI$std::binary_function': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'NI$std::binary_negate': null,
    'NI$std::binary_negate::$__ctor@([_Fn] const &)[impl0]::_Func': null,
    'NI$std::binary_negate::_Functor': null,
    'NI$std::binary_negate::first_argument_type': null,
    'NI$std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Left': null,
    'NI$std::binary_negate::operator ()@bool(::std::binary_negate::first_argument_type const &, ::std::binary_negate::second_argument_type const &)[impl0]::_Right': null,
    'NI$std::binary_negate::second_argument_type': null,
    'NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func': null,
    'NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val': null,
    'NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Func': null,
    'NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Val': null,
    'NI$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args': null,
    'NI$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func': null,
    'NI$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Args': null,
    'NI$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Func': null,
    'NI$std::binder1st': null,
    'NI$std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Func': null,
    'NI$std::binder1st::$__ctor@([_Fn] const &, first_argument_type const &)[impl0]::_Left': null,
    'NI$std::binder1st::_Base': null,
    'NI$std::binder1st::argument_type': null,
    'NI$std::binder1st::op': null,
    'NI$std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type &)[impl0]::_Right': null,
    'NI$std::binder1st::operator ()@::std::binder1st::result_type(::std::binder1st::argument_type const &)[impl0]::_Right': null,
    'NI$std::binder1st::result_type': null,
    'NI$std::binder1st::value': null,
    'NI$std::binder2nd': null,
    'NI$std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Func': null,
    'NI$std::binder2nd::$__ctor@([_Fn] const &, second_argument_type const &)[impl0]::_Right': null,
    'NI$std::binder2nd::_Base': null,
    'NI$std::binder2nd::argument_type': null,
    'NI$std::binder2nd::op': null,
    'NI$std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type &)[impl0]::_Left': null,
    'NI$std::binder2nd::operator ()@::std::binder2nd::result_type(::std::binder2nd::argument_type const &)[impl0]::_Left': null,
    'NI$std::binder2nd::result_type': null,
    'NI$std::binder2nd::value': null,
    'NI$std::bit_and': null,
    'NI$std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::bit_and::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::bit_and@<void>': null,
    'NI$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::bit_not': null,
    'NI$std::bit_not::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left': null,
    'NI$std::bit_not@<void>': null,
    'NI$std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left': null,
    'NI$std::bit_or': null,
    'NI$std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::bit_or::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::bit_or@<void>': null,
    'NI$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::bit_xor': null,
    'NI$std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::bit_xor::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::bit_xor@<void>': null,
    'NI$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::bool_constant': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::conditional_t': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::conjunction_v': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::const_mem_fun1_ref_t': null,
    'NI$std::const_mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::const_mem_fun1_ref_t::_Pmemfun': null,
    'NI$std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Left': null,
    'NI$std::const_mem_fun1_ref_t::operator ()@[_Result]([_Ty] const &, [_Arg])[impl0]::_Right': null,
    'NI$std::const_mem_fun1_t': null,
    'NI$std::const_mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::const_mem_fun1_t::_Pmemfun': null,
    'NI$std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Pleft': null,
    'NI$std::const_mem_fun1_t::operator ()@[_Result]([_Ty] const *, [_Arg])[impl0]::_Right': null,
    'NI$std::const_mem_fun_ref_t': null,
    'NI$std::const_mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::const_mem_fun_ref_t::_Pmemfun': null,
    'NI$std::const_mem_fun_ref_t::operator ()@[_Result]([_Ty] const &)[impl0]::_Left': null,
    'NI$std::const_mem_fun_t': null,
    'NI$std::const_mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::const_mem_fun_t::_Pmemfun': null,
    'NI$std::const_mem_fun_t::operator ()@[_Result]([_Ty] const *)[impl0]::_Pleft': null,
    'NI$std::decay_t': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::divides': null,
    'NI$std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::divides::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::divides@<void>': null,
    'NI$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::enable_if_t': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::exception': { 'htmlFileName': 'vcruntime_exception.h', 'displayName': 'vcruntime_exception.h' },
    'NI$std::false_type': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::function': null,
    'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Al': null,
    'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Right': null,
    'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Ax': null,
    'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Right': null,
    'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Ax': null,
    'NI$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Func': null,
    'NI$std::function::$__ctor@(::std::function &&)[impl0]::_Right': null,
    'NI$std::function::$__ctor@(::std::function const &)[impl0]::_Right': null,
    'NI$std::function::$__ctor@([_Fx])[impl0]::_Func': null,
    'NI$std::function::_Mybase': null,
    'NI$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Ax': null,
    'NI$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Func': null,
    'NI$std::function::operator =@::std::function &(::std::function &&)[impl0]::_Right': null,
    'NI$std::function::operator =@::std::function &(::std::function const &)[impl0]::_Right': null,
    'NI$std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Func': null,
    'NI$std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Func': null,
    'NI$std::function::swap@void(::std::function &)[impl0]::_Right': null,
    'NI$std::index_sequence': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::index_sequence_for': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::integral_constant': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::integral_constant::type': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::integral_constant::value': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::is_bind_expression': null,
    'NI$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>': null,
    'NI$std::is_bind_expression@<[_Tx] const volatile>': null,
    'NI$std::is_bind_expression@<[_Tx] const>': null,
    'NI$std::is_bind_expression@<[_Tx] volatile>': null,
    'NI$std::is_bind_expression_v': null,
    'NI$std::is_function_v': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::is_member_pointer_v': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::is_nothrow_move_constructible': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::is_placeholder': null,
    'NI$std::is_placeholder@<::std::_Ph<*>>': null,
    'NI$std::is_placeholder@<[_Tx] const volatile>': null,
    'NI$std::is_placeholder@<[_Tx] const>': null,
    'NI$std::is_placeholder@<[_Tx] volatile>': null,
    'NI$std::is_placeholder_v': null,
    'NI$std::is_pointer_v': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::is_same': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::is_same@<[_Ty1], [_Ty1]>': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::is_same_v': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::logical_and': null,
    'NI$std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::logical_and::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::logical_and@<void>': null,
    'NI$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::logical_not': null,
    'NI$std::logical_not::operator ()@bool([_Ty] const &)[impl0]::_Left': null,
    'NI$std::logical_not@<void>': null,
    'NI$std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left': null,
    'NI$std::logical_or': null,
    'NI$std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::logical_or::operator ()@bool([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::logical_or@<void>': null,
    'NI$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::make_index_sequence': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::max_align_t': { 'htmlFileName': 'cstddef', 'displayName': 'cstddef' },
    'NI$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun1_ref_t': null,
    'NI$std::mem_fun1_ref_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun1_ref_t::_Pmemfun': null,
    'NI$std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Left': null,
    'NI$std::mem_fun1_ref_t::operator ()@[_Result]([_Ty] &, [_Arg])[impl0]::_Right': null,
    'NI$std::mem_fun1_t': null,
    'NI$std::mem_fun1_t::$__ctor@([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun1_t::_Pmemfun': null,
    'NI$std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Pleft': null,
    'NI$std::mem_fun1_t::operator ()@[_Result]([_Ty] *, [_Arg])[impl0]::_Right': null,
    'NI$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun_ref_t': null,
    'NI$std::mem_fun_ref_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun_ref_t::_Pmemfun': null,
    'NI$std::mem_fun_ref_t::operator ()@[_Result]([_Ty] &)[impl0]::_Left': null,
    'NI$std::mem_fun_t': null,
    'NI$std::mem_fun_t::$__ctor@([_Result]() ([_Ty] ::) *)[impl0]::_Pm': null,
    'NI$std::mem_fun_t::_Pmemfun': null,
    'NI$std::mem_fun_t::operator ()@[_Result]([_Ty] *)[impl0]::_Pleft': null,
    'NI$std::modulus': null,
    'NI$std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Left': null,
    'NI$std::modulus::operator ()@[_Ty]([_Ty] const &, [_Ty] const &)[impl0]::_Right': null,
    'NI$std::modulus@<void>': null,
    'NI$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Left': null,
    'NI$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Right': null,
    'NI$std::negate': null,
    'NI$std::negate::operator ()@[_Ty]([_Ty] const &)[impl0]::_Left': null,
    'NI$std::negate@<void>': null,
    'NI$std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Left': null,
    'NI$std::negation': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func': null,
    'NI$std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Func': null,
    'NI$std::nullptr_t': { 'htmlFileName': 'stddef.h', 'displayName': 'stddef.h' },
    'NI$std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other': null,
    'NI$std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other': null,
    'NI$std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Other': null,
    'NI$std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Other': null,
    'NI$std::pointer_to_binary_function': null,
    'NI$std::pointer_to_binary_function::$__ctor@([_Fn])[impl0]::_Left': null,
    'NI$std::pointer_to_binary_function::_Pfun': null,
    'NI$std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Left': null,
    'NI$std::pointer_to_binary_function::operator ()@[_Result]([_Arg1], [_Arg2])[impl0]::_Right': null,
    'NI$std::pointer_to_unary_function': null,
    'NI$std::pointer_to_unary_function::$__ctor@([_Fn])[impl0]::_Left': null,
    'NI$std::pointer_to_unary_function::_Pfun': null,
    'NI$std::pointer_to_unary_function::operator ()@[_Result]([_Arg])[impl0]::_Left': null,
    'NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Left': null,
    'NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Left': null,
    'NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Left': null,
    'NI$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Left': null,
    'NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Left': null,
    'NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Left': null,
    'NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Left': null,
    'NI$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Left': null,
    'NI$std::reference_wrapper': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::remove_cv_t': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::remove_pointer_t': { 'htmlFileName': 'type_traits', 'displayName': 'type_traits' },
    'NI$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Left': null,
    'NI$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Right': null,
    'NI$std::true_type': { 'htmlFileName': 'xtr1common', 'displayName': 'xtr1common' },
    'NI$std::tuple@<>': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'NI$std::tuple@<[_This], [_Rest]...>': { 'htmlFileName': 'tuple', 'displayName': 'tuple' },
    'NI$std::tuple_size_v': { 'htmlFileName': 'utility', 'displayName': 'utility' },
    'NI$std::unary_function': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'NI$std::unary_function::argument_type': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'NI$std::unary_function::result_type': { 'htmlFileName': 'xstddef', 'displayName': 'xstddef' },
    'NI$std::unary_negate': null,
    'NI$std::unary_negate::$__ctor@([_Fn] const &)[impl0]::_Func': null,
    'NI$std::unary_negate::_Functor': null,
    'NI$std::unary_negate::argument_type': null,
    'NI$std::unary_negate::operator ()@bool(::std::unary_negate::argument_type const &)[impl0]::_Left': null,
    'NI$std::uses_allocator': { 'htmlFileName': 'xutility', 'displayName': 'xutility' },
    'NI$type_info': { 'htmlFileName': 'vcruntime_typeinfo.h', 'displayName': 'vcruntime_typeinfo.h' },
    'TA$std::_Binder::_Fx2': null,
    'TA$std::_Binder::_Ret2': null,
    'TA$std::_Binder::_Types2': null,
    'TA$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)2[impl0]::_Unbound': null,
    'TA$std::_Binder::operator ()@decltype(*)([_Unbound] &&...)[impl0]::_Unbound': null,
    'TA$std::_Binder_result_type::_Fx': null,
    'TA$std::_Binder_result_type::_Ret': null,
    'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_FD': null,
    'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Cv_tuple_TiD': null,
    'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ix': null,
    'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Ret': null,
    'TA$std::_Call_binder@decltype(*)(::std::_Invoker_ret<[_Ret]>, ::std::index_sequence<*...>, [_Cv_FD] &, [_Cv_tuple_TiD] &, [_Untuple] &&)[impl0]::_Untuple': null,
    'TA$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Cv_TiD': null,
    'TA$std::_Fix_arg@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': null,
    'TA$std::_Forced_result_type::_Ret': null,
    'TA$std::_Func_base::_Rx': null,
    'TA$std::_Func_base::_Types': null,
    'TA$std::_Func_class::_Enable_if_callable_t::_Function': null,
    'TA$std::_Func_class::_Enable_if_callable_t::_Fx': null,
    'TA$std::_Func_class::_Reset@void([_Fx] &&)[impl0]::_Fx': null,
    'TA$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc': null,
    'TA$std::_Func_class::_Reset_alloc@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx': null,
    'TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Fx': null,
    'TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::false_type)[impl0]::_Myimpl': null,
    'TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Fx': null,
    'TA$std::_Func_class::_Reset_impl@void([_Fx] &&, ::std::true_type)[impl0]::_Myimpl': null,
    'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alimpl': null,
    'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Alloc': null,
    'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Fx': null,
    'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::false_type)[impl0]::_Myimpl': null,
    'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alimpl': null,
    'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Alloc': null,
    'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Fx': null,
    'TA$std::_Func_class::_Reset_impl_alloc@void([_Fx] &&, [_Alloc] const &, [_Myimpl] *, [_Alimpl] &, ::std::true_type)[impl0]::_Myimpl': null,
    'TA$std::_Func_class::_Ret': null,
    'TA$std::_Func_class::_Types': null,
    'TA$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Ret': null,
    'TA$std::_Func_class::operator ()@[_Ret]([_Types]...)[impl0]::_Types': null,
    'TA$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other1': null,
    'TA$std::_Func_impl::$__ctor@([_Other1] &&, [_Other2] &&)[impl0]::_Other2': null,
    'TA$std::_Func_impl::_Alloc': null,
    'TA$std::_Func_impl::_Callable': null,
    'TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Alloc': null,
    'TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable': null,
    'TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx': null,
    'TA$std::_Func_impl::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types': null,
    'TA$std::_Func_impl::_Rx': null,
    'TA$std::_Func_impl::_Types': null,
    'TA$std::_Func_impl_no_alloc::$__ctor@([_Other] &&)[impl0]::_Other': null,
    'TA$std::_Func_impl_no_alloc::_Callable': null,
    'TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Callable': null,
    'TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Rx': null,
    'TA$std::_Func_impl_no_alloc::_Do_call@[_Rx]([_Types] &&...)[impl0]::_Types': null,
    'TA$std::_Func_impl_no_alloc::_Rx': null,
    'TA$std::_Func_impl_no_alloc::_Types': null,
    'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Ret': null,
    'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>2::_Types': null,
    'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Ret': null,
    'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>3::_Types': null,
    'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Ret': null,
    'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>4::_Types': null,
    'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>::_Ret': null,
    'TA$std::_Get_function_impl@<[_Ret]([_Types]...)>::_Types': null,
    'TA$std::_Is_large::_Impl': null,
    'TA$std::_Mem_fn::_Memptr': null,
    'TA$std::_Mem_fn::operator ()@decltype(*)([_Types] &&...)[impl0]::_Types': null,
    'TA$std::_Select_fixer::_Cv_TiD': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Jx': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Apply@decltype(*)([_Cv_TiD] &, [_Untuple] &&, ::std::index_sequence<*...>)[impl0]::_Untuple': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Cv_TiD': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>2::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Cv_TiD': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>3::_Fix@[_Cv_TiD] &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Cv_TiD': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Fix@decltype(*)([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>4::_Jx': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Cv_TiD': null,
    'TA$std::_Select_fixer@<[_Cv_TiD], *, *, *>::_Fix@type &([_Cv_TiD] &, [_Untuple] &&)[impl0]::_Untuple': null,
    'TA$std::_Test_callable@bool(::std::function<[_Fty]> const &)[impl0]::_Fty': null,
    'TA$std::_Test_callable@bool([_Ty] const &)[impl0]::_Ty': null,
    'TA$std::_Test_callable@bool([_Ty] const &, ::std::false_type)[impl0]::_Ty': null,
    'TA$std::_Test_callable@bool([_Ty] const &, ::std::true_type)[impl0]::_Ty': null,
    'TA$std::binary_negate::_Fn': null,
    'TA$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn': null,
    'TA$std::bind1st@::std::binder1st<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty': null,
    'TA$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Fn': null,
    'TA$std::bind2nd@::std::binder2nd<[_Fn]>([_Fn] const &, [_Ty] const &)[impl0]::_Ty': null,
    'TA$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx': null,
    'TA$std::bind@::std::_Binder<::std::_Unforced, [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types': null,
    'TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Fx': null,
    'TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Ret': null,
    'TA$std::bind@::std::_Binder<[_Ret], [_Fx], [_Types]...>([_Fx] &&, [_Types] &&...)[impl0]::_Types': null,
    'TA$std::binder1st::_Fn': null,
    'TA$std::binder2nd::_Fn': null,
    'TA$std::bit_and::_Ty': null,
    'TA$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::bit_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::bit_not::_Ty': null,
    'TA$std::bit_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty': null,
    'TA$std::bit_or::_Ty': null,
    'TA$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::bit_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::bit_xor::_Ty': null,
    'TA$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::bit_xor@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::const_mem_fun1_ref_t::_Arg': null,
    'TA$std::const_mem_fun1_ref_t::_Result': null,
    'TA$std::const_mem_fun1_ref_t::_Ty': null,
    'TA$std::const_mem_fun1_t::_Arg': null,
    'TA$std::const_mem_fun1_t::_Result': null,
    'TA$std::const_mem_fun1_t::_Ty': null,
    'TA$std::const_mem_fun_ref_t::_Result': null,
    'TA$std::const_mem_fun_ref_t::_Ty': null,
    'TA$std::const_mem_fun_t::_Result': null,
    'TA$std::const_mem_fun_t::_Ty': null,
    'TA$std::divides::_Ty': null,
    'TA$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::divides@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &)[impl0]::_Alloc': null,
    'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function &&)[impl0]::_Alloc': null,
    'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::function const &)[impl0]::_Alloc': null,
    'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, ::std::nullptr_t)[impl0]::_Alloc': null,
    'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Alloc': null,
    'TA$std::function::$__ctor@(::std::allocator_arg_t, [_Alloc] const &, [_Fx])[impl0]::_Fx': null,
    'TA$std::function::$__ctor@([_Fx])[impl0]::_Fx': null,
    'TA$std::function::_Fty2': null,
    'TA$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Alloc': null,
    'TA$std::function::assign@void([_Fx] &&, [_Alloc] const &)[impl0]::_Fx': null,
    'TA$std::function::operator =@::std::function &(::std::reference_wrapper<[_Fx]>)[impl0]::_Fx': null,
    'TA$std::function::operator =@::std::function &([_Fx] &&)[impl0]::_Fx': null,
    'TA$std::function::target@[_Fx] *()[impl0]::_Fx': null,
    'TA$std::function::target@[_Fx] const *()[impl0]::_Fx': null,
    'TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Fx': null,
    'TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Ret': null,
    'TA$std::is_bind_expression@<::std::_Binder<[_Ret], [_Fx], [_Types]...>>::_Types': null,
    'TA$std::is_bind_expression@<[_Tx] const volatile>::_Tx': null,
    'TA$std::is_bind_expression@<[_Tx] const>::_Tx': null,
    'TA$std::is_bind_expression@<[_Tx] volatile>::_Tx': null,
    'TA$std::is_bind_expression_v::_Ty': null,
    'TA$std::is_placeholder@<::std::_Ph<*>>::_Nx': null,
    'TA$std::is_placeholder@<[_Tx] const volatile>::_Tx': null,
    'TA$std::is_placeholder@<[_Tx] const>::_Tx': null,
    'TA$std::is_placeholder@<[_Tx] volatile>::_Tx': null,
    'TA$std::is_placeholder_v::_Ty': null,
    'TA$std::logical_and::_Ty': null,
    'TA$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::logical_and@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::logical_not::_Ty': null,
    'TA$std::logical_not@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty': null,
    'TA$std::logical_or::_Ty': null,
    'TA$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::logical_or@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Rx': null,
    'TA$std::mem_fn@::std::_Mem_fn<[_Rx] ([_Ty] ::) *>([_Rx] ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun1_ref_t::_Arg': null,
    'TA$std::mem_fun1_ref_t::_Result': null,
    'TA$std::mem_fun1_ref_t::_Ty': null,
    'TA$std::mem_fun1_t::_Arg': null,
    'TA$std::mem_fun1_t::_Result': null,
    'TA$std::mem_fun1_t::_Ty': null,
    'TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg': null,
    'TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result': null,
    'TA$std::mem_fun@::std::const_mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result': null,
    'TA$std::mem_fun@::std::const_mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg': null,
    'TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result': null,
    'TA$std::mem_fun@::std::mem_fun1_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result': null,
    'TA$std::mem_fun@::std::mem_fun_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg': null,
    'TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result': null,
    'TA$std::mem_fun_ref@::std::const_mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result': null,
    'TA$std::mem_fun_ref@::std::const_mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Arg': null,
    'TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Result': null,
    'TA$std::mem_fun_ref@::std::mem_fun1_ref_t<[_Result], [_Ty], [_Arg]>([_Result]([_Arg]) ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Result': null,
    'TA$std::mem_fun_ref@::std::mem_fun_ref_t<[_Result], [_Ty]>([_Result]() ([_Ty] ::) *)[impl0]::_Ty': null,
    'TA$std::mem_fun_ref_t::_Result': null,
    'TA$std::mem_fun_ref_t::_Ty': null,
    'TA$std::mem_fun_t::_Result': null,
    'TA$std::mem_fun_t::_Ty': null,
    'TA$std::modulus::_Ty': null,
    'TA$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty1': null,
    'TA$std::modulus@<void>::operator ()@decltype(*)([_Ty1] &&, [_Ty2] &&)[impl0]::_Ty2': null,
    'TA$std::negate::_Ty': null,
    'TA$std::negate@<void>::operator ()@decltype(*)([_Ty] &&)[impl0]::_Ty': null,
    'TA$std::not1@::std::unary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn': null,
    'TA$std::not2@::std::binary_negate<[_Fn]>([_Fn] const &)[impl0]::_Fn': null,
    'TA$std::operator !=@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty': null,
    'TA$std::operator !=@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty': null,
    'TA$std::operator ==@bool(::std::function<[_Fty]> const &, ::std::nullptr_t)[impl0]::_Fty': null,
    'TA$std::operator ==@bool(::std::nullptr_t, ::std::function<[_Fty]> const &)[impl0]::_Fty': null,
    'TA$std::pointer_to_binary_function::_Arg1': null,
    'TA$std::pointer_to_binary_function::_Arg2': null,
    'TA$std::pointer_to_binary_function::_Fn': null,
    'TA$std::pointer_to_binary_function::_Result': null,
    'TA$std::pointer_to_unary_function::_Arg': null,
    'TA$std::pointer_to_unary_function::_Fn': null,
    'TA$std::pointer_to_unary_function::_Result': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg1': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Arg2': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)2[impl0]::_Result': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg1': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Arg2': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)3[impl0]::_Result': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg1': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Arg2': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)4[impl0]::_Result': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg1': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Arg2': null,
    'TA$std::ptr_fun@::std::pointer_to_binary_function<[_Arg1], [_Arg2], [_Result], [_Result]([_Arg1], [_Arg2]) *>([_Result]([_Arg1], [_Arg2]) *)[impl0]::_Result': null,
    'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Arg': null,
    'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)2[impl0]::_Result': null,
    'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Arg': null,
    'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)3[impl0]::_Result': null,
    'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Arg': null,
    'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)4[impl0]::_Result': null,
    'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Arg': null,
    'TA$std::ptr_fun@::std::pointer_to_unary_function<[_Arg], [_Result], [_Result]([_Arg]) *>([_Result]([_Arg]) *)[impl0]::_Result': null,
    'TA$std::swap@void(::std::function<[_Fty]> &, ::std::function<[_Fty]> &)[impl0]::_Fty': null,
    'TA$std::unary_negate::_Fn': null,
    'TA$std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Alloc': null,
    'TA$std::uses_allocator@<::std::function<[_Fty]>, [_Alloc]>::_Fty': null
};
turnOnSymbol();
</script>
</body>
</html>
