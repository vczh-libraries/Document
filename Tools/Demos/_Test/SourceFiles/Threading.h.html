<!DOCTYPE html>
<html>
<head>
    <title>Threading.h</title>
    <link rel="stylesheet" href="../../Cpp.css" />
    <link rel="shortcut icon" href="../../favicon.ico" />
    <script type="text/javascript" src="../../Cpp.js" ></script>
</head>
<body>
<a class="button" href="../FileIndex.html">File Index</a>
<a class="button" href="../SymbolIndex.html">Symbol Index</a>
<br>
<br>
<div class="codebox"><div class="cpp_default"><div class="token cpp_comment ">/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/</div>

<div class="disabled">#ifndef VCZH_THREADING</div>
<div class="disabled">#define VCZH_THREADING</div>

<div class="disabled">#include &lt;Vlpp.h&gt;</div>

<div class="token cpp_keyword ">namespace</div> <div class="def" id="NF[29]$vl"><div class="ref" onclick="jumpToSymbol([], ['vl'], [], [])">vl</div></div>
{
	
<div class="token cpp_comment ">/***********************************************************************
Kernel Mode Objects
***********************************************************************/</div>

	<div class="token cpp_keyword ">namespace</div> <div class="def" id="NF[0]$vl::threading_internal"><div>threading_internal</div></div>
	{
		<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$vl::threading_internal::WaitableData"><div><div class="token cpp_type">WaitableData</div></div></div>;
		<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$vl::threading_internal::ThreadData"><div><div class="token cpp_type">ThreadData</div></div></div>;
		<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$vl::threading_internal::MutexData"><div><div class="token cpp_type">MutexData</div></div></div>;
		<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$vl::threading_internal::SemaphoreData"><div><div class="token cpp_type">SemaphoreData</div></div></div>;
		<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$vl::threading_internal::EventData"><div><div class="token cpp_type">EventData</div></div></div>;
		<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$vl::threading_internal::CriticalSectionData"><div><div class="token cpp_type">CriticalSectionData</div></div></div>;
		<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$vl::threading_internal::ReaderWriterLockData"><div><div class="token cpp_type">ReaderWriterLockData</div></div></div>;
		<div class="token cpp_keyword ">struct</div> <div class="def" id="NF[0]$vl::threading_internal::ConditionVariableData"><div><div class="token cpp_type">ConditionVariableData</div></div></div>;
	}
	
	<div class="token cpp_comment ">/// &lt;summary&gt;Base type of all synchronization objects.&lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::WaitableObject"><div><div class="token cpp_type">WaitableObject</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
	{
<div class="disabled">#if defined VCZH_MSVC</div>
	<div class="token cpp_keyword ">private</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::WaitableData'], [], [])"><div class="token cpp_type">WaitableData</div></div>*			<div class="def" id="NI$vl::WaitableObject::waitableData"><div><div class="token cpp_field">waitableData</div></div></div>;
	<div class="token cpp_keyword ">protected</div>:

		<div class="def" id="FB$vl::WaitableObject::$__ctor@()[decl0]"><div><div class="token cpp_function">WaitableObject</div></div></div>();
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::WaitableObject::SetData@void(::vl::threading_internal::WaitableData *)[decl0]"><div><div class="token cpp_function">SetData</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::WaitableData'], [], [])"><div class="token cpp_type">WaitableData</div></div>* <div class="def" id="NI$vl::WaitableObject::SetData@void(::vl::threading_internal::WaitableData *)[decl0]::data"><div>data</div></div>);
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Test if the object has already been created. Some of the synchronization objects should initialize itself after the constructor.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the object has already been created.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::WaitableObject::IsCreated@bool()[decl0]"><div><div class="token cpp_function">IsCreated</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Wait for this object to signal.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the object is signaled. Returns false if this operation failed.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::WaitableObject::Wait@bool()[decl0]"><div><div class="token cpp_function">Wait</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Wait for this object to signal for a period of time.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the object is signaled. Returns false if this operation failed, including time out.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;ms&quot;&gt;Time in milliseconds.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::WaitableObject::WaitForTime@bool(::vl::vint)[decl0]"><div><div class="token cpp_function">WaitForTime</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::WaitableObject::WaitForTime@bool(::vl::vint)[decl0]::ms"><div>ms</div></div>);
		
		<div class="token cpp_comment ">/// &lt;summary&gt;Wait for multiple objects.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if all objects are signaled. Returns false if this operation failed.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;objects&quot;&gt;A pointer to an array to &lt;see cref=&quot;WaitableObject&quot;/&gt; pointers.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;count&quot;&gt;The number of &lt;see cref=&quot;WaitableObject&quot;/&gt; objects in the array.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">bool</div>									<div class="def" id="FB$vl::WaitableObject::WaitAll@bool(::vl::WaitableObject * *, ::vl::vint)[decl0]"><div><div class="token cpp_function">WaitAll</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::WaitableObject'], [], [])"><div class="token cpp_type">WaitableObject</div></div>** <div class="def" id="NI$vl::WaitableObject::WaitAll@bool(::vl::WaitableObject * *, ::vl::vint)[decl0]::objects"><div>objects</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::WaitableObject::WaitAll@bool(::vl::WaitableObject * *, ::vl::vint)[decl0]::count"><div>count</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Wait for multiple objects for a period of time.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if all objects are signaled. Returns false if this operation failed, including time out.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;objects&quot;&gt;A pointer to an array to &lt;see cref=&quot;WaitableObject&quot;/&gt; pointers.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;count&quot;&gt;The number of &lt;see cref=&quot;WaitableObject&quot;/&gt; objects in the array.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;ms&quot;&gt;Time in milliseconds.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">bool</div>									<div class="def" id="FB$vl::WaitableObject::WaitAllForTime@bool(::vl::WaitableObject * *, ::vl::vint, ::vl::vint)[decl0]"><div><div class="token cpp_function">WaitAllForTime</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::WaitableObject'], [], [])"><div class="token cpp_type">WaitableObject</div></div>** <div class="def" id="NI$vl::WaitableObject::WaitAllForTime@bool(::vl::WaitableObject * *, ::vl::vint, ::vl::vint)[decl0]::objects"><div>objects</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::WaitableObject::WaitAllForTime@bool(::vl::WaitableObject * *, ::vl::vint, ::vl::vint)[decl0]::count"><div>count</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::WaitableObject::WaitAllForTime@bool(::vl::WaitableObject * *, ::vl::vint, ::vl::vint)[decl0]::ms"><div>ms</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Wait for one of the objects.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns the index of the first signaled or abandoned object, according to the &quot;abandoned&quot; parameter. Returns -1 if this operation failed.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;objects&quot;&gt;A pointer to an array to &lt;see cref=&quot;WaitableObject&quot;/&gt; pointers.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;count&quot;&gt;The number of &lt;see cref=&quot;WaitableObject&quot;/&gt; objects in the array.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;abandoned&quot;&gt;Returns true if the waiting is canceled by an abandoned object. An abandoned object is caused by it&apos;s owner thread existing without releasing it.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>									<div class="def" id="FB$vl::WaitableObject::WaitAny@::vl::vint(::vl::WaitableObject * *, ::vl::vint, bool *)[decl0]"><div><div class="token cpp_function">WaitAny</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::WaitableObject'], [], [])"><div class="token cpp_type">WaitableObject</div></div>** <div class="def" id="NI$vl::WaitableObject::WaitAny@::vl::vint(::vl::WaitableObject * *, ::vl::vint, bool *)[decl0]::objects"><div>objects</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::WaitableObject::WaitAny@::vl::vint(::vl::WaitableObject * *, ::vl::vint, bool *)[decl0]::count"><div>count</div></div>, <div class="token cpp_keyword ">bool</div>* <div class="def" id="NI$vl::WaitableObject::WaitAny@::vl::vint(::vl::WaitableObject * *, ::vl::vint, bool *)[decl0]::abandoned"><div>abandoned</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Wait for one of the objects for a period of time.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns the index of the first signaled or abandoned object, according to the &quot;abandoned&quot; parameter. Returns -1 if this operation failed, including time out.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;objects&quot;&gt;A pointer to an array to &lt;see cref=&quot;WaitableObject&quot;/&gt; pointers.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;count&quot;&gt;The number of &lt;see cref=&quot;WaitableObject&quot;/&gt; objects in the array.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;ms&quot;&gt;Time in milliseconds.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;abandoned&quot;&gt;Returns true if the waiting is canceled by an abandoned object. An abandoned object is caused by it&apos;s owner thread existing without releasing it.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>									<div class="def" id="FB$vl::WaitableObject::WaitAnyForTime@::vl::vint(::vl::WaitableObject * *, ::vl::vint, ::vl::vint, bool *)[decl0]"><div><div class="token cpp_function">WaitAnyForTime</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::WaitableObject'], [], [])"><div class="token cpp_type">WaitableObject</div></div>** <div class="def" id="NI$vl::WaitableObject::WaitAnyForTime@::vl::vint(::vl::WaitableObject * *, ::vl::vint, ::vl::vint, bool *)[decl0]::objects"><div>objects</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::WaitableObject::WaitAnyForTime@::vl::vint(::vl::WaitableObject * *, ::vl::vint, ::vl::vint, bool *)[decl0]::count"><div>count</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::WaitableObject::WaitAnyForTime@::vl::vint(::vl::WaitableObject * *, ::vl::vint, ::vl::vint, bool *)[decl0]::ms"><div>ms</div></div>, <div class="token cpp_keyword ">bool</div>* <div class="def" id="NI$vl::WaitableObject::WaitAnyForTime@::vl::vint(::vl::WaitableObject * *, ::vl::vint, ::vl::vint, bool *)[decl0]::abandoned"><div>abandoned</div></div>);
<div class="disabled">#elif defined VCZH_GCC</div>
<div class="disabled">		virtual bool								Wait() = 0;
#endif</div>
	};

	<div class="token cpp_comment ">/// &lt;summary&gt;Thread. [M:vl.Thread.CreateAndStart] is the suggested way to create threads.&lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::Thread"><div><div class="token cpp_type">Thread</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WaitableObject'], [], [])"><div class="token cpp_type">WaitableObject</div></div>
	{
		<div class="token cpp_keyword ">friend</div> <div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::Thread::InternalThreadProc@void(::vl::Thread *)[decl0]"><div><div class="token cpp_function">InternalThreadProc</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::Thread'], [], [])"><div class="token cpp_type">Thread</div></div>* <div class="def" id="NI$vl::Thread::InternalThreadProc@void(::vl::Thread *)[decl0]::thread"><div>thread</div></div>);
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Thread state.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">enum</div> <div class="def" id="NI$vl::Thread::ThreadState"><div><div class="token cpp_type">ThreadState</div></div></div>
		{
			<div class="token cpp_comment ">/// &lt;summary&gt;The thread has not started.&lt;/summary&gt;</div>
			<div class="def" id="NI$vl::Thread::ThreadState::NotStarted"><div><div class="token cpp_enum">NotStarted</div></div></div>,
			<div class="token cpp_comment ">/// &lt;summary&gt;The thread is running.&lt;/summary&gt;</div>
			<div class="def" id="NI$vl::Thread::ThreadState::Running"><div><div class="token cpp_enum">Running</div></div></div>,
			<div class="token cpp_comment ">/// &lt;summary&gt;The thread has been stopped.&lt;/summary&gt;</div>
			<div class="def" id="NI$vl::Thread::ThreadState::Stopped"><div><div class="token cpp_enum">Stopped</div></div></div>
		};

		<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">void</div>(*<div class="def" id="NI$vl::Thread::ThreadProcedure"><div><div class="token cpp_type">ThreadProcedure</div></div></div>)(<div class="ref" onclick="jumpToSymbol([], ['vl::Thread'], [], [])"><div class="token cpp_type">Thread</div></div>*, <div class="token cpp_keyword ">void</div>*);
	<div class="token cpp_keyword ">protected</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::ThreadData'], [], [])"><div class="token cpp_type">ThreadData</div></div>*				<div class="def" id="NI$vl::Thread::internalData"><div><div class="token cpp_field">internalData</div></div></div>;
		<div class="token cpp_keyword ">volatile</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Thread::ThreadState'], [], [])"><div class="token cpp_type">ThreadState</div></div>						<div class="def" id="NI$vl::Thread::threadState"><div><div class="token cpp_field">threadState</div></div></div>;

		<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div>								<div class="def" id="FB$vl::Thread::Run@void()[decl0]"><div><div class="token cpp_function">Run</div></div></div>()=<div class="token cpp_number ">0</div>;

		<div class="def" id="FB$vl::Thread::$__ctor@()[decl0]"><div><div class="token cpp_function">Thread</div></div></div>();
	<div class="token cpp_keyword ">public</div>:
		<div class="def" id="FB$vl::Thread::~Thread@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">Thread</div></div></div>();

		<div class="token cpp_comment ">/// &lt;summary&gt;Create a thread using a function pointer.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns the created thread.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;procedure&quot;&gt;The function pointer.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;argument&quot;&gt;The argument to call the function pointer.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;deleteAfterStopped&quot;&gt;Set to true (by default) to make the thread delete itself after the job is done. If you set this argument to true, you are not recommended to touch the returned thread pointer in any way.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Thread'], [], [])"><div class="token cpp_type">Thread</div></div>*								<div class="def" id="FB$vl::Thread::CreateAndStart@::vl::Thread *(::vl::Thread::ThreadProcedure, void *, bool)[decl0]"><div><div class="token cpp_function">CreateAndStart</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::Thread::ThreadProcedure'], [], [])"><div class="token cpp_type">ThreadProcedure</div></div> <div class="def" id="NI$vl::Thread::CreateAndStart@::vl::Thread *(::vl::Thread::ThreadProcedure, void *, bool)[decl0]::procedure"><div>procedure</div></div>, <div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::Thread::CreateAndStart@::vl::Thread *(::vl::Thread::ThreadProcedure, void *, bool)[decl0]::argument"><div>argument</div></div>=<div class="token cpp_number ">0</div>, <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::Thread::CreateAndStart@::vl::Thread *(::vl::Thread::ThreadProcedure, void *, bool)[decl0]::deleteAfterStopped"><div>deleteAfterStopped</div></div>=<div class="token cpp_keyword ">true</div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a thread using a function object or a lambda expression.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns the created thread.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;procedure&quot;&gt;The function object or the lambda expression.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;deleteAfterStopped&quot;&gt;Set to true (by default) to make the thread delete itself after the job is done. If you set this argument to true, you are not recommended to touch the returned thread pointer in any way.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Thread'], [], [])"><div class="token cpp_type">Thread</div></div>*								<div class="def" id="FB$vl::Thread::CreateAndStart@::vl::Thread *(::vl::Func<void()> const &, bool)[decl0]"><div><div class="token cpp_function">CreateAndStart</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Func'], [], [])"><div class="token cpp_type">Func</div></div>&lt;<div class="token cpp_keyword ">void</div>()&gt;&amp; <div class="def" id="NI$vl::Thread::CreateAndStart@::vl::Thread *(::vl::Func<void()> const &, bool)[decl0]::procedure"><div>procedure</div></div>, <div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::Thread::CreateAndStart@::vl::Thread *(::vl::Func<void()> const &, bool)[decl0]::deleteAfterStopped"><div>deleteAfterStopped</div></div>=<div class="token cpp_keyword ">true</div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Pause the caller thread for a period of time.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;ms&quot;&gt;Time in milliseconds.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">void</div>									<div class="def" id="FB$vl::Thread::Sleep@void(::vl::vint)[decl0]"><div><div class="token cpp_function">Sleep</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::Thread::Sleep@void(::vl::vint)[decl0]::ms"><div>ms</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Get the number of logical processors.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;The number of logical processor.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>									<div class="def" id="FB$vl::Thread::GetCPUCount@::vl::vint()[decl0]"><div><div class="token cpp_function">GetCPUCount</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Get the current thread id.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;The current thread id.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>									<div class="def" id="FB$vl::Thread::GetCurrentThreadId@::vl::vint()[decl0]"><div><div class="token cpp_function">GetCurrentThreadId</div></div></div>();

		<div class="token cpp_comment ">/// &lt;summary&gt;Start the thread.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::Thread::Start@bool()[decl0]"><div><div class="token cpp_function">Start</div></div></div>();
<div class="disabled">#if defined VCZH_GCC</div>
<div class="disabled">		bool										Wait();
#endif</div>
		<div class="token cpp_comment ">/// &lt;summary&gt;Stop the thread.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::Thread::Stop@bool()[decl0]"><div><div class="token cpp_function">Stop</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Get the state of the thread.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;The state of the thread.&lt;/returns&gt;</div>
		<div class="ref" onclick="jumpToSymbol([], ['vl::Thread::ThreadState'], [], [])"><div class="token cpp_type">ThreadState</div></div>									<div class="def" id="FB$vl::Thread::GetState@::vl::Thread::ThreadState()[decl0]"><div><div class="token cpp_function">GetState</div></div></div>();
<div class="disabled">#ifdef VCZH_MSVC</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::Thread::SetCPU@void(::vl::vint)[decl0]"><div><div class="token cpp_function">SetCPU</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::Thread::SetCPU@void(::vl::vint)[decl0]::index"><div>index</div></div>);
<div class="disabled">#endif</div>
	};

	<div class="token cpp_comment ">/// &lt;summary&gt;Mutex.&lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::Mutex"><div><div class="token cpp_type">Mutex</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WaitableObject'], [], [])"><div class="token cpp_type">WaitableObject</div></div>
	{
	<div class="token cpp_keyword ">private</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::MutexData'], [], [])"><div class="token cpp_type">MutexData</div></div>*				<div class="def" id="NI$vl::Mutex::internalData"><div><div class="token cpp_field">internalData</div></div></div>;
	<div class="token cpp_keyword ">public</div>:
		<div class="def" id="FB$vl::Mutex::$__ctor@()[decl0]"><div><div class="token cpp_function">Mutex</div></div></div>();
		<div class="def" id="FB$vl::Mutex::~Mutex@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">Mutex</div></div></div>();

		<div class="token cpp_comment ">/// &lt;summary&gt;Create a mutex.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;owned&quot;&gt;Set to true to own the created mutex.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;name&quot;&gt;Name of the mutex. If it is not empty, than it is a global named mutex. This argument is ignored in Linux.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::Mutex::Create@bool(bool, ::vl::WString const &)[decl0]"><div><div class="token cpp_function">Create</div></div></div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::Mutex::Create@bool(bool, ::vl::WString const &)[decl0]::owned"><div>owned</div></div>=<div class="token cpp_keyword ">false</div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WString'], [], [])"><div class="token cpp_type">WString</div></div>&amp; <div class="def" id="NI$vl::Mutex::Create@bool(bool, ::vl::WString const &)[decl0]::name"><div>name</div></div>=<div class="token cpp_string ">L&quot;&quot;</div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Open an existing global named mutex.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;inheritable&quot;&gt;Set to true make the mutex visible to all all child processes. This argument is only used in Windows.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;name&quot;&gt;Name of the mutex. This argument is ignored in Linux.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::Mutex::Open@bool(bool, ::vl::WString const &)[decl0]"><div><div class="token cpp_function">Open</div></div></div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::Mutex::Open@bool(bool, ::vl::WString const &)[decl0]::inheritable"><div>inheritable</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WString'], [], [])"><div class="token cpp_type">WString</div></div>&amp; <div class="def" id="NI$vl::Mutex::Open@bool(bool, ::vl::WString const &)[decl0]::name"><div>name</div></div>);

		<div class="token cpp_comment ">/// &lt;summary&gt;</div>
		<div class="token cpp_comment ">/// Release the mutex.</div>
		<div class="token cpp_comment ">/// In Linux, calling Release() more than once between two Wait(), or calling Wait() more than once between two Release(), will results in an undefined behavior.</div>
		<div class="token cpp_comment ">/// &lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::Mutex::Release@bool()[decl0]"><div><div class="token cpp_function">Release</div></div></div>();
<div class="disabled">#ifdef VCZH_GCC</div>
<div class="disabled">		bool										Wait();</div>
<div class="disabled">#endif</div>
	};
	
	<div class="token cpp_comment ">/// &lt;summary&gt;Semaphore.&lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::Semaphore"><div><div class="token cpp_type">Semaphore</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WaitableObject'], [], [])"><div class="token cpp_type">WaitableObject</div></div>
	{
	<div class="token cpp_keyword ">private</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::SemaphoreData'], [], [])"><div class="token cpp_type">SemaphoreData</div></div>*			<div class="def" id="NI$vl::Semaphore::internalData"><div><div class="token cpp_field">internalData</div></div></div>;
	<div class="token cpp_keyword ">public</div>:
		<div class="def" id="FB$vl::Semaphore::$__ctor@()[decl0]"><div><div class="token cpp_function">Semaphore</div></div></div>();
		<div class="def" id="FB$vl::Semaphore::~Semaphore@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">Semaphore</div></div></div>();
		
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a semaphore.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;initialCount&quot;&gt;Define the counter of the semaphore.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;maxCount&quot;&gt;Define the maximum value of the counter of the semaphore. This argument is only used in Windows.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;name&quot;&gt;Name of the semaphore. If it is not empty, than it is a global named semaphore. This argument is ignored in Linux.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::Semaphore::Create@bool(::vl::vint, ::vl::vint, ::vl::WString const &)[decl0]"><div><div class="token cpp_function">Create</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::Semaphore::Create@bool(::vl::vint, ::vl::vint, ::vl::WString const &)[decl0]::initialCount"><div>initialCount</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::Semaphore::Create@bool(::vl::vint, ::vl::vint, ::vl::WString const &)[decl0]::maxCount"><div>maxCount</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WString'], [], [])"><div class="token cpp_type">WString</div></div>&amp; <div class="def" id="NI$vl::Semaphore::Create@bool(::vl::vint, ::vl::vint, ::vl::WString const &)[decl0]::name"><div>name</div></div>=<div class="token cpp_string ">L&quot;&quot;</div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Open an existing global named semaphore.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;inheritable&quot;&gt;Set to true make the semaphore visible to all all child processes. This argument is only used in Windows.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;name&quot;&gt;Name of the semaphore. This argument is ignored in Linux.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::Semaphore::Open@bool(bool, ::vl::WString const &)[decl0]"><div><div class="token cpp_function">Open</div></div></div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::Semaphore::Open@bool(bool, ::vl::WString const &)[decl0]::inheritable"><div>inheritable</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WString'], [], [])"><div class="token cpp_type">WString</div></div>&amp; <div class="def" id="NI$vl::Semaphore::Open@bool(bool, ::vl::WString const &)[decl0]::name"><div>name</div></div>);
		
		<div class="token cpp_comment ">/// &lt;summary&gt; Release the semaphore once. &lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::Semaphore::Release@bool()[decl0]"><div><div class="token cpp_function">Release</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt; Release the semaphore multiple times. &lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;count&quot;&gt;The amout to release.&lt;/param&gt;</div>
		<div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div>										<div class="def" id="FB$vl::Semaphore::Release@::vl::vint(::vl::vint)[decl0]"><div><div class="token cpp_function">Release</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::Semaphore::Release@::vl::vint(::vl::vint)[decl0]::count"><div>count</div></div>);
<div class="disabled">#ifdef VCZH_GCC</div>
<div class="disabled">		bool										Wait();</div>
<div class="disabled">#endif</div>
	};

	<div class="token cpp_comment ">/// &lt;summary&gt;Event.&lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::EventObject"><div><div class="token cpp_type">EventObject</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WaitableObject'], [], [])"><div class="token cpp_type">WaitableObject</div></div>
	{
	<div class="token cpp_keyword ">private</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::EventData'], [], [])"><div class="token cpp_type">EventData</div></div>*				<div class="def" id="NI$vl::EventObject::internalData"><div><div class="token cpp_field">internalData</div></div></div>;
	<div class="token cpp_keyword ">public</div>:
		<div class="def" id="FB$vl::EventObject::$__ctor@()[decl0]"><div><div class="token cpp_function">EventObject</div></div></div>();
		<div class="def" id="FB$vl::EventObject::~EventObject@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">EventObject</div></div></div>();
		
		<div class="token cpp_comment ">/// &lt;summary&gt;Create an auto unsignal event. Auto unsignal means, when one thread waits for the event and succeeded, the event will become unsignaled immediately.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;signaled&quot;&gt;Set to true make the event signaled at the beginning.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;name&quot;&gt;Name of the event. If it is not empty, than it is a global named mutex. This argument is only used in Windows.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::EventObject::CreateAutoUnsignal@bool(bool, ::vl::WString const &)[decl0]"><div><div class="token cpp_function">CreateAutoUnsignal</div></div></div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::EventObject::CreateAutoUnsignal@bool(bool, ::vl::WString const &)[decl0]::signaled"><div>signaled</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WString'], [], [])"><div class="token cpp_type">WString</div></div>&amp; <div class="def" id="NI$vl::EventObject::CreateAutoUnsignal@bool(bool, ::vl::WString const &)[decl0]::name"><div>name</div></div>=<div class="token cpp_string ">L&quot;&quot;</div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a manual unsignal event.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;signaled&quot;&gt;Set to true make the event signaled at the beginning.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;name&quot;&gt;Name of the event. If it is not empty, than it is a global named mutex. This argument is only used in Windows.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::EventObject::CreateManualUnsignal@bool(bool, ::vl::WString const &)[decl0]"><div><div class="token cpp_function">CreateManualUnsignal</div></div></div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::EventObject::CreateManualUnsignal@bool(bool, ::vl::WString const &)[decl0]::signaled"><div>signaled</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WString'], [], [])"><div class="token cpp_type">WString</div></div>&amp; <div class="def" id="NI$vl::EventObject::CreateManualUnsignal@bool(bool, ::vl::WString const &)[decl0]::name"><div>name</div></div>=<div class="token cpp_string ">L&quot;&quot;</div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Open an existing global named event.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;inheritable&quot;&gt;Set to true make the event visible to all all child processes. This argument is only used in Windows.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;name&quot;&gt;Name of the event. This argument is only used in Windows.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::EventObject::Open@bool(bool, ::vl::WString const &)[decl0]"><div><div class="token cpp_function">Open</div></div></div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::EventObject::Open@bool(bool, ::vl::WString const &)[decl0]::inheritable"><div>inheritable</div></div>, <div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::WString'], [], [])"><div class="token cpp_type">WString</div></div>&amp; <div class="def" id="NI$vl::EventObject::Open@bool(bool, ::vl::WString const &)[decl0]::name"><div>name</div></div>);

		<div class="token cpp_comment ">/// &lt;summary&gt;Signal the event.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::EventObject::Signal@bool()[decl0]"><div><div class="token cpp_function">Signal</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Unsignal the event.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::EventObject::Unsignal@bool()[decl0]"><div><div class="token cpp_function">Unsignal</div></div></div>();
<div class="disabled">#ifdef VCZH_GCC</div>
<div class="disabled">		bool										Wait();</div>
<div class="disabled">#endif</div>
	};

<div class="token cpp_comment ">/***********************************************************************
Thread Pool
***********************************************************************/</div>

	<div class="token cpp_comment ">/// &lt;summary&gt;A light-weight thread pool.&lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::ThreadPoolLite"><div><div class="token cpp_type">ThreadPoolLite</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>
	{
	<div class="token cpp_keyword ">private</div>:
		<div class="def" id="FB$vl::ThreadPoolLite::$__ctor@()[decl0]"><div><div class="token cpp_function">ThreadPoolLite</div></div></div>();
		<div class="def" id="FB$vl::ThreadPoolLite::~ThreadPoolLite@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">ThreadPoolLite</div></div></div>();
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Queue a function pointer.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;proc&quot;&gt;The function pointer.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;argument&quot;&gt;The argument to call the function pointer.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">bool</div>									<div class="def" id="FB$vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)[decl0]"><div><div class="token cpp_function">Queue</div></div></div>(<div class="token cpp_keyword ">void</div>(*<div class="def" id="NI$vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)[decl0]::proc"><div>proc</div></div>)(<div class="token cpp_keyword ">void</div>*), <div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)[decl0]::argument"><div>argument</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Queue a function object.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;proc&quot;&gt;The function object.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">bool</div>									<div class="def" id="FB$vl::ThreadPoolLite::Queue@bool(::vl::Func<void()> const &)[decl0]"><div><div class="token cpp_function">Queue</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol(['vl::Func@<[R]([TArgs]...)>'], ['vl::Func'], [], [])"><div class="token cpp_type">Func</div></div>&lt;<div class="token cpp_keyword ">void</div>()&gt;&amp; <div class="def" id="NI$vl::ThreadPoolLite::Queue@bool(::vl::Func<void()> const &)[decl0]::proc"><div>proc</div></div>);
		
		<div class="token cpp_comment ">/// &lt;summary&gt;Queue a lambda expression.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;typeparam name=&quot;T&quot;&gt;The type of the lambda expression.&lt;/typeparam&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;proc&quot;&gt;The lambda expression.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">typename</div> <div class="def" id="TA$vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::T"><div><div class="token cpp_type">T</div></div></div>&gt;
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]"><div><div class="token cpp_function">QueueLambda</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::T'], [], [])"><div class="token cpp_type">T</div></div>&amp; <div class="def" id="NI$vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::proc"><div><div class="token cpp_argument">proc</div></div></div>)
		{
			<div class="ref" onclick="jumpToSymbol(['vl::ThreadPoolLite::Queue@bool(::vl::Func<void()> const &)'], ['vl::ThreadPoolLite::Queue@bool(::vl::Func<void()> const &)', 'vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)'], [], [])"><div class="token cpp_function">Queue</div></div>(<div class="ref" onclick="jumpToSymbol(['vl::Func@<[R]([TArgs]...)>'], ['vl::Func'], [], [])"><div class="token cpp_type">Func</div></div>&lt;<div class="token cpp_keyword ">void</div>()&gt;(<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::proc'], [], [])"><div class="token cpp_argument">proc</div></div>));
		}

<div class="disabled">#ifdef VCZH_GCC</div>
<div class="disabled">		static bool									Stop(bool discardPendingTasks);</div>
<div class="disabled">#endif</div>
	};

<div class="token cpp_comment ">/***********************************************************************
Kernel Mode Objects in Process
***********************************************************************/</div>

	<div class="token cpp_comment ">/// &lt;summary&gt;</div>
	<div class="token cpp_comment ">/// Critical section.</div>
	<div class="token cpp_comment ">/// The macro &quot;CS_LOCK&quot; is recommended instead of calling [M:vl.CriticalSection.Enter] and [M:vl.CriticalSection.Leave] like this:</div>
	<div class="token cpp_comment ">/// &lt;program&gt;&lt;code&gt;&lt;![CDATA[</div>
	<div class="token cpp_comment ">/// CS_LOCK(yourCriticalSection)</div>
	<div class="token cpp_comment ">/// {</div>
	<div class="token cpp_comment ">///     // do something</div>
	<div class="token cpp_comment ">/// }</div>
	<div class="token cpp_comment ">/// ]]&gt;&lt;/code&gt;&lt;/program&gt;</div>
	<div class="token cpp_comment ">/// &lt;/summary&gt;</div>
	<div class="token cpp_comment ">/// &lt;remarks&gt;</div>
	<div class="token cpp_comment ">/// In Windows, enter a owned critical section will not result in dead lock.</div>
	<div class="token cpp_comment ">/// In Linux and macOS, it works like a mutex.</div>
	<div class="token cpp_comment ">/// &lt;/remarks&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::CriticalSection"><div><div class="token cpp_type">CriticalSection</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
	{
	<div class="token cpp_keyword ">private</div>:
		<div class="token cpp_keyword ">friend</div> <div class="token cpp_keyword ">class</div> <div class="ref" onclick="jumpToSymbol([], ['vl::ConditionVariable'], [], [])"><div class="token cpp_type">ConditionVariable</div></div>;
		<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::CriticalSectionData'], [], [])"><div class="token cpp_type">CriticalSectionData</div></div>*	<div class="def" id="NI$vl::CriticalSection::internalData"><div><div class="token cpp_field">internalData</div></div></div>;
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a critical section.&lt;/summary&gt;</div>
		<div class="def" id="FB$vl::CriticalSection::$__ctor@()[decl0]"><div><div class="token cpp_function">CriticalSection</div></div></div>();
		<div class="def" id="FB$vl::CriticalSection::~CriticalSection@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">CriticalSection</div></div></div>();

		<div class="token cpp_comment ">/// &lt;summary&gt;Try enter a critical section. This function will return immediately.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the current thread owned the critical section.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::CriticalSection::TryEnter@bool()[decl0]"><div><div class="token cpp_function">TryEnter</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Enter a critical section.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::CriticalSection::Enter@void()[decl0]"><div><div class="token cpp_function">Enter</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Leave a critical section.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::CriticalSection::Leave@void()[decl0]"><div><div class="token cpp_function">Leave</div></div></div>();

	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::CriticalSection::Scope"><div><div class="token cpp_type">Scope</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
		{
		<div class="token cpp_keyword ">private</div>:
			<div class="ref" onclick="jumpToSymbol([], ['vl::CriticalSection'], [], [])"><div class="token cpp_type">CriticalSection</div></div>*						<div class="def" id="NI$vl::CriticalSection::Scope::criticalSection"><div><div class="token cpp_field">criticalSection</div></div></div>;
		<div class="token cpp_keyword ">public</div>:
			<div class="def" id="FB$vl::CriticalSection::Scope::$__ctor@(::vl::CriticalSection &)[decl0]"><div><div class="token cpp_function">Scope</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::CriticalSection'], [], [])"><div class="token cpp_type">CriticalSection</div></div>&amp; <div class="def" id="NI$vl::CriticalSection::Scope::$__ctor@(::vl::CriticalSection &)[decl0]::_criticalSection"><div>_criticalSection</div></div>);
			<div class="def" id="FB$vl::CriticalSection::Scope::~Scope@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">Scope</div></div></div>();
		};
	};
	
	<div class="token cpp_comment ">/// &lt;summary&gt;</div>
	<div class="token cpp_comment ">/// Reader writer lock.</div>
	<div class="token cpp_comment ">/// The macro &quot;READER_LOCK&quot; and &quot;WRITER_LOCK&quot; are recommended instead of calling [M:vl.ReaderWriterLock.EnterReader], [M:vl.ReaderWriterLock.LeaveReader], [M:vl.ReaderWriterLock.EnterWriter] and [M:vl.ReaderWriterLock.LeaveWriter] like this:</div>
	<div class="token cpp_comment ">/// &lt;program&gt;&lt;code&gt;&lt;![CDATA[</div>
	<div class="token cpp_comment ">/// READER_LOCK(yourLock)</div>
	<div class="token cpp_comment ">/// {</div>
	<div class="token cpp_comment ">///     // do something</div>
	<div class="token cpp_comment ">/// }</div>
	<div class="token cpp_comment ">/// ]]&gt;&lt;/code&gt;&lt;/program&gt;</div>
	<div class="token cpp_comment ">/// or</div>
	<div class="token cpp_comment ">/// &lt;program&gt;&lt;code&gt;&lt;![CDATA[</div>
	<div class="token cpp_comment ">/// WRITER_LOCK(yourLock)</div>
	<div class="token cpp_comment ">/// {</div>
	<div class="token cpp_comment ">///     // do something</div>
	<div class="token cpp_comment ">/// }</div>
	<div class="token cpp_comment ">/// ]]&gt;&lt;/code&gt;&lt;/program&gt;</div>
	<div class="token cpp_comment ">/// &lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::ReaderWriterLock"><div><div class="token cpp_type">ReaderWriterLock</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
	{
	<div class="token cpp_keyword ">private</div>:
		<div class="token cpp_keyword ">friend</div> <div class="token cpp_keyword ">class</div> <div class="ref" onclick="jumpToSymbol([], ['vl::ConditionVariable'], [], [])"><div class="token cpp_type">ConditionVariable</div></div>;
		<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::ReaderWriterLockData'], [], [])"><div class="token cpp_type">ReaderWriterLockData</div></div>*	<div class="def" id="NI$vl::ReaderWriterLock::internalData"><div><div class="token cpp_field">internalData</div></div></div>;
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a reader writer lock.&lt;/summary&gt;</div>
		<div class="def" id="FB$vl::ReaderWriterLock::$__ctor@()[decl0]"><div><div class="token cpp_function">ReaderWriterLock</div></div></div>();
		<div class="def" id="FB$vl::ReaderWriterLock::~ReaderWriterLock@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">ReaderWriterLock</div></div></div>();
		
		<div class="token cpp_comment ">/// &lt;summary&gt;Try acquire a reader lock. This function will return immediately.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the current thread acquired the reader lock.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::ReaderWriterLock::TryEnterReader@bool()[decl0]"><div><div class="token cpp_function">TryEnterReader</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Acquire a reader lock.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::ReaderWriterLock::EnterReader@void()[decl0]"><div><div class="token cpp_function">EnterReader</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Release a reader lock.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::ReaderWriterLock::LeaveReader@void()[decl0]"><div><div class="token cpp_function">LeaveReader</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Try acquire a writer lock. This function will return immediately.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the current thread acquired the writer lock.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::ReaderWriterLock::TryEnterWriter@bool()[decl0]"><div><div class="token cpp_function">TryEnterWriter</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Acquire a writer lock.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::ReaderWriterLock::EnterWriter@void()[decl0]"><div><div class="token cpp_function">EnterWriter</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Release a writer lock.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::ReaderWriterLock::LeaveWriter@void()[decl0]"><div><div class="token cpp_function">LeaveWriter</div></div></div>();
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::ReaderWriterLock::ReaderScope"><div><div class="token cpp_type">ReaderScope</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
		{
		<div class="token cpp_keyword ">private</div>:
			<div class="ref" onclick="jumpToSymbol([], ['vl::ReaderWriterLock'], [], [])"><div class="token cpp_type">ReaderWriterLock</div></div>*						<div class="def" id="NI$vl::ReaderWriterLock::ReaderScope::lock"><div><div class="token cpp_field">lock</div></div></div>;
		<div class="token cpp_keyword ">public</div>:
			<div class="def" id="FB$vl::ReaderWriterLock::ReaderScope::$__ctor@(::vl::ReaderWriterLock &)[decl0]"><div><div class="token cpp_function">ReaderScope</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ReaderWriterLock'], [], [])"><div class="token cpp_type">ReaderWriterLock</div></div>&amp; <div class="def" id="NI$vl::ReaderWriterLock::ReaderScope::$__ctor@(::vl::ReaderWriterLock &)[decl0]::_lock"><div>_lock</div></div>);
			<div class="def" id="FB$vl::ReaderWriterLock::ReaderScope::~ReaderScope@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">ReaderScope</div></div></div>();
		};
		
		<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::ReaderWriterLock::WriterScope"><div><div class="token cpp_type">WriterScope</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
		{
		<div class="token cpp_keyword ">private</div>:
			<div class="ref" onclick="jumpToSymbol([], ['vl::ReaderWriterLock'], [], [])"><div class="token cpp_type">ReaderWriterLock</div></div>*						<div class="def" id="NI$vl::ReaderWriterLock::WriterScope::lock"><div><div class="token cpp_field">lock</div></div></div>;
		<div class="token cpp_keyword ">public</div>:
			<div class="def" id="FB$vl::ReaderWriterLock::WriterScope::$__ctor@(::vl::ReaderWriterLock &)[decl0]"><div><div class="token cpp_function">WriterScope</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ReaderWriterLock'], [], [])"><div class="token cpp_type">ReaderWriterLock</div></div>&amp; <div class="def" id="NI$vl::ReaderWriterLock::WriterScope::$__ctor@(::vl::ReaderWriterLock &)[decl0]::_lock"><div>_lock</div></div>);
			<div class="def" id="FB$vl::ReaderWriterLock::WriterScope::~WriterScope@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">WriterScope</div></div></div>();
		};
	};

	<div class="token cpp_comment ">/// &lt;summary&gt;Conditional variable.&lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::ConditionVariable"><div><div class="token cpp_type">ConditionVariable</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
	{
	<div class="token cpp_keyword ">private</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal'], [], [])">threading_internal</div>::<div class="ref" onclick="jumpToSymbol([], ['vl::threading_internal::ConditionVariableData'], [], [])"><div class="token cpp_type">ConditionVariableData</div></div>*	<div class="def" id="NI$vl::ConditionVariable::internalData"><div><div class="token cpp_field">internalData</div></div></div>;
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a conditional variable.&lt;/summary&gt;</div>
		<div class="def" id="FB$vl::ConditionVariable::$__ctor@()[decl0]"><div><div class="token cpp_function">ConditionVariable</div></div></div>();
		<div class="def" id="FB$vl::ConditionVariable::~ConditionVariable@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">ConditionVariable</div></div></div>();

		<div class="token cpp_comment ">/// &lt;summary&gt;Bind a conditional variable with a owned critical section and release it. When the function returns, the condition variable is activated, and the current thread owned the critical section again.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;cs&quot;&gt;The critical section.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::ConditionVariable::SleepWith@bool(::vl::CriticalSection &)[decl0]"><div><div class="token cpp_function">SleepWith</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::CriticalSection'], [], [])"><div class="token cpp_type">CriticalSection</div></div>&amp; <div class="def" id="NI$vl::ConditionVariable::SleepWith@bool(::vl::CriticalSection &)[decl0]::cs"><div>cs</div></div>);
<div class="disabled">#ifdef VCZH_MSVC</div>
		<div class="token cpp_comment ">/// &lt;summary&gt;Bind a conditional variable with a owned critical section and release it for a period of time. When the function returns, the condition variable is activated or it is time out, and the current thread owned the critical section again.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;cs&quot;&gt;The critical section.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;ms&quot;&gt;Time in milliseconds.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::ConditionVariable::SleepWithForTime@bool(::vl::CriticalSection &, ::vl::vint)[decl0]"><div><div class="token cpp_function">SleepWithForTime</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::CriticalSection'], [], [])"><div class="token cpp_type">CriticalSection</div></div>&amp; <div class="def" id="NI$vl::ConditionVariable::SleepWithForTime@bool(::vl::CriticalSection &, ::vl::vint)[decl0]::cs"><div>cs</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::ConditionVariable::SleepWithForTime@bool(::vl::CriticalSection &, ::vl::vint)[decl0]::ms"><div>ms</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Bind a conditional variable with a owned reader lock and release it. When the function returns, the condition variable is activated, and the current thread owned the reader lock again.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;lock&quot;&gt;The reader lock.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::ConditionVariable::SleepWithReader@bool(::vl::ReaderWriterLock &)[decl0]"><div><div class="token cpp_function">SleepWithReader</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ReaderWriterLock'], [], [])"><div class="token cpp_type">ReaderWriterLock</div></div>&amp; <div class="def" id="NI$vl::ConditionVariable::SleepWithReader@bool(::vl::ReaderWriterLock &)[decl0]::lock"><div>lock</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Bind a conditional variable with a owned reader lock and release it for a period of time. When the function returns, the condition variable is activated or it is time out, and the current thread owned the reader lock again.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;lock&quot;&gt;The reader lock.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;ms&quot;&gt;Time in milliseconds.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::ConditionVariable::SleepWithReaderForTime@bool(::vl::ReaderWriterLock &, ::vl::vint)[decl0]"><div><div class="token cpp_function">SleepWithReaderForTime</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ReaderWriterLock'], [], [])"><div class="token cpp_type">ReaderWriterLock</div></div>&amp; <div class="def" id="NI$vl::ConditionVariable::SleepWithReaderForTime@bool(::vl::ReaderWriterLock &, ::vl::vint)[decl0]::lock"><div>lock</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::ConditionVariable::SleepWithReaderForTime@bool(::vl::ReaderWriterLock &, ::vl::vint)[decl0]::ms"><div>ms</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Bind a conditional variable with a owned writer lock and release it. When the function returns, the condition variable is activated, and the current thread owned the writer lock again.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;lock&quot;&gt;The writer lock.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::ConditionVariable::SleepWithWriter@bool(::vl::ReaderWriterLock &)[decl0]"><div><div class="token cpp_function">SleepWithWriter</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ReaderWriterLock'], [], [])"><div class="token cpp_type">ReaderWriterLock</div></div>&amp; <div class="def" id="NI$vl::ConditionVariable::SleepWithWriter@bool(::vl::ReaderWriterLock &)[decl0]::lock"><div>lock</div></div>);
		<div class="token cpp_comment ">/// &lt;summary&gt;Bind a conditional variable with a owned writer lock and release it for a period of time. When the function returns, the condition variable is activated or it is time out, and the current thread owned the writer lock again.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if this operation succeeded.&lt;/returns&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;lock&quot;&gt;The writer lock.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;ms&quot;&gt;Time in milliseconds.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;This function is only available in Windows.&lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::ConditionVariable::SleepWithWriterForTime@bool(::vl::ReaderWriterLock &, ::vl::vint)[decl0]"><div><div class="token cpp_function">SleepWithWriterForTime</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ReaderWriterLock'], [], [])"><div class="token cpp_type">ReaderWriterLock</div></div>&amp; <div class="def" id="NI$vl::ConditionVariable::SleepWithWriterForTime@bool(::vl::ReaderWriterLock &, ::vl::vint)[decl0]::lock"><div>lock</div></div>, <div class="ref" onclick="jumpToSymbol([], ['vl::vint'], [], [])"><div class="token cpp_type">vint</div></div> <div class="def" id="NI$vl::ConditionVariable::SleepWithWriterForTime@bool(::vl::ReaderWriterLock &, ::vl::vint)[decl0]::ms"><div>ms</div></div>);
<div class="disabled">#endif</div>
		<div class="token cpp_comment ">/// &lt;summary&gt;Wake one thread that pending on this condition variable.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::ConditionVariable::WakeOnePending@void()[decl0]"><div><div class="token cpp_function">WakeOnePending</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Wake all thread that pending on this condition variable.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::ConditionVariable::WakeAllPendings@void()[decl0]"><div><div class="token cpp_function">WakeAllPendings</div></div></div>();
	};

<div class="token cpp_comment ">/***********************************************************************
User Mode Objects
***********************************************************************/</div>

	<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">long</div> <div class="def" id="NI$vl::LockedInt"><div><div class="token cpp_type">LockedInt</div></div></div>;
	
	<div class="token cpp_comment ">/// &lt;summary&gt;</div>
	<div class="token cpp_comment ">/// Spin lock. It is similar to mutex, but it does not occupy resource in the system.</div>
	<div class="token cpp_comment ">/// The macro &quot;SPIN_LOCK&quot; is recommended instead of calling [M:vl.SpinLock.Enter] and [M:vl.SpinLock.Leave] like this:</div>
	<div class="token cpp_comment ">/// &lt;program&gt;&lt;code&gt;&lt;![CDATA[</div>
	<div class="token cpp_comment ">/// SPIN_LOCK(yourLock)</div>
	<div class="token cpp_comment ">/// {</div>
	<div class="token cpp_comment ">///     // do something</div>
	<div class="token cpp_comment ">/// }</div>
	<div class="token cpp_comment ">/// ]]&gt;&lt;/code&gt;&lt;/program&gt;</div>
	<div class="token cpp_comment ">/// &lt;/summary&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::SpinLock"><div><div class="token cpp_type">SpinLock</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
	{
	<div class="token cpp_keyword ">protected</div>:
		<div class="token cpp_keyword ">volatile</div> <div class="ref" onclick="jumpToSymbol([], ['vl::LockedInt'], [], [])"><div class="token cpp_type">LockedInt</div></div>							<div class="def" id="NI$vl::SpinLock::token"><div><div class="token cpp_field">token</div></div></div>;
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a spin lock.&lt;/summary&gt;</div>
		<div class="def" id="FB$vl::SpinLock::$__ctor@()[decl0]"><div><div class="token cpp_function">SpinLock</div></div></div>();
		<div class="def" id="FB$vl::SpinLock::~SpinLock@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">SpinLock</div></div></div>();
		
		<div class="token cpp_comment ">/// &lt;summary&gt;Try enter a spin lock. This function will return immediately.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the current thread owned the spin lock.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div>										<div class="def" id="FB$vl::SpinLock::TryEnter@bool()[decl0]"><div><div class="token cpp_function">TryEnter</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Enter a spin lock.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::SpinLock::Enter@void()[decl0]"><div><div class="token cpp_function">Enter</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Leave a spin lock.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div>										<div class="def" id="FB$vl::SpinLock::Leave@void()[decl0]"><div><div class="token cpp_function">Leave</div></div></div>();

	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::SpinLock::Scope"><div><div class="token cpp_type">Scope</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
		{
		<div class="token cpp_keyword ">private</div>:
			<div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock'], [], [])"><div class="token cpp_type">SpinLock</div></div>*								<div class="def" id="NI$vl::SpinLock::Scope::spinLock"><div><div class="token cpp_field">spinLock</div></div></div>;
		<div class="token cpp_keyword ">public</div>:
			<div class="def" id="FB$vl::SpinLock::Scope::$__ctor@(::vl::SpinLock &)[decl0]"><div><div class="token cpp_function">Scope</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock'], [], [])"><div class="token cpp_type">SpinLock</div></div>&amp; <div class="def" id="NI$vl::SpinLock::Scope::$__ctor@(::vl::SpinLock &)[decl0]::_spinLock"><div>_spinLock</div></div>);
			<div class="def" id="FB$vl::SpinLock::Scope::~Scope@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">Scope</div></div></div>();
		};
	};

<div class="disabled">#define SPIN_LOCK(LOCK) SCOPE_VARIABLE(const SpinLock::Scope&amp;, scope, LOCK)</div>
<div class="disabled">#define CS_LOCK(LOCK) SCOPE_VARIABLE(const CriticalSection::Scope&amp;, scope, LOCK)</div>
<div class="disabled">#define READER_LOCK(LOCK) SCOPE_VARIABLE(const ReaderWriterLock::ReaderScope&amp;, scope, LOCK)</div>
<div class="disabled">#define WRITER_LOCK(LOCK) SCOPE_VARIABLE(const ReaderWriterLock::WriterScope&amp;, scope, LOCK)</div>

<div class="token cpp_comment ">/***********************************************************************
Thread Local Storage
***********************************************************************/</div>

	<div class="token cpp_comment ">/// &lt;summary&gt;Thread local storage operations.&lt;/summary&gt;</div>
	<div class="token cpp_comment ">/// &lt;remarks&gt;</div>
	<div class="token cpp_comment ">/// This class is designed to define global variables.</div>
	<div class="token cpp_comment ">/// Dynamically allocation will result in undefined behavior.</div>
	<div class="token cpp_comment ">/// &lt;/remarks&gt;</div>
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::ThreadLocalStorage"><div><div class="token cpp_type">ThreadLocalStorage</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">private</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
	{
		<div class="token cpp_keyword ">typedef</div> <div class="token cpp_keyword ">void</div>(*<div class="def" id="NI$vl::ThreadLocalStorage::Destructor"><div><div class="token cpp_type">Destructor</div></div></div>)(<div class="token cpp_keyword ">void</div>*);
	<div class="token cpp_keyword ">protected</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::vuint64_t'], [], [])"><div class="token cpp_type">vuint64_t</div></div>								<div class="def" id="NI$vl::ThreadLocalStorage::key"><div><div class="token cpp_field">key</div></div></div>;
		<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadLocalStorage::Destructor'], [], [])"><div class="token cpp_type">Destructor</div></div>								<div class="def" id="NI$vl::ThreadLocalStorage::destructor"><div><div class="token cpp_field">destructor</div></div></div>;
		<div class="token cpp_keyword ">volatile</div> <div class="token cpp_keyword ">bool</div>							<div class="def" id="NI$vl::ThreadLocalStorage::disposed"><div><div class="token cpp_field">disposed</div></div></div> = <div class="token cpp_keyword ">false</div>;
		
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">void</div>								<div class="def" id="FB$vl::ThreadLocalStorage::PushStorage@void(::vl::ThreadLocalStorage *)[decl0]"><div><div class="token cpp_function">PushStorage</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadLocalStorage'], [], [])"><div class="token cpp_type">ThreadLocalStorage</div></div>* <div class="def" id="NI$vl::ThreadLocalStorage::PushStorage@void(::vl::ThreadLocalStorage *)[decl0]::storage"><div>storage</div></div>);
	<div class="token cpp_keyword ">public</div>:
		<div class="def" id="FB$vl::ThreadLocalStorage::$__ctor@(::vl::ThreadLocalStorage::Destructor)[decl0]"><div><div class="token cpp_function">ThreadLocalStorage</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadLocalStorage::Destructor'], [], [])"><div class="token cpp_type">Destructor</div></div> <div class="def" id="NI$vl::ThreadLocalStorage::$__ctor@(::vl::ThreadLocalStorage::Destructor)[decl0]::_destructor"><div>_destructor</div></div>);
		<div class="def" id="FB$vl::ThreadLocalStorage::~ThreadLocalStorage@()[decl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">ThreadLocalStorage</div></div></div>();

		<div class="token cpp_keyword ">void</div>*									<div class="def" id="FB$vl::ThreadLocalStorage::Get@void *()[decl0]"><div><div class="token cpp_function">Get</div></div></div>();
		<div class="token cpp_keyword ">void</div>									<div class="def" id="FB$vl::ThreadLocalStorage::Set@void(void *)[decl0]"><div><div class="token cpp_function">Set</div></div></div>(<div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::ThreadLocalStorage::Set@void(void *)[decl0]::data"><div>data</div></div>);
		<div class="token cpp_keyword ">void</div>									<div class="def" id="FB$vl::ThreadLocalStorage::Clear@void()[decl0]"><div><div class="token cpp_function">Clear</div></div></div>();
		<div class="token cpp_keyword ">void</div>									<div class="def" id="FB$vl::ThreadLocalStorage::Dispose@void()[decl0]"><div><div class="token cpp_function">Dispose</div></div></div>();

		<div class="token cpp_comment ">/// &lt;summary&gt;Fix all storage creation.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">void</div>								<div class="def" id="FB$vl::ThreadLocalStorage::FixStorages@void()[decl0]"><div><div class="token cpp_function">FixStorages</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Clear all storages for the current thread. For threads that are created using [T:vl.Thread], this function will be automatically called when before the thread exit.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">void</div>								<div class="def" id="FB$vl::ThreadLocalStorage::ClearStorages@void()[decl0]"><div><div class="token cpp_function">ClearStorages</div></div></div>();
		<div class="token cpp_comment ">/// &lt;summary&gt;Clear all storages for the current thread (should be the main thread) and clear all records. This function can only be called by the main thread when all other threads are exited. It will reduce noices for detecting memory leaks.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">void</div>								<div class="def" id="FB$vl::ThreadLocalStorage::DisposeStorages@void()[decl0]"><div><div class="token cpp_function">DisposeStorages</div></div></div>();
	};

	<div class="token cpp_comment ">/// &lt;summary&gt;Thread local variable. Different threads can store different values to and obtain differnt values from a thread local variable.&lt;/summary&gt;</div>
	<div class="token cpp_comment ">/// &lt;typeparam name=&quot;T&quot;&gt;Type of the storage.&lt;/typeparam&gt;</div>
	<div class="token cpp_comment ">/// &lt;remarks&gt;</div>
	<div class="token cpp_comment ">/// This class is designed to define global variables.</div>
	<div class="token cpp_comment ">/// Dynamically allocation will result in undefined behavior.</div>
	<div class="token cpp_comment ">/// &lt;/remarks&gt;</div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">typename</div> <div class="def" id="TA$vl::ThreadVariable::T"><div><div class="token cpp_type">T</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::ThreadVariable"><div class="ref" onclick="jumpToSymbol([], [], ['vl::ThreadVariable@<[T] *>'], [])"><div class="token cpp_type">ThreadVariable</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">private</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
	{
	<div class="token cpp_keyword ">protected</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadLocalStorage'], [], [])"><div class="token cpp_type">ThreadLocalStorage</div></div>						<div class="def" id="NI$vl::ThreadVariable::storage"><div><div class="token cpp_field">storage</div></div></div>;

		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::ThreadVariable::Destructor@void(void *)[impl0]"><div><div class="token cpp_function">Destructor</div></div></div>(<div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::ThreadVariable::Destructor@void(void *)[impl0]::data"><div><div class="token cpp_argument">data</div></div></div>)
		{
			<div class="token cpp_keyword ">if</div> (<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::Destructor@void(void *)[impl0]::data'], [], [])"><div class="token cpp_argument">data</div></div>)
			{
				<div class="token cpp_keyword ">delete</div> (<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::T'], [], [])"><div class="token cpp_type">T</div></div>*)<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::Destructor@void(void *)[impl0]::data'], [], [])"><div class="token cpp_argument">data</div></div>;
			}
		}
	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a thread local variable.&lt;/summary&gt;</div>
		<div class="def" id="FB$vl::ThreadVariable::$__ctor@()[impl0]"><div><div class="token cpp_function">ThreadVariable</div></div></div>()
			:storage(&amp;<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::Destructor@void(void *)'], [], [])"><div class="token cpp_function">Destructor</div></div>)
		{
		}

		<div class="def" id="FB$vl::ThreadVariable::~ThreadVariable@()[impl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">ThreadVariable</div></div></div>()
		{
		}

		<div class="token cpp_comment ">/// &lt;summary&gt;Test if the storage has data.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;Returns true if the storage has data.&lt;/returns&gt;</div>
		<div class="token cpp_keyword ">bool</div> <div class="def" id="FB$vl::ThreadVariable::HasData@bool()[impl0]"><div><div class="token cpp_function">HasData</div></div></div>()
		{
			<div class="token cpp_keyword ">return</div> <div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Get@void *()'], ['vl::ThreadLocalStorage::Get@void *()'], [], [])"><div class="token cpp_function">Get</div></div>() != <div class="token cpp_keyword ">nullptr</div>;
		}

		<div class="token cpp_comment ">/// &lt;summary&gt;Remove the data from this storage.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::ThreadVariable::Clear@void()[impl0]"><div><div class="token cpp_function">Clear</div></div></div>()
		{
			<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Clear@void()'], ['vl::ThreadLocalStorage::Clear@void()'], [], [])"><div class="token cpp_function">Clear</div></div>();
		}

		<div class="token cpp_comment ">/// &lt;summary&gt;Get the stored data.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;returns&gt;The stored ata.&lt;/returns&gt;</div>
		<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::T'], [], [])"><div class="token cpp_type">T</div></div>&amp; <div class="def" id="FB$vl::ThreadVariable::Get@[T] &()[impl0]"><div><div class="token cpp_function">Get</div></div></div>()
		{
			<div class="token cpp_keyword ">return</div> *(<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::T'], [], [])"><div class="token cpp_type">T</div></div>*)<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Get@void *()'], ['vl::ThreadLocalStorage::Get@void *()'], [], [])"><div class="token cpp_function">Get</div></div>();
		}

		<div class="token cpp_comment ">/// &lt;summary&gt;Set data to this storage.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;value&quot;&gt;The data to set.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::ThreadVariable::Set@void([T] const &)[impl0]"><div><div class="token cpp_function">Set</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::T'], [], [])"><div class="token cpp_type">T</div></div>&amp; <div class="def" id="NI$vl::ThreadVariable::Set@void([T] const &)[impl0]::value"><div><div class="token cpp_argument">value</div></div></div>)
		{
			<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Clear@void()'], ['vl::ThreadLocalStorage::Clear@void()'], [], [])"><div class="token cpp_function">Clear</div></div>();
			<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Set@void(void *)'], ['vl::ThreadLocalStorage::Set@void(void *)'], [], [])"><div class="token cpp_function">Set</div></div>(<div class="token cpp_keyword ">new</div> <div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::T'], [], [])"><div class="token cpp_type">T</div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable::Set@void([T] const &)[impl0]::value'], [], [])"><div class="token cpp_argument">value</div></div>));
		}
	};

	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">typename</div> <div class="def" id="TA$vl::ThreadVariable@<[T] *>::T"><div><div class="token cpp_type">T</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::ThreadVariable@<[T] *>"><div class="ref" onclick="jumpToSymbol([], [], [], ['vl::ThreadVariable'])"><div class="token cpp_type">ThreadVariable</div></div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::T'], [], [])"><div class="token cpp_type">T</div></div>*&gt; : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>, <div class="token cpp_keyword ">private</div> <div class="ref" onclick="jumpToSymbol([], ['vl::NotCopyable'], [], [])"><div class="token cpp_type">NotCopyable</div></div>
	{
	<div class="token cpp_keyword ">protected</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadLocalStorage'], [], [])"><div class="token cpp_type">ThreadLocalStorage</div></div>						<div class="def" id="NI$vl::ThreadVariable@<[T] *>::storage"><div><div class="token cpp_field">storage</div></div></div>;

	<div class="token cpp_keyword ">public</div>:
		<div class="def" id="FB$vl::ThreadVariable@<[T] *>::$__ctor@()[impl0]"><div><div class="token cpp_function">ThreadVariable</div></div></div>()
			:storage(<div class="token cpp_keyword ">nullptr</div>)
		{
		}

		<div class="def" id="FB$vl::ThreadVariable@<[T] *>::~ThreadVariable@()[impl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">ThreadVariable</div></div></div>()
		{
		}

		<div class="token cpp_keyword ">bool</div> <div class="def" id="FB$vl::ThreadVariable@<[T] *>::HasData@bool()[impl0]"><div><div class="token cpp_function">HasData</div></div></div>()
		{
			<div class="token cpp_keyword ">return</div> <div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Get@void *()'], ['vl::ThreadLocalStorage::Get@void *()'], [], [])"><div class="token cpp_function">Get</div></div>() != <div class="token cpp_keyword ">nullptr</div>;
		}

		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::ThreadVariable@<[T] *>::Clear@void()[impl0]"><div><div class="token cpp_function">Clear</div></div></div>()
		{
			<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Set@void(void *)'], ['vl::ThreadLocalStorage::Set@void(void *)'], [], [])"><div class="token cpp_function">Set</div></div>(<div class="token cpp_keyword ">nullptr</div>);
		}

		<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::T'], [], [])"><div class="token cpp_type">T</div></div>* <div class="def" id="FB$vl::ThreadVariable@<[T] *>::Get@[T] *()[impl0]"><div><div class="token cpp_function">Get</div></div></div>()
		{
			<div class="token cpp_keyword ">return</div> (<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::T'], [], [])"><div class="token cpp_type">T</div></div>*)<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Get@void *()'], ['vl::ThreadLocalStorage::Get@void *()'], [], [])"><div class="token cpp_function">Get</div></div>();
		}

		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::ThreadVariable@<[T] *>::Set@void([T] *)[impl0]"><div><div class="token cpp_function">Set</div></div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::T'], [], [])"><div class="token cpp_type">T</div></div>* <div class="def" id="NI$vl::ThreadVariable@<[T] *>::Set@void([T] *)[impl0]::value"><div><div class="token cpp_argument">value</div></div></div>)
		{
			<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::storage'], [], [])"><div class="token cpp_field">storage</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::ThreadLocalStorage::Set@void(void *)'], ['vl::ThreadLocalStorage::Set@void(void *)'], [], [])"><div class="token cpp_function">Set</div></div>((<div class="token cpp_keyword ">void</div>*)<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadVariable@<[T] *>::Set@void([T] *)[impl0]::value'], [], [])"><div class="token cpp_argument">value</div></div>);
		}
	};

<div class="token cpp_comment ">/***********************************************************************
RepeatingTaskExecutor
***********************************************************************/</div>

	<div class="token cpp_comment ">/// &lt;summary&gt;</div>
	<div class="token cpp_comment ">/// Queued task executor. It is different from a thread because:</div>
	<div class="token cpp_comment ">/// &lt;ul&gt;</div>
	<div class="token cpp_comment ">///   &lt;li&gt;Task execution is single threaded.&lt;/li&gt;</div>
	<div class="token cpp_comment ">///   &lt;li&gt;If you queue a task, it will override all unexecuted queued tasks.&lt;/li&gt;</div>
	<div class="token cpp_comment ">/// &lt;/ul&gt;</div>
	<div class="token cpp_comment ">/// &lt;/summary&gt;</div>
	<div class="token cpp_comment ">/// &lt;typeparam name=&quot;T&quot;&gt;The type of the argument to run a task.&lt;/typeparam&gt;</div>
	<div class="token cpp_keyword ">template</div>&lt;<div class="token cpp_keyword ">typename</div> <div class="def" id="TA$vl::RepeatingTaskExecutor::T"><div><div class="token cpp_type">T</div></div></div>&gt;
	<div class="token cpp_keyword ">class</div> <div class="def" id="NI$vl::RepeatingTaskExecutor"><div><div class="token cpp_type">RepeatingTaskExecutor</div></div></div> : <div class="token cpp_keyword ">public</div> <div class="ref" onclick="jumpToSymbol([], ['vl::Object'], [], [])"><div class="token cpp_type">Object</div></div>
	{
	<div class="token cpp_keyword ">private</div>:
		<div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock'], [], [])"><div class="token cpp_type">SpinLock</div></div>								<div class="def" id="NI$vl::RepeatingTaskExecutor::inputLock"><div><div class="token cpp_field">inputLock</div></div></div>;
		<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::T'], [], [])"><div class="token cpp_type">T</div></div>										<div class="def" id="NI$vl::RepeatingTaskExecutor::inputData"><div><div class="token cpp_field">inputData</div></div></div>;
		<div class="token cpp_keyword ">volatile</div> <div class="token cpp_keyword ">bool</div>							<div class="def" id="NI$vl::RepeatingTaskExecutor::inputDataAvailable"><div><div class="token cpp_field">inputDataAvailable</div></div></div>;
		<div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock'], [], [])"><div class="token cpp_type">SpinLock</div></div>								<div class="def" id="NI$vl::RepeatingTaskExecutor::executingEvent"><div><div class="token cpp_field">executingEvent</div></div></div>;
		<div class="token cpp_keyword ">volatile</div> <div class="token cpp_keyword ">bool</div>							<div class="def" id="NI$vl::RepeatingTaskExecutor::executing"><div><div class="token cpp_field">executing</div></div></div>;

		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]"><div><div class="token cpp_function">ExecutingProcInternal</div></div></div>()
		{
			<div class="token cpp_keyword ">while</div>(<div class="token cpp_keyword ">true</div>)
			{
				<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputDataAvailable"><div>currentInputDataAvailable</div></div>;
				<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::T'], [], [])"><div class="token cpp_type">T</div></div> <div class="def" id="NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputData"><div>currentInputData</div></div>;
<div class="expandable"><div class="disabled">				SPIN_LOCK(inputLock)</div>
<div class="expanded">				<div class="token cpp_keyword ">if</div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::__scope_variable_flag__"><div>__scope_variable_flag__</div></div>=<div class="token cpp_keyword ">true</div>) <div class="token cpp_keyword ">for</div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock'], [], [])"><div class="token cpp_type">SpinLock</div></div>::<div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock::Scope'], [], [])"><div class="token cpp_type">Scope</div></div>&amp; <div class="def" id="NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::scope"><div>scope</div></div> = <div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::inputLock'], [], [])"><div class="token cpp_field">inputLock</div></div>;<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::__scope_variable_flag__'], [], [])">__scope_variable_flag__</div>;<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::__scope_variable_flag__'], [], [])">__scope_variable_flag__</div>=<div class="token cpp_keyword ">false</div>)</div></div>
				{
					<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputData'], [], [])">currentInputData</div>=<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::inputData'], [], [])"><div class="token cpp_field">inputData</div></div>;
					<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::inputData'], [], [])"><div class="token cpp_field">inputData</div></div>=<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::T'], [], [])"><div class="token cpp_type">T</div></div>();
					<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputDataAvailable'], [], [])">currentInputDataAvailable</div>=<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::inputDataAvailable'], [], [])"><div class="token cpp_field">inputDataAvailable</div></div>;
					<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::inputDataAvailable'], [], [])"><div class="token cpp_field">inputDataAvailable</div></div>=<div class="token cpp_keyword ">false</div>;
					<div class="token cpp_keyword ">if</div>(!<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputDataAvailable'], [], [])">currentInputDataAvailable</div>)
					{
						<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::executing'], [], [])"><div class="token cpp_field">executing</div></div>=<div class="token cpp_keyword ">false</div>;
						<div class="token cpp_keyword ">goto</div> FINISH_EXECUTING;
					}
				}
				<div class="ref" onclick="jumpToSymbol(['vl::RepeatingTaskExecutor::Execute@void([T] const &)'], ['vl::RepeatingTaskExecutor::Execute@void([T] const &)'], [], [])"><div class="token cpp_function">Execute</div></div>(<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputData'], [], [])">currentInputData</div>);
			}
		FINISH_EXECUTING:
			<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::executingEvent'], [], [])"><div class="token cpp_field">executingEvent</div></div>.<div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock::Leave@void()'], [], [])"><div class="token cpp_function">Leave</div></div>();
		}

		<div class="token cpp_keyword ">static</div> <div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::RepeatingTaskExecutor::ExecutingProc@void(void *)[impl0]"><div><div class="token cpp_function">ExecutingProc</div></div></div>(<div class="token cpp_keyword ">void</div>* <div class="def" id="NI$vl::RepeatingTaskExecutor::ExecutingProc@void(void *)[impl0]::argument"><div><div class="token cpp_argument">argument</div></div></div>)
		{
			((<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor'], [], [])"><div class="token cpp_type">RepeatingTaskExecutor</div></div>&lt;<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::T'], [], [])"><div class="token cpp_type">T</div></div>&gt;*)<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::ExecutingProc@void(void *)[impl0]::argument'], [], [])"><div class="token cpp_argument">argument</div></div>)-&gt;<div class="ref" onclick="jumpToSymbol(['vl::RepeatingTaskExecutor::ExecutingProcInternal@void()'], ['vl::RepeatingTaskExecutor::ExecutingProcInternal@void()'], [], [])"><div class="token cpp_function">ExecutingProcInternal</div></div>();
		}
	
	<div class="token cpp_keyword ">protected</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;This function is called when it is ready to execute a task. Task execution is single threaded. All task code should be put inside the function.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;input&quot;&gt;The argument to run a task.&lt;/param&gt;</div>
		<div class="token cpp_keyword ">virtual</div> <div class="token cpp_keyword ">void</div>							<div class="def" id="FB$vl::RepeatingTaskExecutor::Execute@void([T] const &)[decl0]"><div><div class="token cpp_function">Execute</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::T'], [], [])"><div class="token cpp_type">T</div></div>&amp; <div class="def" id="NI$vl::RepeatingTaskExecutor::Execute@void([T] const &)[decl0]::input"><div>input</div></div>)=<div class="token cpp_number ">0</div>;

	<div class="token cpp_keyword ">public</div>:
		<div class="token cpp_comment ">/// &lt;summary&gt;Create a task executor.&lt;/summary&gt;</div>
		<div class="def" id="FB$vl::RepeatingTaskExecutor::$__ctor@()[impl0]"><div><div class="token cpp_function">RepeatingTaskExecutor</div></div></div>()
			:inputDataAvailable(<div class="token cpp_keyword ">false</div>)
			,executing(<div class="token cpp_keyword ">false</div>)
		{
		}

		<div class="def" id="FB$vl::RepeatingTaskExecutor::~RepeatingTaskExecutor@()[impl0]"><div><div class="token cpp_function">~</div><div class="token cpp_function">RepeatingTaskExecutor</div></div></div>()
		{
			<div class="ref" onclick="jumpToSymbol(['vl::RepeatingTaskExecutor::EnsureTaskFinished@void()'], ['vl::RepeatingTaskExecutor::EnsureTaskFinished@void()'], [], [])"><div class="token cpp_function">EnsureTaskFinished</div></div>();
		}

		<div class="token cpp_comment ">/// &lt;summary&gt;Wait for all tasks to finish.&lt;/summary&gt;</div>
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::RepeatingTaskExecutor::EnsureTaskFinished@void()[impl0]"><div><div class="token cpp_function">EnsureTaskFinished</div></div></div>()
		{
			<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::executingEvent'], [], [])"><div class="token cpp_field">executingEvent</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::SpinLock::Enter@void()'], ['vl::SpinLock::Enter@void()'], [], [])"><div class="token cpp_function">Enter</div></div>();
			<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::executingEvent'], [], [])"><div class="token cpp_field">executingEvent</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::SpinLock::Leave@void()'], ['vl::SpinLock::Leave@void()'], [], [])"><div class="token cpp_function">Leave</div></div>();
		}

		<div class="token cpp_comment ">/// &lt;summary&gt;Queue a task.&lt;/summary&gt;</div>
		<div class="token cpp_comment ">/// &lt;param name=&quot;input&quot;&gt;The argument to run a task.&lt;/param&gt;</div>
		<div class="token cpp_comment ">/// &lt;remarks&gt;</div>
		<div class="token cpp_comment ">/// &lt;p&gt;</div>
		<div class="token cpp_comment ">/// When there is a running task, queuing a new task will cancel all unexecuted queued tasks.</div>
		<div class="token cpp_comment ">/// When there is no running task, queuing a task will execute this task immediately.</div>
		<div class="token cpp_comment ">/// &lt;/p&gt;</div>
		<div class="token cpp_comment ">/// &lt;/remarks&gt;</div>
		<div class="token cpp_keyword ">void</div> <div class="def" id="FB$vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]"><div><div class="token cpp_function">SubmitTask</div></div></div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::T'], [], [])"><div class="token cpp_type">T</div></div>&amp; <div class="def" id="NI$vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::input"><div><div class="token cpp_argument">input</div></div></div>)
		{
<div class="expandable"><div class="disabled">			SPIN_LOCK(inputLock)</div>
<div class="expanded">			<div class="token cpp_keyword ">if</div>(<div class="token cpp_keyword ">bool</div> <div class="def" id="NI$vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::__scope_variable_flag__"><div>__scope_variable_flag__</div></div>=<div class="token cpp_keyword ">true</div>) <div class="token cpp_keyword ">for</div>(<div class="token cpp_keyword ">const</div> <div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock'], [], [])"><div class="token cpp_type">SpinLock</div></div>::<div class="ref" onclick="jumpToSymbol([], ['vl::SpinLock::Scope'], [], [])"><div class="token cpp_type">Scope</div></div>&amp; <div class="def" id="NI$vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::scope"><div>scope</div></div> = <div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::inputLock'], [], [])"><div class="token cpp_field">inputLock</div></div>;<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::__scope_variable_flag__'], [], [])">__scope_variable_flag__</div>;<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::__scope_variable_flag__'], [], [])">__scope_variable_flag__</div>=<div class="token cpp_keyword ">false</div>)</div></div>
			{
				<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::inputData'], [], [])"><div class="token cpp_field">inputData</div></div>=<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::input'], [], [])"><div class="token cpp_argument">input</div></div>;
				<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::inputDataAvailable'], [], [])"><div class="token cpp_field">inputDataAvailable</div></div>=<div class="token cpp_keyword ">true</div>;
			}
			<div class="token cpp_keyword ">if</div>(!<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::executing'], [], [])"><div class="token cpp_field">executing</div></div>)
			{
				<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::executing'], [], [])"><div class="token cpp_field">executing</div></div>=<div class="token cpp_keyword ">true</div>;
				<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::executingEvent'], [], [])"><div class="token cpp_field">executingEvent</div></div>.<div class="ref" onclick="jumpToSymbol(['vl::SpinLock::Enter@void()'], ['vl::SpinLock::Enter@void()'], [], [])"><div class="token cpp_function">Enter</div></div>();
				<div class="ref" onclick="jumpToSymbol([], ['vl::ThreadPoolLite'], [], [])"><div class="token cpp_type">ThreadPoolLite</div></div>::<div class="ref" onclick="jumpToSymbol(['vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)'], ['vl::ThreadPoolLite::Queue@bool(::vl::Func<void()> const &)', 'vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)'], [], [])"><div class="token cpp_function">Queue</div></div>(&amp;<div class="ref" onclick="jumpToSymbol([], ['vl::RepeatingTaskExecutor::ExecutingProc@void(void *)'], [], [])"><div class="token cpp_function">ExecutingProc</div></div>, <div class="token cpp_keyword ">this</div>);
			}
		}
	};
}
<div class="disabled">#endif
</div>
</div></div>
<script type="text/javascript">
referencedSymbols = {
    'vl': {
        'displayNameInHtml': 'vl',
        'impls': [],
        'decls': [
            'NF[0]$vl',
            'NF[1]$vl',
            'NF[2]$vl',
            'NF[3]$vl',
            'NF[4]$vl',
            'NF[5]$vl',
            'NF[6]$vl',
            'NF[7]$vl',
            'NF[8]$vl',
            'NF[9]$vl',
            'NF[10]$vl',
            'NF[11]$vl',
            'NF[12]$vl',
            'NF[13]$vl',
            'NF[14]$vl',
            'NF[15]$vl',
            'NF[16]$vl',
            'NF[17]$vl',
            'NF[18]$vl',
            'NF[19]$vl',
            'NF[20]$vl',
            'NF[21]$vl',
            'NF[22]$vl',
            'NF[23]$vl',
            'NF[24]$vl',
            'NF[25]$vl',
            'NF[26]$vl',
            'NF[27]$vl',
            'NF[28]$vl',
            'NF[29]$vl',
            'NF[30]$vl',
            'NF[31]$vl',
            'NF[32]$vl',
            'NF[33]$vl',
            'NF[34]$vl',
            'NF[35]$vl',
            'NF[36]$vl',
            'NF[37]$vl',
            'NF[38]$vl',
            'NF[39]$vl',
            'NF[40]$vl'
        ]
    },
    'vl::ConditionVariable': {
        'displayNameInHtml': '<span class="cpp_type">ConditionVariable</span>',
        'impls': [
            'NI$vl::ConditionVariable'
        ],
        'decls': []
    },
    'vl::CriticalSection': {
        'displayNameInHtml': '<span class="cpp_type">CriticalSection</span>',
        'impls': [
            'NI$vl::CriticalSection'
        ],
        'decls': []
    },
    'vl::Func': {
        'displayNameInHtml': '<span class="cpp_type">Func</span>&lt;<span class="cpp_type">T</span>&gt;',
        'impls': [],
        'decls': [
            'NF[0]$vl::Func'
        ]
    },
    'vl::Func@<[R]([TArgs]...)>': {
        'displayNameInHtml': '<span class="cpp_type">Func</span>&lt;<span class="cpp_type">R</span>(<span class="cpp_type">TArgs</span>...)&gt;',
        'impls': [
            'NI$vl::Func@<[R]([TArgs]...)>'
        ],
        'decls': []
    },
    'vl::LockedInt': {
        'displayNameInHtml': '<span class="cpp_type">LockedInt</span>',
        'impls': [
            'NI$vl::LockedInt'
        ],
        'decls': []
    },
    'vl::NotCopyable': {
        'displayNameInHtml': '<span class="cpp_type">NotCopyable</span>',
        'impls': [
            'NI$vl::NotCopyable'
        ],
        'decls': []
    },
    'vl::Object': {
        'displayNameInHtml': '<span class="cpp_type">Object</span>',
        'impls': [
            'NI$vl::Object'
        ],
        'decls': []
    },
    'vl::ReaderWriterLock': {
        'displayNameInHtml': '<span class="cpp_type">ReaderWriterLock</span>',
        'impls': [
            'NI$vl::ReaderWriterLock'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;',
        'impls': [
            'NI$vl::RepeatingTaskExecutor'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::EnsureTaskFinished@void()': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_function">EnsureTaskFinished</span>()',
        'impls': [
            'FB$vl::RepeatingTaskExecutor::EnsureTaskFinished@void()[impl0]'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::Execute@void([T] const &)': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_function">Execute</span>(<span class="cpp_type">T</span> <span class="cpp_keyword">const</span> &)',
        'impls': [],
        'decls': [
            'FB$vl::RepeatingTaskExecutor::Execute@void([T] const &)[decl0]'
        ]
    },
    'vl::RepeatingTaskExecutor::ExecutingProc@void(void *)': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_function">ExecutingProc</span>(<span class="cpp_keyword">void</span> *)',
        'impls': [
            'FB$vl::RepeatingTaskExecutor::ExecutingProc@void(void *)[impl0]'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::ExecutingProc@void(void *)[impl0]::argument': {
        'displayNameInHtml': 'argument',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::ExecutingProc@void(void *)[impl0]::argument'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::ExecutingProcInternal@void()': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_function">ExecutingProcInternal</span>()',
        'impls': [
            'FB$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::__scope_variable_flag__': {
        'displayNameInHtml': '__scope_variable_flag__',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::__scope_variable_flag__'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputData': {
        'displayNameInHtml': 'currentInputData',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputData'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputDataAvailable': {
        'displayNameInHtml': 'currentInputDataAvailable',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputDataAvailable'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::__scope_variable_flag__': {
        'displayNameInHtml': '__scope_variable_flag__',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::__scope_variable_flag__'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::input': {
        'displayNameInHtml': 'input',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::input'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::T': {
        'displayNameInHtml': '<span class="cpp_type">T</span>',
        'impls': [
            'TA$vl::RepeatingTaskExecutor::T'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::executing': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_field">executing</span>',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::executing'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::executingEvent': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_field">executingEvent</span>',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::executingEvent'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::inputData': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_field">inputData</span>',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::inputData'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::inputDataAvailable': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_field">inputDataAvailable</span>',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::inputDataAvailable'
        ],
        'decls': []
    },
    'vl::RepeatingTaskExecutor::inputLock': {
        'displayNameInHtml': '<span class="cpp_type">RepeatingTaskExecutor</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_field">inputLock</span>',
        'impls': [
            'NI$vl::RepeatingTaskExecutor::inputLock'
        ],
        'decls': []
    },
    'vl::SpinLock': {
        'displayNameInHtml': '<span class="cpp_type">SpinLock</span>',
        'impls': [
            'NI$vl::SpinLock'
        ],
        'decls': []
    },
    'vl::SpinLock::Enter@void()': {
        'displayNameInHtml': '<span class="cpp_type">SpinLock</span>::<span class="cpp_function">Enter</span>()',
        'impls': [],
        'decls': [
            'FB$vl::SpinLock::Enter@void()[decl0]'
        ]
    },
    'vl::SpinLock::Leave@void()': {
        'displayNameInHtml': '<span class="cpp_type">SpinLock</span>::<span class="cpp_function">Leave</span>()',
        'impls': [],
        'decls': [
            'FB$vl::SpinLock::Leave@void()[decl0]'
        ]
    },
    'vl::SpinLock::Scope': {
        'displayNameInHtml': '<span class="cpp_type">SpinLock</span>::<span class="cpp_type">Scope</span>',
        'impls': [
            'NI$vl::SpinLock::Scope'
        ],
        'decls': []
    },
    'vl::Thread': {
        'displayNameInHtml': '<span class="cpp_type">Thread</span>',
        'impls': [
            'NI$vl::Thread'
        ],
        'decls': []
    },
    'vl::Thread::ThreadProcedure': {
        'displayNameInHtml': '<span class="cpp_type">Thread</span>::<span class="cpp_type">ThreadProcedure</span>',
        'impls': [
            'NI$vl::Thread::ThreadProcedure'
        ],
        'decls': []
    },
    'vl::Thread::ThreadState': {
        'displayNameInHtml': '<span class="cpp_type">Thread</span>::<span class="cpp_type">ThreadState</span>',
        'impls': [
            'NI$vl::Thread::ThreadState'
        ],
        'decls': []
    },
    'vl::ThreadLocalStorage': {
        'displayNameInHtml': '<span class="cpp_type">ThreadLocalStorage</span>',
        'impls': [
            'NI$vl::ThreadLocalStorage'
        ],
        'decls': []
    },
    'vl::ThreadLocalStorage::Clear@void()': {
        'displayNameInHtml': '<span class="cpp_type">ThreadLocalStorage</span>::<span class="cpp_function">Clear</span>()',
        'impls': [],
        'decls': [
            'FB$vl::ThreadLocalStorage::Clear@void()[decl0]'
        ]
    },
    'vl::ThreadLocalStorage::Destructor': {
        'displayNameInHtml': '<span class="cpp_type">ThreadLocalStorage</span>::<span class="cpp_type">Destructor</span>',
        'impls': [
            'NI$vl::ThreadLocalStorage::Destructor'
        ],
        'decls': []
    },
    'vl::ThreadLocalStorage::Get@void *()': {
        'displayNameInHtml': '<span class="cpp_type">ThreadLocalStorage</span>::<span class="cpp_function">Get</span>()',
        'impls': [],
        'decls': [
            'FB$vl::ThreadLocalStorage::Get@void *()[decl0]'
        ]
    },
    'vl::ThreadLocalStorage::Set@void(void *)': {
        'displayNameInHtml': '<span class="cpp_type">ThreadLocalStorage</span>::<span class="cpp_function">Set</span>(<span class="cpp_keyword">void</span> *)',
        'impls': [],
        'decls': [
            'FB$vl::ThreadLocalStorage::Set@void(void *)[decl0]'
        ]
    },
    'vl::ThreadPoolLite': {
        'displayNameInHtml': '<span class="cpp_type">ThreadPoolLite</span>',
        'impls': [
            'NI$vl::ThreadPoolLite'
        ],
        'decls': []
    },
    'vl::ThreadPoolLite::Queue@bool(::vl::Func<void()> const &)': {
        'displayNameInHtml': '<span class="cpp_type">ThreadPoolLite</span>::<span class="cpp_function">Queue</span>(<span class="cpp_type">Func</span>&lt;<span class="cpp_keyword">void</span>()&gt; <span class="cpp_keyword">const</span> &)',
        'impls': [],
        'decls': [
            'FB$vl::ThreadPoolLite::Queue@bool(::vl::Func<void()> const &)[decl0]'
        ]
    },
    'vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)': {
        'displayNameInHtml': '<span class="cpp_type">ThreadPoolLite</span>::<span class="cpp_function">Queue</span>(<span class="cpp_keyword">void</span>( *)(<span class="cpp_keyword">void</span> *), <span class="cpp_keyword">void</span> *)',
        'impls': [],
        'decls': [
            'FB$vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)[decl0]'
        ]
    },
    'vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::T': {
        'displayNameInHtml': '<span class="cpp_type">T</span>',
        'impls': [
            'TA$vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::T'
        ],
        'decls': []
    },
    'vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::proc': {
        'displayNameInHtml': 'proc',
        'impls': [
            'NI$vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::proc'
        ],
        'decls': []
    },
    'vl::ThreadVariable': {
        'displayNameInHtml': '<span class="cpp_type">ThreadVariable</span>&lt;<span class="cpp_type">T</span>&gt;',
        'impls': [
            'NI$vl::ThreadVariable'
        ],
        'decls': []
    },
    'vl::ThreadVariable::Destructor@void(void *)': {
        'displayNameInHtml': '<span class="cpp_type">ThreadVariable</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_function">Destructor</span>(<span class="cpp_keyword">void</span> *)',
        'impls': [
            'FB$vl::ThreadVariable::Destructor@void(void *)[impl0]'
        ],
        'decls': []
    },
    'vl::ThreadVariable::Destructor@void(void *)[impl0]::data': {
        'displayNameInHtml': 'data',
        'impls': [
            'NI$vl::ThreadVariable::Destructor@void(void *)[impl0]::data'
        ],
        'decls': []
    },
    'vl::ThreadVariable::Set@void([T] const &)[impl0]::value': {
        'displayNameInHtml': 'value',
        'impls': [
            'NI$vl::ThreadVariable::Set@void([T] const &)[impl0]::value'
        ],
        'decls': []
    },
    'vl::ThreadVariable::T': {
        'displayNameInHtml': '<span class="cpp_type">T</span>',
        'impls': [
            'TA$vl::ThreadVariable::T'
        ],
        'decls': []
    },
    'vl::ThreadVariable::storage': {
        'displayNameInHtml': '<span class="cpp_type">ThreadVariable</span>&lt;<span class="cpp_type">T</span>&gt;::<span class="cpp_field">storage</span>',
        'impls': [
            'NI$vl::ThreadVariable::storage'
        ],
        'decls': []
    },
    'vl::ThreadVariable@<[T] *>': {
        'displayNameInHtml': '<span class="cpp_type">ThreadVariable</span>&lt;<span class="cpp_type">T</span> *&gt;',
        'impls': [
            'NI$vl::ThreadVariable@<[T] *>'
        ],
        'decls': []
    },
    'vl::ThreadVariable@<[T] *>::Set@void([T] *)[impl0]::value': {
        'displayNameInHtml': 'value',
        'impls': [
            'NI$vl::ThreadVariable@<[T] *>::Set@void([T] *)[impl0]::value'
        ],
        'decls': []
    },
    'vl::ThreadVariable@<[T] *>::T': {
        'displayNameInHtml': '<span class="cpp_type">T</span>',
        'impls': [
            'TA$vl::ThreadVariable@<[T] *>::T'
        ],
        'decls': []
    },
    'vl::ThreadVariable@<[T] *>::storage': {
        'displayNameInHtml': '<span class="cpp_type">ThreadVariable</span>&lt;<span class="cpp_type">T</span> *&gt;::<span class="cpp_field">storage</span>',
        'impls': [
            'NI$vl::ThreadVariable@<[T] *>::storage'
        ],
        'decls': []
    },
    'vl::WString': {
        'displayNameInHtml': '<span class="cpp_type">WString</span>',
        'impls': [
            'NI$vl::WString'
        ],
        'decls': []
    },
    'vl::WaitableObject': {
        'displayNameInHtml': '<span class="cpp_type">WaitableObject</span>',
        'impls': [
            'NI$vl::WaitableObject'
        ],
        'decls': []
    },
    'vl::threading_internal': {
        'displayNameInHtml': 'vl::threading_internal',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal'
        ]
    },
    'vl::threading_internal::ConditionVariableData': {
        'displayNameInHtml': '<span class="cpp_type">ConditionVariableData</span>',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal::ConditionVariableData'
        ]
    },
    'vl::threading_internal::CriticalSectionData': {
        'displayNameInHtml': '<span class="cpp_type">CriticalSectionData</span>',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal::CriticalSectionData'
        ]
    },
    'vl::threading_internal::EventData': {
        'displayNameInHtml': '<span class="cpp_type">EventData</span>',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal::EventData'
        ]
    },
    'vl::threading_internal::MutexData': {
        'displayNameInHtml': '<span class="cpp_type">MutexData</span>',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal::MutexData'
        ]
    },
    'vl::threading_internal::ReaderWriterLockData': {
        'displayNameInHtml': '<span class="cpp_type">ReaderWriterLockData</span>',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal::ReaderWriterLockData'
        ]
    },
    'vl::threading_internal::SemaphoreData': {
        'displayNameInHtml': '<span class="cpp_type">SemaphoreData</span>',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal::SemaphoreData'
        ]
    },
    'vl::threading_internal::ThreadData': {
        'displayNameInHtml': '<span class="cpp_type">ThreadData</span>',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal::ThreadData'
        ]
    },
    'vl::threading_internal::WaitableData': {
        'displayNameInHtml': '<span class="cpp_type">WaitableData</span>',
        'impls': [],
        'decls': [
            'NF[0]$vl::threading_internal::WaitableData'
        ]
    },
    'vl::vint': {
        'displayNameInHtml': '<span class="cpp_type">vint</span>',
        'impls': [
            'NI$vl::vint'
        ],
        'decls': []
    },
    'vl::vuint64_t': {
        'displayNameInHtml': '<span class="cpp_type">vuint64_t</span>',
        'impls': [
            'NI$vl::vuint64_t'
        ],
        'decls': []
    }
};
symbolToFiles = {
    'FB$vl::RepeatingTaskExecutor::EnsureTaskFinished@void()[impl0]': null,
    'FB$vl::RepeatingTaskExecutor::Execute@void([T] const &)[decl0]': null,
    'FB$vl::RepeatingTaskExecutor::ExecutingProc@void(void *)[impl0]': null,
    'FB$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]': null,
    'FB$vl::SpinLock::Enter@void()[decl0]': null,
    'FB$vl::SpinLock::Leave@void()[decl0]': null,
    'FB$vl::ThreadLocalStorage::Clear@void()[decl0]': null,
    'FB$vl::ThreadLocalStorage::Get@void *()[decl0]': null,
    'FB$vl::ThreadLocalStorage::Set@void(void *)[decl0]': null,
    'FB$vl::ThreadPoolLite::Queue@bool(::vl::Func<void()> const &)[decl0]': null,
    'FB$vl::ThreadPoolLite::Queue@bool(void(void *) *, void *)[decl0]': null,
    'FB$vl::ThreadVariable::Destructor@void(void *)[impl0]': null,
    'NF[0]$vl': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' },
    'NF[0]$vl::Func': { 'htmlFileName': 'Function.h', 'displayName': 'Function.h' },
    'NF[0]$vl::threading_internal': null,
    'NF[0]$vl::threading_internal::ConditionVariableData': null,
    'NF[0]$vl::threading_internal::CriticalSectionData': null,
    'NF[0]$vl::threading_internal::EventData': null,
    'NF[0]$vl::threading_internal::MutexData': null,
    'NF[0]$vl::threading_internal::ReaderWriterLockData': null,
    'NF[0]$vl::threading_internal::SemaphoreData': null,
    'NF[0]$vl::threading_internal::ThreadData': null,
    'NF[0]$vl::threading_internal::WaitableData': null,
    'NF[10]$vl': { 'htmlFileName': 'Interfaces.h', 'displayName': 'Interfaces.h' },
    'NF[11]$vl': { 'htmlFileName': 'List.h', 'displayName': 'List.h' },
    'NF[12]$vl': { 'htmlFileName': 'Dictionary.h', 'displayName': 'Dictionary.h' },
    'NF[13]$vl': { 'htmlFileName': 'OperationCopyFrom.h', 'displayName': 'OperationCopyFrom.h' },
    'NF[14]$vl': { 'htmlFileName': 'OperationEnumerable.h', 'displayName': 'OperationEnumerable.h' },
    'NF[15]$vl': { 'htmlFileName': 'OperationConcat.h', 'displayName': 'OperationConcat.h' },
    'NF[16]$vl': { 'htmlFileName': 'OperationForEach.h', 'displayName': 'OperationForEach.h' },
    'NF[17]$vl': { 'htmlFileName': 'OperationPair.h', 'displayName': 'OperationPair.h' },
    'NF[18]$vl': { 'htmlFileName': 'OperationSelect.h', 'displayName': 'OperationSelect.h' },
    'NF[19]$vl': { 'htmlFileName': 'OperationSequence.h', 'displayName': 'OperationSequence.h' },
    'NF[1]$vl': { 'htmlFileName': 'Pointer.h', 'displayName': 'Pointer.h' },
    'NF[20]$vl': { 'htmlFileName': 'OperationSet.h', 'displayName': 'OperationSet.h' },
    'NF[21]$vl': { 'htmlFileName': 'OperationString.h', 'displayName': 'OperationString.h' },
    'NF[22]$vl': { 'htmlFileName': 'OperationWhere.h', 'displayName': 'OperationWhere.h' },
    'NF[23]$vl': { 'htmlFileName': 'Operation.h', 'displayName': 'Operation.h' },
    'NF[24]$vl': { 'htmlFileName': 'Event.h', 'displayName': 'Event.h' },
    'NF[25]$vl': { 'htmlFileName': 'PartialOrdering.h', 'displayName': 'PartialOrdering.h' },
    'NF[26]$vl': { 'htmlFileName': 'UnitTest.h', 'displayName': 'UnitTest.h' },
    'NF[27]$vl': { 'htmlFileName': 'HttpUtility.h', 'displayName': 'HttpUtility.h' },
    'NF[28]$vl': { 'htmlFileName': 'Locale.h', 'displayName': 'Locale.h' },
    'NF[29]$vl': null,
    'NF[2]$vl': { 'htmlFileName': 'Function.h', 'displayName': 'Function.h' },
    'NF[30]$vl': { 'htmlFileName': 'Interfaces.h2', 'displayName': 'Interfaces.h' },
    'NF[31]$vl': { 'htmlFileName': 'BroadcastStream.h', 'displayName': 'BroadcastStream.h' },
    'NF[32]$vl': { 'htmlFileName': 'CacheStream.h', 'displayName': 'CacheStream.h' },
    'NF[33]$vl': { 'htmlFileName': 'CompressionStream.h', 'displayName': 'CompressionStream.h' },
    'NF[34]$vl': { 'htmlFileName': 'FileStream.h', 'displayName': 'FileStream.h' },
    'NF[35]$vl': { 'htmlFileName': 'MemoryStream.h', 'displayName': 'MemoryStream.h' },
    'NF[36]$vl': { 'htmlFileName': 'Accessor.h', 'displayName': 'Accessor.h' },
    'NF[37]$vl': { 'htmlFileName': 'MemoryWrapperStream.h', 'displayName': 'MemoryWrapperStream.h' },
    'NF[38]$vl': { 'htmlFileName': 'CharFormat.h', 'displayName': 'CharFormat.h' },
    'NF[39]$vl': { 'htmlFileName': 'FileSystem.h', 'displayName': 'FileSystem.h' },
    'NF[3]$vl': { 'htmlFileName': 'Lazy.h', 'displayName': 'Lazy.h' },
    'NF[40]$vl': { 'htmlFileName': 'RecorderStream.h', 'displayName': 'RecorderStream.h' },
    'NF[4]$vl': { 'htmlFileName': 'String.h', 'displayName': 'String.h' },
    'NF[5]$vl': { 'htmlFileName': 'Console.h', 'displayName': 'Console.h' },
    'NF[6]$vl': { 'htmlFileName': 'Exception.h', 'displayName': 'Exception.h' },
    'NF[7]$vl': { 'htmlFileName': 'GlobalStorage.h', 'displayName': 'GlobalStorage.h' },
    'NF[8]$vl': { 'htmlFileName': 'Tuple.h', 'displayName': 'Tuple.h' },
    'NF[9]$vl': { 'htmlFileName': 'Pair.h', 'displayName': 'Pair.h' },
    'NI$vl::ConditionVariable': null,
    'NI$vl::CriticalSection': null,
    'NI$vl::Func@<[R]([TArgs]...)>': { 'htmlFileName': 'Function.h', 'displayName': 'Function.h' },
    'NI$vl::LockedInt': null,
    'NI$vl::NotCopyable': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' },
    'NI$vl::Object': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' },
    'NI$vl::ReaderWriterLock': null,
    'NI$vl::RepeatingTaskExecutor': null,
    'NI$vl::RepeatingTaskExecutor::ExecutingProc@void(void *)[impl0]::argument': null,
    'NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::__scope_variable_flag__': null,
    'NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputData': null,
    'NI$vl::RepeatingTaskExecutor::ExecutingProcInternal@void()[impl0]::currentInputDataAvailable': null,
    'NI$vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::__scope_variable_flag__': null,
    'NI$vl::RepeatingTaskExecutor::SubmitTask@void([T] const &)[impl0]::input': null,
    'NI$vl::RepeatingTaskExecutor::executing': null,
    'NI$vl::RepeatingTaskExecutor::executingEvent': null,
    'NI$vl::RepeatingTaskExecutor::inputData': null,
    'NI$vl::RepeatingTaskExecutor::inputDataAvailable': null,
    'NI$vl::RepeatingTaskExecutor::inputLock': null,
    'NI$vl::SpinLock': null,
    'NI$vl::SpinLock::Scope': null,
    'NI$vl::Thread': null,
    'NI$vl::Thread::ThreadProcedure': null,
    'NI$vl::Thread::ThreadState': null,
    'NI$vl::ThreadLocalStorage': null,
    'NI$vl::ThreadLocalStorage::Destructor': null,
    'NI$vl::ThreadPoolLite': null,
    'NI$vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::proc': null,
    'NI$vl::ThreadVariable': null,
    'NI$vl::ThreadVariable::Destructor@void(void *)[impl0]::data': null,
    'NI$vl::ThreadVariable::Set@void([T] const &)[impl0]::value': null,
    'NI$vl::ThreadVariable::storage': null,
    'NI$vl::ThreadVariable@<[T] *>': null,
    'NI$vl::ThreadVariable@<[T] *>::Set@void([T] *)[impl0]::value': null,
    'NI$vl::ThreadVariable@<[T] *>::storage': null,
    'NI$vl::WString': { 'htmlFileName': 'String.h', 'displayName': 'String.h' },
    'NI$vl::WaitableObject': null,
    'NI$vl::vint': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' },
    'NI$vl::vuint64_t': { 'htmlFileName': 'Basic.h', 'displayName': 'Basic.h' },
    'TA$vl::RepeatingTaskExecutor::T': null,
    'TA$vl::ThreadPoolLite::QueueLambda@void([T] const &)[impl0]::T': null,
    'TA$vl::ThreadVariable::T': null,
    'TA$vl::ThreadVariable@<[T] *>::T': null
};
turnOnSymbol();
</script>
</body>
</html>
