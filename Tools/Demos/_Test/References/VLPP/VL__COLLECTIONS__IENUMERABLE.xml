<Document symbolId="vl::collections::IEnumerable" accessor="" category="Class" name="IEnumerable" declFile="Interfaces.h" declId="NI$vl::collections::IEnumerable"><summary>
 An enumerable interface representing all types that provide multiple values in order.
 range-based for-loop is not supported on enumerable yet, current we have &quot;FOREACH&quot; and &quot;FOREACH_INDEXER&quot; for iterating values.
 <symbols><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [Ss] const &amp;, bool)" declFile="OperationCopyFrom.h" declId="FB$vl::collections::CopyFrom@void([Ds] &amp;, [Ss] const &amp;, bool)[impl0]"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, ::vl::vint, bool)" declFile="OperationCopyFrom.h" declId="FB$vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, ::vl::vint, bool)[impl0]"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, [S] const *, bool)" declFile="OperationCopyFrom.h" declId="FB$vl::collections::CopyFrom@void([Ds] &amp;, [S] const *, [S] const *, bool)[impl0]"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void([Ds] &amp;, ::vl::ObjectString&lt;[S]&gt; const &amp;, bool)" declFile="OperationString.h" declId="FB$vl::collections::CopyFrom@void([Ds] &amp;, ::vl::ObjectString&lt;[S]&gt; const &amp;, bool)[impl0]"/><symbol name="CopyFrom" docId="vl::collections::CopyFrom@void(::vl::ObjectString&lt;[D]&gt; &amp;, [Ss] const &amp;, bool)" declFile="OperationString.h" declId="FB$vl::collections::CopyFrom@void(::vl::ObjectString&lt;[D]&gt; &amp;, [Ss] const &amp;, bool)[impl0]"/></symbols> functions work for all enumerable implementation.
 <symbol name="LazyList" docId="vl::collections::LazyList" declFile="Operation.h" declId="NI$vl::collections::LazyList"/> provides high-level operations for enumerables, you can create a lazy list by calling <symbols><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::IEnumerable&lt;[T]&gt; const &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::LazyList&lt;[T]&gt; const &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;(::vl::collections::LazyList&lt;[T]&gt; const &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const *, [T] const *)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const *, [T] const *)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] [*] &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] [*] &amp;)[impl0]"/><symbol name="From" docId="vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const [*] &amp;)" declFile="Operation.h" declId="FB$vl::collections::From@::vl::collections::LazyList&lt;[T]&gt;([T] const [*] &amp;)[impl0]"/></symbols> on any enumerables.
 </summary><example index="0"/><typeparam name="T">Type of the values in the enumerable.</typeparam><signature><![CDATA[template <
    typename T
>
class IEnumerable
    : Interface;
]]></signature><basetypes><symbol name="Interface" docId="vl::Interface" declFile="Basic.h" declId="NI$vl::Interface"/></basetypes></Document>